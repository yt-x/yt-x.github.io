<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python Selenium库</title>
    <url>/2023/03/06/Python-Selenium%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Python-Selenium库"><a href="#Python-Selenium库" class="headerlink" title="Python Selenium库"></a>Python Selenium库</h1><h2 id="Selenium基础"><a href="#Selenium基础" class="headerlink" title="Selenium基础"></a>Selenium基础</h2><p>​	Selenium是一个用于测试网站的自动化测试工具，支持各种浏览器包括Chrome、Firefox、Safari等主流界面浏览器，同时也支持phantomJS无界面浏览器。</p>
<h3 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h3><p>​	<code>pip install Selenium</code></p>
<h3 id="安装浏览器驱动"><a href="#安装浏览器驱动" class="headerlink" title="安装浏览器驱动"></a>安装浏览器驱动</h3><p>​	谷歌浏览器下载链接 <a target="_blank" rel="noopener" href="https://chromedriver.storage.googleapis.com/index.html?path=2.35/">https://chromedriver.storage.googleapis.com/index.html?path=2.35/</a></p>
<p>​	火狐浏览器下载链接 <a target="_blank" rel="noopener" href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>​	设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： F:\GeckoDriver , 将下载的浏览器驱动文件（例如：chromedriver、geckodriver）丢到该目录下。</p>
<p><strong>我的电脑–&gt;属性–&gt;系统设置–&gt;高级–&gt;环境变量–&gt;系统变量–&gt;Path，将“F:\GeckoDriver”目录添加到Path的值中。比如：Path字段;F:\GeckoDriver</strong></p>
<span id="more"></span>


<h2 id="Selenium-快速入门"><a href="#Selenium-快速入门" class="headerlink" title="Selenium 快速入门"></a>Selenium 快速入门</h2><h3 id="Selenium提供了8种定位方式"><a href="#Selenium提供了8种定位方式" class="headerlink" title="Selenium提供了8种定位方式"></a>Selenium提供了8种定位方式</h3><ol>
<li>id</li>
<li>name</li>
<li>class name</li>
<li>tag name</li>
<li>link text</li>
<li>partial link text</li>
<li>xpath</li>
<li>css selector</li>
</ol>
<h3 id="定位元素的8种方式"><a href="#定位元素的8种方式" class="headerlink" title="定位元素的8种方式"></a>定位元素的8种方式</h3><table>
<thead>
<tr>
<th>定位一个元素</th>
<th>定位多个元素</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td>find_element_by_id</td>
<td>find_elements_by_id</td>
<td align="center">通过元素id定位</td>
</tr>
<tr>
<td>find_element_by_name</td>
<td>find_elements_by_name</td>
<td align="center">通过元素name定位</td>
</tr>
<tr>
<td>find_element_by_xpath</td>
<td>find_elements_by_xpath</td>
<td align="center">通过xpath表达式定位</td>
</tr>
<tr>
<td>find_element_by_link_text</td>
<td>find_elements_by_link_tex</td>
<td align="center">通过完整超链接定位</td>
</tr>
<tr>
<td>find_element_by_partial_link_text</td>
<td>find_elements_by_partial_link_text</td>
<td align="center">通过部分链接定位</td>
</tr>
<tr>
<td>find_element_by_tag_name</td>
<td>find_elements_by_tag_name</td>
<td align="center">通过标签定位</td>
</tr>
<tr>
<td>find_element_by_class_name</td>
<td>find_elements_by_class_name</td>
<td align="center">通过类名进行定位</td>
</tr>
<tr>
<td>find_elements_by_css_selector</td>
<td>find_elements_by_css_selector</td>
<td align="center">通过css选择器进行定位</td>
</tr>
</tbody></table>
<h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><h4 id="web页面："><a href="#web页面：" class="headerlink" title="web页面："></a>web页面：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">link</span>=<span class="string">&quot;#0000cc&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;result_logo&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">onmousedown</span>=<span class="string">&quot;return c(&#123;&#x27;fm&#x27;:&#x27;tab&#x27;,&#x27;tab&#x27;:&#x27;logo&#x27;&#125;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/s&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;soutu-btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;kw&quot;</span> <span class="attr">class</span>=<span class="string">&quot;s_ipt&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;255&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先需要先导入模块然后进行一些操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">dr=webdriver.Chrome()</span><br><span class="line">dr.get(<span class="string">&#x27;url&#x27;</span>)  <span class="comment">#这里的url就是对应页面的url</span></span><br></pre></td></tr></table></figure>



<h5 id="通过id定位"><a href="#通过id定位" class="headerlink" title="通过id定位:"></a>通过id定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_id(<span class="string">&quot;kw&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过name定位"><a href="#通过name定位" class="headerlink" title="通过name定位:"></a>通过name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_name(<span class="string">&quot;wd&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过class-name定位"><a href="#通过class-name定位" class="headerlink" title="通过class name定位:"></a>通过class name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_class_name(<span class="string">&quot;s_ipt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过tag-name定位"><a href="#通过tag-name定位" class="headerlink" title="通过tag name定位:"></a>通过tag name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_tag_name(<span class="string">&quot;input&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过xpath定位-常用写法"><a href="#通过xpath定位-常用写法" class="headerlink" title="通过xpath定位,常用写法"></a>通过xpath定位,<em>常用写法</em></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;kw&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//*[@name=&#x27;wd&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;/html/body/form/span/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//span[@class=&#x27;soutu-btn&#x27;]/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//form[@id=&#x27;form&#x27;]/span/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//input[@id=&#x27;kw&#x27; and @name=&#x27;wd&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过css定位-常用写法"><a href="#通过css定位-常用写法" class="headerlink" title="通过css定位_常用写法_"></a>通过css定位_常用写法_</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;#kw&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;[name=wd]&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;.s_ipt&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;html &gt; body &gt; form &gt; span &gt; input&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;span.soutu-btn&gt; input#kw&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;form#form &gt; span &gt; input&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>假如页面上有一组文本链接</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;mnav&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://news.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tj_trnews&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;mnav&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.hao123.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tj_trhao123&quot;</span>&gt;</span>hao123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="通过link-text定位"><a href="#通过link-text定位" class="headerlink" title="通过link text定位"></a>通过link text定位</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_link_text(<span class="string">&quot;新闻&quot;</span>)</span><br><span class="line">dr.find_element_by_link_text(<span class="string">&quot;hao123&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过partial link text定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;新&quot;</span>)</span><br><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;hao&quot;</span>)</span><br><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Selenium库下webdriver模块常用方法"><a href="#Selenium库下webdriver模块常用方法" class="headerlink" title="Selenium库下webdriver模块常用方法"></a>Selenium库下webdriver模块常用方法</h3><h4 id="控制浏览器操作的一些方法"><a href="#控制浏览器操作的一些方法" class="headerlink" title="控制浏览器操作的一些方法"></a>控制浏览器操作的一些方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>set_window_size()</td>
<td>设置浏览器的大小</td>
</tr>
<tr>
<td>back()</td>
<td>控制浏览器后退</td>
</tr>
<tr>
<td>forward()</td>
<td>控制浏览器前进</td>
</tr>
<tr>
<td>refresh()</td>
<td>刷新当前页面</td>
</tr>
<tr>
<td>clear()</td>
<td>清除文本</td>
</tr>
<tr>
<td>send_keys (value)</td>
<td>模拟按键输入</td>
</tr>
<tr>
<td>click()</td>
<td>单击元素</td>
</tr>
<tr>
<td>submit()</td>
<td>用于提交表单</td>
</tr>
<tr>
<td>get_attribute(name)</td>
<td>获取元素属性值</td>
</tr>
<tr>
<td>is_displayed()</td>
<td>设置该元素是否用户可见</td>
</tr>
<tr>
<td>size</td>
<td>返回元素的尺寸</td>
</tr>
<tr>
<td>text</td>
<td>获取元素的文本</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment">#1.创建Chrome浏览器对象，这会在电脑上在打开一个浏览器窗口</span></span><br><span class="line">browser = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)               <span class="comment">#这个就是电脑上存放驱动的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过浏览器向服务器发送URL请求</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.刷新浏览器</span></span><br><span class="line">browser.refresh()</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.设置浏览器的大小</span></span><br><span class="line">browser.set_window_size(<span class="number">1400</span>,<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在浏览器上进行操作</span></span><br><span class="line">element=browser.find_element_by_link_text(<span class="string">&quot;新闻&quot;</span>)</span><br><span class="line">element.click()      <span class="comment">#模拟鼠标左键单击</span></span><br><span class="line"></span><br><span class="line">element=browser.find_element_by_link_text(<span class="string">&quot;“下团组”时间&quot;</span>)</span><br><span class="line">element.click()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>​	在 WebDriver 中， 将这些关于鼠标操作的方法封装在 ActionChains 类提供</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ActionChains(driver)</td>
<td>构造ActionChains对象</td>
</tr>
<tr>
<td>context_click()</td>
<td>右击</td>
</tr>
<tr>
<td>move_to_element(above)</td>
<td>执行鼠标悬停操作</td>
</tr>
<tr>
<td>double_click()</td>
<td>双击</td>
</tr>
<tr>
<td>drag_and_drop()</td>
<td>拖动</td>
</tr>
<tr>
<td>move_to_element(above)</td>
<td>执行鼠标悬停操作</td>
</tr>
<tr>
<td>context_click()</td>
<td>用于模拟鼠标右键操作， 在调用时需要指定元素定位</td>
</tr>
<tr>
<td>perform()</td>
<td>执行所有 ActionChains 中存储的行为，可以理解成是对整个操作的提交动作</td>
</tr>
</tbody></table>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMzA4MTIwODU5MzEx?x-oss-process=image/format,png" alt="实例演示在百度首页用selenium进行设置操作"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment">#1.引入 ActionChains 类</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建Chrome浏览器对象，这会在电脑上在打开一个浏览器窗口</span></span><br><span class="line">driver = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.定位到要悬停的元素</span></span><br><span class="line">element= driver.find_element_by_link_text(<span class="string">&quot;设置&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.对定位到的元素执行鼠标悬停操作</span></span><br><span class="line">ActionChains(driver).move_to_element(element).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到要进行操作的选项</span></span><br><span class="line">elem1=driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>)</span><br><span class="line">elem1.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过元素选择器找到id=sh_2,并点击设置</span></span><br><span class="line">elem2=driver.find_element_by_id(<span class="string">&quot;sh_1&quot;</span>)</span><br><span class="line">elem2.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存设置</span></span><br><span class="line">elem3=driver.find_element_by_class_name(<span class="string">&quot;prefpanelgo&quot;</span>)</span><br><span class="line">elem3.click()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>​	Selenium中的Key模块为我们提供了模拟键盘按键的方法，那就是send_keys()方法。它不仅可以模拟键盘输入，也可以模拟键盘的操作。</p>
<p>模拟键盘操作</p>
<table>
<thead>
<tr>
<th>模拟键盘按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.BACK_SPACE)</td>
<td>删除键（BackSpace）</td>
</tr>
<tr>
<td>send_keys(Keys.SPACE)</td>
<td>空格键(Space)</td>
</tr>
<tr>
<td>send_keys(Keys.TAB)</td>
<td>制表键(Tab)</td>
</tr>
<tr>
<td>send_keys(Keys.ESCAPE)</td>
<td>回退键（Esc）</td>
</tr>
<tr>
<td>send_keys(Keys.ENTER)</td>
<td>回车键（Enter）</td>
</tr>
</tbody></table>
<p>模拟键盘组合键</p>
<table>
<thead>
<tr>
<th>模拟键盘按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.CONTROL,‘a’)</td>
<td>全选（Ctrl+A）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘c’)</td>
<td>复制（Ctrl+C）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘x’)</td>
<td>剪切（Ctrl+X）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘v’)</td>
<td>粘贴（Ctrl+V）</td>
</tr>
<tr>
<td>send_keys(Keys.F1…Fn)</td>
<td>键盘 F1…Fn</td>
</tr>
</tbody></table>
<h4 id="获取断言信息"><a href="#获取断言信息" class="headerlink" title="获取断言信息"></a>获取断言信息</h4><p>​	不管是在做功能测试还是自动化测试，最后一步需要拿实际结果与预期进行比较。这个比较的称之为断言。通过我们获取title 、URL和text等信息进行断言。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>用于获得当前页面的标题</td>
</tr>
<tr>
<td>current_url</td>
<td>用户获得当前页面的URL</td>
</tr>
<tr>
<td>text</td>
<td>获取搜索条目的文本信息</td>
</tr>
</tbody></table>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before search================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面title</span></span><br><span class="line">title = driver.title</span><br><span class="line"><span class="built_in">print</span>(title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面URL</span></span><br><span class="line">now_url = driver.current_url</span><br><span class="line"><span class="built_in">print</span>(now_url)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After search================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次打印当前页面title</span></span><br><span class="line">title = driver.title</span><br><span class="line"><span class="built_in">print</span>(title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面URL</span></span><br><span class="line">now_url = driver.current_url</span><br><span class="line"><span class="built_in">print</span>(now_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取结果数目  text</span></span><br><span class="line">user = driver.find_element_by_class_name(<span class="string">&#x27;nums&#x27;</span>).text</span><br><span class="line"><span class="built_in">print</span>(user)</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭所有窗口</span></span><br><span class="line">driver.quit()</span><br><span class="line"><span class="comment">#结果如下</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Before search================</span></span><br><span class="line"><span class="string">百度一下，你就知道</span></span><br><span class="line"><span class="string">https://www.baidu.com/</span></span><br><span class="line"><span class="string">After search================</span></span><br><span class="line"><span class="string">selenium_百度搜索</span></span><br><span class="line"><span class="string">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=selenium&amp;rsv_pq=a1d51b980000e36e&amp;rsv_t=a715IZaMpLd1w92I4LNUi7gKuOdlAz5McsHe%2FSLQeBZD44OUIPnjY%2B7pODM&amp;rqlang=cn&amp;rsv_enter=0&amp;rsv_sug3=8&amp;inputT=758&amp;rsv_sug4=759</span></span><br><span class="line"><span class="string">搜索工具</span></span><br><span class="line"><span class="string">百度为您找到相关结果约7,170,000个</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="设置元素等待"><a href="#设置元素等待" class="headerlink" title="设置元素等待"></a>设置元素等待</h4><h4 id="定位一组元素-注意：是一组元素"><a href="#定位一组元素-注意：是一组元素" class="headerlink" title="定位一组元素(注意：是一组元素)"></a>定位一组元素(注意：是一组元素)</h4><p>​	定位一组元素的方法与定位单个元素的方法类似，唯一的区别是在单词element后面多了一个s表示复数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver =webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.定位一组元素</span></span><br><span class="line">elements = driver.find_elements_by_xpath(<span class="string">&#x27;//div/h3/a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(elements))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.循环遍历出每一条搜索结果的标题</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> elements:</span><br><span class="line">    <span class="built_in">print</span>(t.text)</span><br><span class="line">    element=driver.find_element_by_link_text(t.text)</span><br><span class="line">    element.click()</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="多表单切换"><a href="#多表单切换" class="headerlink" title="多表单切换"></a>多表单切换</h4><p>​	在Web应用中经常会遇到frame&#x2F;iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame&#x2F;iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame&#x2F;iframe表单的内嵌页面中。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>switch_to.frame()</td>
<td>将当前定位的主体切换为frame&#x2F;iframe表单的内嵌页面中</td>
</tr>
<tr>
<td>switch_to.default_content()</td>
<td>跳回最外层的页面</td>
</tr>
</tbody></table>
<p>126邮箱登录框的结构大概是这样子的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;x-URS-iframe&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           ...</span><br><span class="line">           <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>想要操作登录框必须要先切换到iframe表单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;http://www.126.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.switch_to.frame(<span class="string">&#x27;x-URS-iframe&#x27;</span>)</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;email&quot;</span>).clear()</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;email&quot;</span>).send_keys(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;password&quot;</span>).clear()</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;password&quot;</span>).send_keys(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;dologin&quot;</span>).click()</span><br><span class="line">driver.switch_to.default_content()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="comment">#先通过xpth定位到iframe</span></span><br><span class="line">xf = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;x-URS-iframe&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#再将定位对象传给switch_to.frame()方法</span></span><br><span class="line">driver.switch_to.frame(xf)</span><br><span class="line">……</span><br><span class="line">driver.switch_to.parent_frame()</span><br></pre></td></tr></table></figure>

<h4 id="多窗口切换："><a href="#多窗口切换：" class="headerlink" title="多窗口切换："></a>多窗口切换：</h4><p>​	在页面操作过程中有时候点击某个链接会弹出新的窗口，这时就需要主机切换到新打开的窗口上进行操作。WebDriver提供了switch_to.window()方法，可以实现在不同的窗口之间切换。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>current_window_handle</td>
<td align="center">获得当前窗口句柄</td>
</tr>
<tr>
<td>window_handles</td>
<td align="center">返回所有窗口的句柄到当前会话</td>
</tr>
<tr>
<td>switch_to.window()</td>
<td align="center">用于切换到相应的窗口，与上一节的switch_to.frame()类似，前者用于不同窗口的切换，后者用于不同表单之间的切换。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.获得百度搜索窗口句柄</span></span><br><span class="line">sreach_windows = driver.current_window_handle</span><br><span class="line"></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&#x27;登录&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;立即注册&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.获得当前所有打开的窗口的句柄</span></span><br><span class="line">all_handles = driver.window_handles</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.进入注册窗口</span></span><br><span class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> all_handles:</span><br><span class="line">    <span class="keyword">if</span> handle != sreach_windows:</span><br><span class="line">        driver.switch_to.window(handle)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;跳转到注册窗口&#x27;</span>)</span><br><span class="line">        driver.find_element_by_name(<span class="string">&quot;account&quot;</span>).send_keys(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">        driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>).send_keys(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="警告框处理"><a href="#警告框处理" class="headerlink" title="警告框处理"></a>警告框处理</h4><p>​	在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用  switch_to.alert 方法定位到 alert&#x2F;confirm&#x2F;prompt，然后使用text&#x2F;accept&#x2F;dismiss&#x2F;  send_keys等方法进行操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>返回 alert&#x2F;confirm&#x2F;prompt 中的文字信息</td>
</tr>
<tr>
<td>accept()</td>
<td>接受现有警告框</td>
</tr>
<tr>
<td>dismiss()</td>
<td>解散现有警告框</td>
</tr>
<tr>
<td>send_keys(keysToSend)</td>
<td>发送文本至警告框。keysToSend：将文本发送至警告框。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标悬停至“设置”链接</span></span><br><span class="line">link = driver.find_element_by_link_text(<span class="string">&#x27;设置&#x27;</span>)</span><br><span class="line">ActionChains(driver).move_to_element(link).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开搜索设置并点击</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#在此处设置等待2s否则可能报错</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 保存设置</span></span><br><span class="line">driver.find_element_by_class_name(<span class="string">&quot;prefpanelgo&quot;</span>).click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受警告框</span></span><br><span class="line">driver.switch_to.alert.accept()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="下拉框选择操作"><a href="#下拉框选择操作" class="headerlink" title="下拉框选择操作"></a>下拉框选择操作</h4><p>​	导入类</p>
<p><code>from selenium.webdriver.support.select import Select</code></p>
<p>Select类的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>select_by_value(“选择值”)</td>
<td>select标签的value属性的值</td>
</tr>
<tr>
<td>select_by_index(“索引值”)</td>
<td>下拉框的索引</td>
</tr>
<tr>
<td>select_by_visible_testx(“文本值”)</td>
<td>下拉框的文本值</td>
</tr>
</tbody></table>
<p>百度搜索设置的下拉框</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.鼠标悬停至“设置”链接</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&#x27;设置&#x27;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#2.打开搜索设置</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.搜索结果显示条数</span></span><br><span class="line">sel = driver.find_element_by_xpath(<span class="string">&quot;//select[@id=&#x27;nr&#x27;]&quot;</span>)</span><br><span class="line">Select(sel).select_by_value(<span class="string">&#x27;50&#x27;</span>)  <span class="comment"># 显示50条</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>​	对于通过input标签实现的上传功能，可以将其看作是一个输入框，即通过send_keys()指定本地文件路径的方式实现文件上传。</p>
<p>通过send_keys()方法来实现文件上传:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">file_path = <span class="string">&#x27;file:///&#x27;</span> + os.path.abspath(<span class="string">&#x27;upfile.html&#x27;</span>)</span><br><span class="line">driver.get(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位上传按钮，添加本地文件</span></span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;file&quot;</span>).send_keys(<span class="string">&#x27;D:\\upload_file.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h4><p>​	有时候我们需要验证浏览器中cookie是否正确，因为基于真实cookie的测试是无法通过白盒和集成测试进行的。WebDriver提供了操作Cookie的相关方法，可以读取、添加和删除cookie信息。</p>
<p>WebDriver操作cookie的方法:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get_cookies()</td>
<td>获得所有cookie信息</td>
</tr>
<tr>
<td>get_cookie(name)</td>
<td>返回字典的key为“name”的cookie信息</td>
</tr>
<tr>
<td>add_cookie(cookie_dict)</td>
<td>添加cookie。“cookie_dict”指字典对象，必须有name 和value 值</td>
</tr>
<tr>
<td>delete_cookie(name,optionsString)</td>
<td>删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”</td>
</tr>
<tr>
<td>delete_all_cookies()</td>
<td>删除所有cookie信息</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">browser.get(<span class="string">&quot;http://www.youdao.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.打印cookie信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印所有的cookie信息为：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加cookie信息</span></span><br><span class="line"><span class="built_in">dict</span>=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&quot;name&quot;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;Kaina&#x27;</span>&#125;</span><br><span class="line">browser.add_cookie(<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;添加cookie信息为：&#x27;</span>)</span><br><span class="line"><span class="comment">#3.遍历打印cookie信息</span></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#4.删除一个cookie</span></span><br><span class="line">browser.delete_cookie(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除一个cookie&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除所有cookie后：&#x27;</span>)</span><br><span class="line"><span class="comment">#5.删除所有cookie,无需传递参数</span></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h4 id="调用JavaScript代码"><a href="#调用JavaScript代码" class="headerlink" title="调用JavaScript代码"></a>调用JavaScript代码</h4><p>​	虽然WebDriver提供了操作浏览器的前进和后退方法，但对于浏览器滚动条并没有提供相应的操作方法。在这种情况下，就可以借助JavaScript来控制浏览器的滚动条。WebDriver提供了execute_script()方法来执行JavaScript代码。</p>
<p>用于调整浏览器滚动条位置的JavaScript代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!-- window.scrollTo(左边距,上边距); --&gt;</span><br><span class="line">window.scrollTo(<span class="number">0</span>,<span class="number">450</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距。其代码如下：</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.访问百度</span></span><br><span class="line">driver=webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搜索</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.休眠2s目的是获得服务器的响应内容，如果不使用休眠可能报错</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.通过javascript设置浏览器窗口的滚动条位置</span></span><br><span class="line">js=<span class="string">&quot;window.scrollTo(100,450);&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<p>通过浏览器打开百度进行搜索，并且提前通过set_window_size()方法将浏览器窗口设置为固定宽高显示，目的是让窗口出现水平和垂直滚动条。然后通过execute_script()方法执行JavaScripts代码来移动滚动条的位置。<br> 滚动条上下左右滚动代码演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver=webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.set_window_size(<span class="number">400</span>,<span class="number">400</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搜索</span></span><br><span class="line"><span class="comment"># driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)</span></span><br><span class="line"><span class="comment"># driver.find_element_by_id(&quot;su&quot;).click()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.休眠2s目的是获得服务器的响应内容，如果不使用休眠可能报错</span></span><br><span class="line">sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4 滚动左右滚动条---向右</span></span><br><span class="line">js2 = <span class="string">&quot;var q=document.documentElement.scrollLeft=10000&quot;</span></span><br><span class="line">driver.execute_script(js2)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5 滚动左右滚动条---向左</span></span><br><span class="line">js3 = <span class="string">&quot;var q=document.documentElement.scrollLeft=0&quot;</span></span><br><span class="line">driver.execute_script(js3)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6 拖动到滚动条底部---向下</span></span><br><span class="line">js = <span class="string">&quot;var q=document.documentElement.scrollTop=10000&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#7 拖动到滚动条底部---向上</span></span><br><span class="line">js = <span class="string">&quot;var q=document.documentElement.scrollTop=0&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<h4 id="窗口截图"><a href="#窗口截图" class="headerlink" title="窗口截图"></a>窗口截图</h4><p>​	自动化用例是由程序去执行的，因此有时候打印的错误信息并不十分明确。如果在脚本执行出错的时候能对当前窗口截图保存，那么通过图片就可以非常直观地看出出错的原因。WebDriver提供了截图函数get_screenshot_as_file()来截取当前窗口。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get_screenshot_as_file(self, filename)</td>
<td>用于截取当前窗口，并把图片保存到本地</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver =webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>).send_keys(<span class="string">&#x27;selenium&#x27;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>).click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.截取当前窗口，并指定截图图片的保存位置</span></span><br><span class="line">driver.get_screenshot_as_file(<span class="string">&quot;D:\\baidu_img.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="关闭浏览器"><a href="#关闭浏览器" class="headerlink" title="关闭浏览器"></a>关闭浏览器</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>close()</td>
<td>关闭单个窗口</td>
</tr>
<tr>
<td>quit()</td>
<td>关闭所有窗口</td>
</tr>
</tbody></table>
<p>​	</p>
]]></content>
      <categories>
        <category>Python-learn</category>
        <category>Python 库</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>图床搭建与PicGO---typora</title>
    <url>/2023/03/07/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E4%B8%8EPicGO-typora/</url>
    <content><![CDATA[<h1 id="图床搭建与PicGO—typora"><a href="#图床搭建与PicGO—typora" class="headerlink" title="图床搭建与PicGO—typora"></a>图床搭建与PicGO—typora</h1><h2 id="图床选择与注册"><a href="#图床选择与注册" class="headerlink" title="图床选择与注册"></a>图床选择与注册</h2><p>图床选择很多，但是建议选择比较长期还有稳定的图床，当然如果可以免费自然是更好。</p>
<p>我这次选择的是<a target="_blank" rel="noopener" href="https://www.imgurl.org/vip/manage/upload">ImgURL</a></p>
<p>之前用过<a target="_blank" rel="noopener" href="https://sm.ms/">SM.MS</a></p>
<p>两者都好用，后者注册和使用更加方便，初始上传的最大图片限制是5G，但是个人用肯定够了</p>
<span id="more"></span>


<h2 id="PicGO"><a href="#PicGO" class="headerlink" title="PicGO"></a>PicGO</h2><h3 id="ImgURL"><a href="#ImgURL" class="headerlink" title="ImgURL"></a>ImgURL</h3><p>在GitHub的<a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.1">下载界面</a>选择一个比较稳定的版本进行安装，别安装尝鲜版。安装速度可能有点慢，因为是GitHub。自己想办法&#x3D;.&#x3D;</p>
<p>下好以后就绑到你所使用的图床就行，当然前提是你的图床支持PicGO。我使用的ImgURL有很详细的<a target="_blank" rel="noopener" href="https://doc.xiaoz.org/books/imgurl-pro/page/picgo">教程</a>。当然使用可以直接绑定的图床肯定更方便，比如阿里云、腾讯云、SM.MS等</p>
<p>关于插件的下载和SM.MS一样就行，然后根据官方教程绑定PicGO和ImgURL；这里直接看教程就行，很详细了。</p>
<h3 id="SM-MS"><a href="#SM-MS" class="headerlink" title="SM.MS"></a>SM.MS</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133270020">参考文档</a></p>
<p>在安装好PicGO和注册好SM.MS后，使用typora测试了下图片上传，毫无疑问上传失败。因为没有对PicGO进行配置。于是只好去网上找教程。   </p>
<p>首先是PicGO提供的SM.MS有问题，需要下一个插件，叫做<a target="_blank" rel="noopener" href="https://github.com/xlzy520/picgo-plugin-smms-user">smms-user</a>；当然最好是在PicGo.app自己软件里面的插件设置去下载最好—搜索smms-user然后点击安装就行，等待安装完成。<br><img src="https://s2.loli.net/2023/03/07/6nQAoprPjKdBWYX.png" alt="image-20230307142211939"></p>
<p>这里我遇到了第一个坑，就是一直安装不上，然后网上搜索了，关于picgo.app的解决方案真不多，然后我把日志里面的几个报错全去ChatGPT问了下，如下：然后我选择了最粗暴的，重装。遗憾的是，我重装了两次还是有问题，于是便选择使用npm，结果在管理员权限出现了问题，qwq。<br><strong>直接说最后解决方案：重装，然后以管理员权限启动</strong> </p>
<p><img src="https://s2.loli.net/2023/03/07/wVguaZMkWo6RH5N.png" alt="image-20230307163057301"></p>
<p>这次插件成功安装了，接下来要做的就是配置一下插件，在左侧图床设置里面会如下图所示，左键插件右下角设置按钮，然后把从SM.MS获取到的token填进插件的plugin以及uploader中。再把默认图片上传改为SM.MS-登录用户</p>
<p><img src="https://s2.loli.net/2023/03/07/58tXJrFHjnseAC4.png" alt="image-20230307163751194"></p>
<p><img src="https://s2.loli.net/2023/03/07/EMTDwm1gcGUZ3ed.png" alt="image-20230307181803403"></p>
<p>然后再用图片进行测试，发现上传成功，解下来再把typora里的图片上传方式改下。</p>
<h2 id="typora设置"><a href="#typora设置" class="headerlink" title="typora设置"></a>typora设置</h2><p>上传服务设定改一下，路径选择你PicGO的位置。然后点击<strong>验证图片上传选项</strong></p>
<p><img src="https://s2.loli.net/2023/03/07/EagXR9tlN8FnD3M.png" alt="image-20230307182146879"></p>
<p>第二个问题出现了，上传图片失败，我直接进PICGO的日志中把这次上传去找了下问题，结果是typora的图片传不上去了。直接用就行，文档里面图片不受影响。</p>
<p><img src="https://s2.loli.net/2023/03/07/4BEJKOvm7IiWPaS.png" alt="image-20230307182427400"></p>
<p><img src="https://s2.loli.net/2023/03/07/iTlbnIsyOCN9qmS.png" alt="image-20230307182550000"></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>图床</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-OpenCV基础教程</title>
    <url>/2023/03/07/Python-OpenCV%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>前言：OpenCV是为了搞比赛学的，当时目的是为了做喷播机的识别系统，识别可喷区域，掌握基础就行，在学的过程中发现OpenCV入门还是很简单的，而且摄像头玩着还是挺有意思。至于学Python-OpenCV，是因为使用的设备是树莓派，这里就不得不感慨一下，21年那会树莓派4B才600左右，现在已经1200+了，难崩！</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/index.html">OpenCV官方界面</a></li>
</ul>
<span id="more"></span>

<h1 id="OPEN-CV基础"><a href="#OPEN-CV基础" class="headerlink" title="OPEN CV基础"></a>OPEN CV基础</h1><h2 id="什么是图像"><a href="#什么是图像" class="headerlink" title="什么是图像"></a>什么是图像</h2><p>图像是由像素点组成的，像素点的矩阵就组成图像大小</p>
<p>计算机是01编码制，数字图像也是用01来记录信息，一般接触的都是八位数图像，0是最黑，255是最白</p>
<p>像素点：比如说<code>[500,500,3]</code> 就是<code>分别代表h，w，像素通道</code></p>
<h3 id="H-S-V-颜色模型"><a href="#H-S-V-颜色模型" class="headerlink" title="H S V 颜色模型"></a>H S V 颜色模型</h3><p>HSV（Hue Saturation Value）颜色模型是面向用户的</p>
<p>HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。</p>
<p>这个模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）</p>
<h4 id="色调"><a href="#色调" class="headerlink" title="色调"></a>色调</h4><p>用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,紫色为300°；</p>
<h4 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h4><p>饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。</p>
<h4 id="明度"><a href="#明度" class="headerlink" title="明度"></a>明度</h4><p>明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。</p>
<img src="https://bkimg.cdn.bcebos.com/pic/8d5494eef01f3a29fb2420739925bc315d607c9b?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1/format,f_auto" alt="HSV颜色空间模型" style="zoom:150%;" />

<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><h3 id="二值图像"><a href="#二值图像" class="headerlink" title="二值图像"></a>二值图像</h3><p><img src="D:\typora\src\image-20210911131838722.png" alt="二值图像是指：每个像素点均为黑色或者白色的图像。二值图像一般用来描述字符图像，其优点是占用空间少，缺点是，当表示人物，风景的图像时，二值图像只能展示其边缘信息，图像内部的纹理特征表现不明显。这时候要使用纹理特征更为丰富的灰度图像"></p>
<h3 id="灰度图像与彩色图像"><a href="#灰度图像与彩色图像" class="headerlink" title="灰度图像与彩色图像"></a>灰度图像与彩色图像</h3><p>一幅完整的图像，是由红色、绿色、蓝色三个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%9A%E9%81%93">通道</a>组成的。红色、绿色、蓝色三个通道的缩览图都是以<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%81%B0%E5%BA%A6">灰度</a>显示的。用不同的灰度色阶来表示“ 红，绿，蓝”在图像中的比重。通道中的纯白，代表了该色光在此处为最高亮度，亮度级别是255。</p>
<p>通道是整个Photo shop显示图像的基础。色彩的变动，实际上就是间接在对通道灰度图进行调整。通道是Photo shop处理图像的核心部分，所有的色彩调整工具都是围绕在这个核心周围使用的。</p>
<p>在计算机领域中，这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑色与白色两种颜色；灰度图像在黑色与白色之间还有许多级的颜色深度。但是，在数字图像领域之外，“黑白图像”也表示“灰度图像”，例如灰度的照片通常叫做“黑白照片”。在一些关于数字图像的文章中单色图像等同于灰度图像，在另外一些文章中又等同于黑白图像。</p>
<p>我们可以通过下面几种方法，将其转换为灰度：</p>
<p>1.浮点算法：Gray&#x3D;R * 0.3+G * 0.59+B * 0.11</p>
<p>2.整数方法：Gray&#x3D;(R * 30+G * 59+B * 11)&#x2F;100</p>
<p>3.移位方法：Gray &#x3D;(R * 76+G * 151+B * 28)&gt;&gt;8;</p>
<p>4.<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%B3%E5%9D%87%E5%80%BC%E6%B3%95">平均值法</a>：Gray&#x3D;（R+G+B）&#x2F;3;</p>
<p>5.仅取绿色：Gray&#x3D;G；</p>
<p>通过上述任一种方法求得Gray后，将原来的RGB(R,G,B)中的R,G,B统一用Gray替换，形成新的颜色RGB(Gray,Gray,Gray)，用它替换原来的RGB(R,G,B)就是灰度图了。</p>
<p><img src="/typora%5Csrc%5Cimage-20210911131936378.png" alt="image-20210911131936378"></p>
<h2 id="数据读取–图像"><a href="#数据读取–图像" class="headerlink" title="数据读取–图像"></a>数据读取–图像</h2><p><code>cv2.imread</code></p>
<p><code>cv2.IMREAD_COLOR</code>:彩色图像读取   可以使用1 代替</p>
<p><code>cv2.IMREAD_GRAYSCALE</code> ：灰度图像 可以使用0代替</p>
<p><code>cv2.IMREAD_UNCHANGED 包括alpha（透明度）通道的加载图像模式·</code>  可以使用-1代替</p>
<p><code>cv2.waitKey()</code>是让程序暂停的意思，参数是等待时间（毫秒ms）的时间一到，会继续执行接下来的程序，<strong>传入0的话表示一直等待等待期间也可以获取用户的按键输入</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img=cv2.imread(<span class="string">&quot;NV.jpg&quot;</span>,<span class="number">0</span>)<span class="comment">#加载灰度图像</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;image&quot;</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>) </span><br><span class="line"><span class="string">&quot;如果路径有错误，会返回None值，但并不会报错&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以先用<code>cv2.namedWindow()</code>创建一个画面，之后再显示</p>
<p>参数 1 仍然是图片的，参数 2 默认是<code>cv2.WINDOW_AUTOSIZE</code>，表示图片大小图片，也可以设置为<code>cv2.WINDOW_NORMAL</code>，表示图片大小可调整。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先定义窗口，后显示图片</span></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;lena2&#x27;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;lena2&#x27;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h2 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h2><p><code>cv2.imshow(windows_name, image)</code>    用的是B G R通道</p>
<p><code>imshow</code>函数作用是在窗口中显示图像，窗口自动适合于图像大小，我们也可以通过<code>imutils</code>模块调整显示图像的窗口的大小</p>
<p>windows_name： 窗口名称(字符串)<br>image： 图像对象，类型是<code>numpy</code>中的<code>ndarray</code>类型</p>
<p>在这之后需要调用 <code>cv2.waitKey()它的唯一参数是它应该等待用户输入多长时间（以毫秒给图像绘制留下时间，否则窗口会出现无响应的情况，并且图像无法显示出来</code></p>
<p>也就是说<code>cv2,imshow</code>后面必须跟<code>waitKey()</code>否则无法显示</p>
<p>这里可以通过<code>imutils</code>模块改变图像显示大小，下面示例展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>,img) </span><br><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>,imutils.resize(img,<span class="number">800</span>)) <span class="comment">#利用imutils模块调整图片尺寸</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了 <code>opencv</code> 外也可以调用 <code>matplotlib</code>对图像进行展示 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#matplotlib.pyplot  展示</span></span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>])  <span class="comment"># cv2是BGR  而plt是RGB需要换一下通道</span></span><br><span class="line">plt.show()  <span class="comment">#彩色图展示</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\PYTHON\OpenCV\image-20210912141915286.png" alt="image-20210912141915286"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#灰度图展示</span></span><br><span class="line">plt.imshow(img,cmap=plt.cm.gray)</span><br><span class="line">plt.show</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20210912140643353.png"></p>
<h2 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h2><p><code>imwrite 函数保存图像</code></p>
<p><code>cb2.imwrite(image_filename,image)</code></p>
<p>函数参数一： 保存的图像名称(字符串)<br>函数参数二： 图像对象，类型是<code>numpy</code>中的<code>ndarray</code>类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&#x27;img.jpg&#x27;</span>, img)   <span class="comment">#将图像保存成jpg文件</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;img2.png&#x27;</span>, img) <span class="comment">#将图像保存成png文件</span></span><br></pre></td></tr></table></figure>

<h2 id="图像读取显示保存练习"><a href="#图像读取显示保存练习" class="headerlink" title="图像读取显示保存练习"></a>图像读取显示保存练习</h2><ol>
<li><p>打开<code>lena.jpg</code>并显示，如果按下q，就保存图片为<code>&#39;lena_save.bmp&#39;</code>，否则就结束程序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;lena&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># ord()用来获取某个字符的编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):   <span class="comment">#键输入q就会保存</span></span><br><span class="line">    <span class="comment">#cv2.imwrite(&#x27;lena_save.bmp&#x27;, img)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;已保存&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Matplotlib</code> 是 Python 中常用的一个绘图库，</p>
</li>
</ol>
<h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d3/d63/classcv_1_1Mat.html">map对象</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56"><code>cv2.imread()</code></a></li>
<li>[<code>cv2.imshow()</code>(<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563</a>)</li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce"><code>cv2.imwrite()</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b"><code>cv.namedWindow()</code></a></li>
</ul>
<h2 id="窗口销毁函数"><a href="#窗口销毁函数" class="headerlink" title="窗口销毁函数"></a>窗口销毁函数</h2><p>当我们使用<code>imshow</code>函数展示图像时，最后需要在程序中对图像展示窗口进行销毁，否则程序将无法正常终止</p>
<p><code>cv2.destroyWindow(windows_name)</code> 销毁单个特定窗口，参数： 将要销毁的窗口的名字<br><code>cv2.destroyAllWindows() </code>销毁全部窗口，无参数</p>
<p>销毁窗口，不能图片窗口一出现我们就将窗口销毁，这样便没法观看窗口,应该采用以下方式</p>
<p><code>cv2.waitKey(time_of_milliseconds)</code></p>
<p>1.让窗口停留一段时间就销毁</p>
<p>2.接收指令，如接收指定的键盘敲击后结束窗口</p>
<p><code>参数：time_of_milliseconds</code>  大于0，此时的参数表示时间，单位是毫秒，表示等待一定毫秒后自动销毁窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表示等待10秒后，将销毁所有图像</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">10000</span>):</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="comment">#表示等待10秒，将销毁窗口名称为&#x27;image&#x27;的图像窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">10000</span>):</span><br><span class="line">    cv2.destroyWindow(<span class="string">&#x27;image&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>参数小于等于0时： 此时窗口将等待一个键盘指令，接收到指令后就会进行窗口销毁，这个指令是可以自动定义的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#当指定waitKey(0) == 27时当敲击键盘 Esc 时便销毁所有窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="comment">#当接收到键盘敲击A时，便销毁名称为&#x27;origin image&#x27;的图像窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(-<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>):</span><br><span class="line">    cv2.destroyWindow(<span class="string">&#x27;origin image&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="颜色空间装换"><a href="#颜色空间装换" class="headerlink" title="颜色空间装换"></a>颜色空间装换</h2><h3 id="图像色彩空间（color-space）变换函数-cv2-cvtColor"><a href="#图像色彩空间（color-space）变换函数-cv2-cvtColor" class="headerlink" title="*图像色彩空间（color space）变换函数 cv2.cvtColor"></a>*图像色彩空间（color space）变换函数 <code>cv2.cvtColor</code></h3><p><code>cv2.cvtColor(input_image,flag)</code> </p>
<p>参数一： input_image表示将要变换色彩的图像,<code>ndarray</code>对象</p>
<p> 参数二： 表示图像色彩空间变换的类型,常用有两种</p>
<p><code> cv2.COLOR_BGR2GRAY:表示将图像从BGR空间转化成灰度图，最常用</code> </p>
<p><code>cv2.COLOR_BGR2HSV:表示将图像从RGB空间转换到HSV空间</code></p>
<p>如果需要查看flag所有的类型，可以通过以下程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv2) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="built_in">print</span>(flags)</span><br><span class="line"><span class="comment">#共有274种</span></span><br></pre></td></tr></table></figure>

<h2 id="为何总是对灰度图进行处理？"><a href="#为何总是对灰度图进行处理？" class="headerlink" title="为何总是对灰度图进行处理？"></a>为何总是对灰度图进行处理？</h2><p><strong>图像的颜色主要是由于图像受到外界光照影响随之产生的不同颜色信息，同一个背景物的图像在不同光源照射下产生的不同颜色效果的图像，因此在我们做图像特征提取和识别过程时，我们要的是图像的梯度信息，也就是图像的本质内容，而颜色信息会对我们对梯度信息提取造成一定的干扰，因此我们会在做图像特征提取和识别前将图像转化为灰度图，这样同时也降低了处理的数据量并且增强了处理效果。</strong></p>
<h2 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一个长宽分别为w、h的 R G B彩色图像来说，它的每个像素值是由(B、G、R)的一个tuple组成，<code>opencv-python</code>中每个像素三个值的顺序是B、G、R，而对于灰度图像来说，每个像素对应的便只是一个整数，如果要把像素缩放到0、1，则灰度图像就是二值图像，0便是黑色，1便是白色。我们通过下面的例子来理解一下</p>
<p>处理的图像如下<img src="D:\typora\src\NV.jpg" alt="NV"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">rgb_img = cv2.imread(<span class="string">&#x27;E:/pycharm/opencv/new/NV.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rgb_img.shape)  <span class="comment"># (676, 1202, 3)  # h有676个像素点，w有1202个像素点，3就是三通道，也就是说看到的是彩图</span></span><br><span class="line"><span class="built_in">print</span>(rgb_img[<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># [16 11 12]</span></span><br><span class="line"><span class="built_in">print</span>(rgb_img[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]) <span class="comment"># 16</span></span><br><span class="line"></span><br><span class="line">gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)  <span class="comment">#灰度</span></span><br><span class="line"><span class="built_in">print</span>(gray_img.shape) <span class="comment">#(676, 1202)</span></span><br><span class="line"><span class="built_in">print</span>(gray_img[<span class="number">0</span>, <span class="number">0</span>])<span class="comment">#12</span></span><br></pre></td></tr></table></figure>

<p>从以上程序运行结果可以得知，彩色图像的高度height&#x3D;676，宽度&#x3D;1202 ，通道数为3     像素(0,0)的值为（16 11 12）   即 R&#x3D;16 G&#x3D;11  B&#x3D;12 </p>
<p>但是对于灰度图像来说就是单通道的</p>
<p>因此(0, 0, 0)便是代表一个黑色像素，(255, 255, 255)便是代表一个白色像素。这么想，B&#x3D;0, G&#x3D;0,  R&#x3D;0相当于关闭了颜色通道也就相当于无光照进入，所以图像整个是黑的，而(255, 255, 255)即B&#x3D;255, G&#x3D;255, R&#x3D;255，  相当于打开了B、G、R所有通道光线全部进入，因此便是白色。上图的灰度就是12即[12 12 12]</p>
<h3 id="创建一个简单的图"><a href="#创建一个简单的图" class="headerlink" title="创建一个简单的图"></a>创建一个简单的图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">white_img = np.ones((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">white_img = <span class="number">255</span>*white_img</span><br><span class="line">cv2.imshow(<span class="string">&#x27;white_img&#x27;</span>, white_img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210912192702186.png" alt="image-20210912192702186" style="zoom:33%;" />

<p><strong>公共参数：</strong></p>
<p><strong><code>img</code>：表示需要进行绘制的图像对象ndarray</strong><br><strong><code>color</code>：表示绘制几何图形的颜色，采用<code>BGR</code>即上述说的(B、G、R)</strong><br><strong><code>thickness</code>表示绘制几何图形中线的粗细，默认为1，对于圆、椭圆等封闭图像取-1时是填充图形内部</strong><br><strong><code>lineType </code>表示绘制几何图形线的类型，默认8-connected线是光滑的，当取<code>cv2.LINE_AA</code>时线呈现锯齿状</strong></p>
<h4 id="cv2-line-直线绘制函数"><a href="#cv2-line-直线绘制函数" class="headerlink" title="cv2.line 直线绘制函数"></a><code>cv2.line</code> 直线绘制函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.line(image, starting, ending, color, thickness, lineType)</span><br><span class="line"><span class="comment">#starting,ending 分别表示线的起点像素坐标，终点像素坐标</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-rectangle-矩形"><a href="#cv2-rectangle-矩形" class="headerlink" title="cv2.rectangle   矩形"></a><code>cv2.rectangle</code>   矩形</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.rectangle(image, top-left, bottom-right, color, thickness, lineType)</span><br><span class="line"><span class="comment">#top-left , bottom-right 分别表示长方形左上角像素坐标、右下角像素坐标</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-circle-圆"><a href="#cv2-circle-圆" class="headerlink" title="cv2.circle  圆"></a><code>cv2.circle</code>  圆</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.circle(image, center, radius, color, thickness, lineType)</span><br><span class="line"><span class="comment"># center 表示圆的圆心像素坐标</span></span><br><span class="line"><span class="comment"># radius 圆的半径长度</span></span><br><span class="line"><span class="comment">#当thickness=-1时，绘制的圆是实心圆，当thickness&gt;=0时绘制的是空心圆</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-ellipse-椭圆"><a href="#cv2-ellipse-椭圆" class="headerlink" title="cv2.ellipse   椭圆"></a><code>cv2.ellipse </code>  椭圆</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.circle(image, center, (major-axis-length, minor-axis-length), angle, startAngle, endAngle, color, thickness, lineType)</span><br><span class="line"><span class="comment">#当参数thickness = -1 时绘制的是实心椭圆，当thickness &gt;= 0 时绘制的是空心椭圆</span></span><br><span class="line"><span class="comment"># center： 表示椭圆中心像素坐标</span></span><br><span class="line"><span class="comment"># major-axis-length： 表示椭圆的长轴长度</span></span><br><span class="line"><span class="comment"># minor-axis-length： 表示椭圆的短轴长度</span></span><br><span class="line"><span class="comment"># angle： 表示椭圆在逆时针方向旋转的角度</span></span><br><span class="line"><span class="comment"># startAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的起始角度</span></span><br><span class="line"><span class="comment"># endAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的终止时角度</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-polylines-多边形"><a href="#cv2-polylines-多边形" class="headerlink" title="cv2.polylines 多边形"></a><code>cv2.polylines</code> 多边形</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.polylines(image, [point-<span class="built_in">set</span>], flag, color, thickness, lineType)</span><br><span class="line"><span class="comment"># [point-set]： 表示多边形点的集合，如果多边形有m个点，则便是一个m12的数组，表示共m个点</span></span><br><span class="line"><span class="comment"># flag： 当flag = True 时，则多边形是封闭的，当flag = False 时，则多边形只是从第一个到最后一个点连线组成的图像，没有封闭</span></span><br></pre></td></tr></table></figure>

<p>cv2.putText</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = np.ones((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">img = <span class="number">255</span>*img</span><br><span class="line">img = cv2.line(img, (<span class="number">100</span>,<span class="number">100</span>), (<span class="number">400</span>,<span class="number">400</span>),(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</span><br><span class="line">img = cv2.rectangle(img,(<span class="number">200</span>, <span class="number">20</span>),(<span class="number">400</span>,<span class="number">120</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">img = cv2.circle(img,(<span class="number">100</span>,<span class="number">400</span>), <span class="number">50</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">img = cv2.circle(img,(<span class="number">250</span>,<span class="number">400</span>), <span class="number">50</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">0</span>)</span><br><span class="line">img = cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">180</span>,(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">pts = np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line">img = cv2.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210912194703373.png" alt="image-20210912194703373" style="zoom:50%;" />

<h2 id="对图像的简单像素操作"><a href="#对图像的简单像素操作" class="headerlink" title="对图像的简单像素操作"></a>对图像的简单像素操作</h2><p>对于一个图像，每个像素点都有其对应的坐标<code>img[height,width,颜色通道]</code>而对于彩色图像每个像素点都是由[g,b,r]组成的</p>
<ul>
<li><code>img[y,x]</code>获取&#x2F;设置像素点值，<code>img.shape</code>：图片的形状（行数(height)、列数(width)、通道数），：<code>img.dtype</code>图像的数据类型。</li>
<li><code>img[y1:y2,x1:x2]</code>进行ROI截取，<code>cv2.split()/cv2.merge()</code>通道分割&#x2F;合并。更推荐的获取单通道方式：<code>b = img[:, :, 0]</code></li>
</ul>
<h4 id="获取和修改像素点值"><a href="#获取和修改像素点值" class="headerlink" title="获取和修改像素点值"></a>获取和修改像素点值</h4><p>操作以后，计算机内存中img的像素点是改变了 但是因为并没有保存，因此原图是没有更改的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 1.获取像素的值 b g r</span></span><br><span class="line">px = img[<span class="number">100</span>, <span class="number">90</span>]</span><br><span class="line"><span class="built_in">print</span>(px)  <span class="comment"># [103 98 197]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只获取蓝色blue通道的值</span></span><br><span class="line">px_blue = img[<span class="number">100</span>, <span class="number">90</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(px_blue)  <span class="comment"># 103</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改像素的值</span></span><br><span class="line">img[<span class="number">100</span>, <span class="number">90</span>] = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]</span><br><span class="line"><span class="built_in">print</span>(img[<span class="number">100</span>, <span class="number">90</span>])  <span class="comment"># [255 255 255]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.图片形状</span></span><br><span class="line"><span class="built_in">print</span>(img.shape)  <span class="comment"># (263, 247, 3)</span></span><br><span class="line"><span class="comment"># 形状中包括行数、列数和通道数</span></span><br><span class="line">height, width, channels = img.shape</span><br><span class="line"><span class="comment"># img是灰度图的话：height, width = img.shape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总像素数 h*W*通道数</span></span><br><span class="line"><span class="built_in">print</span>(img.size)  <span class="comment"># 263*247*3=194883</span></span><br><span class="line"><span class="comment"># 数据类型</span></span><br><span class="line"><span class="built_in">print</span>(img.dtype)  <span class="comment"># uint8   0-256</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.ROI截取   截取部分图像数据</span></span><br><span class="line">face = img[<span class="number">100</span>:<span class="number">200</span>, <span class="number">115</span>:<span class="number">188</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;face&#x27;</span>, face)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.通道分割与合并</span></span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">img = cv2.merge((b, g, r))</span><br><span class="line"><span class="comment"># 更推荐的获取某一通道方式</span></span><br><span class="line">b = img[:, :, <span class="number">0</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;b&#x27;</span>, b)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="对图像取反"><a href="#对图像取反" class="headerlink" title="对图像取反"></a>对图像取反</h4><p><code>reverse_img = 255 - gray_img  </code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;[[12 14 14 ... 18 21 19]</span></span><br><span class="line"><span class="string"> [11 14 13 ... 23 20 17]</span></span><br><span class="line"><span class="string"> [13 13 13 ... 21 23 20]</span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string"> [20 22 22 ... 31 30 28]</span></span><br><span class="line"><span class="string"> [19 19 22 ... 28 29 29]</span></span><br><span class="line"><span class="string"> [21 19 16 ... 33 30 30]]&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#变成</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[243 241 241 ... 237 234 236]</span></span><br><span class="line"><span class="string"> [244 241 242 ... 232 235 238]</span></span><br><span class="line"><span class="string"> [242 242 242 ... 234 232 235]</span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string"> [235 233 233 ... 224 225 227]</span></span><br><span class="line"><span class="string"> [236 236 233 ... 227 226 226]</span></span><br><span class="line"><span class="string"> [234 236 239 ... 222 225 225]]&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210920180815747.png" alt="image-20210920180815747" style="zoom:50%;" />

<h4 id="对图像像素线性变换"><a href="#对图像像素线性变换" class="headerlink" title="对图像像素线性变换"></a>对图像像素线性变换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gray_img.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(gray_img.shape[<span class="number">1</span>]):</span><br><span class="line">        random_img[i, j] = gray_img[i, j]*<span class="number">1.2</span> <span class="comment">#灰度图所有像素都成了1.2  这里的[i,j]就代表一个一个的像素点</span></span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210920180922849.png" alt="image-20210920180922849" style="zoom:50%;" />

<h4 id="截取部分图像数据-ROI"><a href="#截取部分图像数据-ROI" class="headerlink" title="截取部分图像数据 ROI"></a>截取部分图像数据 ROI</h4><p>学了特征后，就可以自动截取</p>
<p>先了解下这个图像的坐标左上角是原点，x轴与常规相同，y轴朝下  </p>
<p>下例中cat就是对NV这个图片进行切片，h切<code>0:200</code>,w也切<code>0:200</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rgb_img = cv2.imread(<span class="string">&#x27;E:/pycharm/opencv/new/NV.jpg&#x27;</span>)</span><br><span class="line">cat=rgb_img[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">200</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>,rgb_img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20210920184022634.png" alt="截取到的"></p>
<h4 id="颜色通道的分割与合并"><a href="#颜色通道的分割与合并" class="headerlink" title="颜色通道的分割与合并"></a>颜色通道的分割与合并</h4><p>彩色图的<code>BGR</code>三个通道是可以分开单独访问的，可以也。将单独的三个通道合并分类中翻译一副图像分别使用<code>cv2.split()</code>状语从句：<code>cv2.merge()</code></p>
<p>这个效率比较低</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">img = cv2.merge((b, g, r))</span><br></pre></td></tr></table></figure>

<p>用<code>num</code>索引的方法比较简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = img[:, :, <span class="number">0</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;blue&#x27;</span>, b)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="掩膜mask"><a href="#掩膜mask" class="headerlink" title="掩膜mask"></a>掩膜mask</h2><p>物理的角度<br>在半导体制造中，许多芯片工艺步骤采用光刻技术，用于这些步骤的图形“底片”称为掩膜（也称作“掩模”），其作用是：在硅片上选定的区域中对一个不透明的图形模板遮盖，继而下面的腐蚀或扩散将只影响选定的区域以外的区域。<br>图像掩膜与其类似，用选定的图像、图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。</p>
<p> 数字图像处理中,图像掩模主要用于：</p>
<p>①提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。</p>
<p>②屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。</p>
<p>③结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。</p>
<p>④特殊形状图像的制作。用选定的图像、图形或物体,对待处理的图像(全部或局部)进行遮挡,来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e1eee55fde4d735986d0108c6004db3a.png" alt="这里写图片描述"></p>
<h2 id="图像基本运算"><a href="#图像基本运算" class="headerlink" title="图像基本运算"></a>图像基本运算</h2><p>bitwise_and、bitwise_or、bitwise_xor、bitwise_not这四个按位操作函数。</p>
<p>bitwise_and是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&amp;1&#x3D;1，1&amp;0&#x3D;0，0&amp;1&#x3D;0，0&amp;0&#x3D;0<br>bitwise_or是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1&#x3D;1，1|0&#x3D;0，0|1&#x3D;0，0|0&#x3D;0<br>bitwise_xor是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1 ^ 1&#x3D;0,1 ^ 0&#x3D;1,0 ^ 1&#x3D;1,0^0&#x3D;0<br>bitwise_not是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，~ 1 &#x3D;0，~0&#x3D;1</p>
<h2 id="颜色分离"><a href="#颜色分离" class="headerlink" title="颜色分离"></a>颜色分离</h2><p>对于一张彩色图像，若有需要对某种颜色进行分离出来，在 OpenCV 中需要使用到 cv2.inRange 和 cv2.bitwise_and 两个函数。</p>
<p>首先介绍一下两个函数：</p>
<p>1、cv2.inRange</p>
<p>cv2.inRange(src, lowerb, upperb)<br>用以确认元素值是否介于某个区域<br>inRange 函数需要设定三个参数，其中 src 指源图像；lowerb 指图像中低于 lowerb 的值，其所对应的图像值将为 0；upperb指图像中高于 upperb 的值，图像值变为 0 。换言之，源图像中仅有图像值介于 lowerb 和 upperb 之间的值才不为 0 ，且值将变成 255<br>2、cv2.bitwise_and</p>
<p>cv2.bitwise_and(src1, scr2, mask&#x3D;)<br>用于对两个数组（图像也是数组）对位元素进行运算，即计算机中的“和”运算。以二进制为例，1&amp;1输出 1 ，1&amp;0、0&amp;1、0&amp;0则均输出 0 。<br>bitwise_and 函数需要设定三个参数，其中 src1 指第一个数组（源图像），src2 指第二个数组（源图像），mask&#x3D; 用于指定具体的掩模（常以 0 和 1 元素为主，用以输出具体的元素），应设为 uint8 格式，即单通道的 8-bit 的数组。另外，mask 参数为可选参数，可省略。<br>言归正传，以某张船的照片为例，分离出图像的蓝色。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块，输出原图</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">ship_rgb = cv2.imread(<span class="string">&#x27;ship.jpg&#x27;</span>)[:,:,::-<span class="number">1</span>]</span><br><span class="line">plt.imshow(ship_rgb)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210302103907984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0OTU2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像转为HSV格式进而得到mask，HSV分别代表色相(Hue)、饱和度(Saturation)、明度(Value)</span></span><br><span class="line">ship_hsv = cv2.cvtColor(ship_rgb, cv2.COLOR_RGB2HSV)</span><br><span class="line"><span class="comment"># 设定参数lowerb、upperb</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">lowerb = np.array([<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>])</span><br><span class="line">upperb = np.array([<span class="number">140</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line"><span class="comment"># 获取mask</span></span><br><span class="line">mask = cv2.inRange(ship_hsv, lowerb, upperb)</span><br><span class="line"><span class="comment"># 利用mask进行颜色分离</span></span><br><span class="line">ship_masked = cv2.bitwise_and(ship_bgr,ship_bgr,mask=mask)</span><br><span class="line"><span class="comment"># 转回RGB格式</span></span><br><span class="line">ship_blue = cv2.cvtColor(ship_masked,cv2.COLOR_BGR2RGB)</span><br></pre></td></tr></table></figure>



<h2 id="拍摄与本地视频的读取与处理："><a href="#拍摄与本地视频的读取与处理：" class="headerlink" title="拍摄与本地视频的读取与处理："></a>拍摄与本地视频的读取与处理：</h2><p><code>cv2.ViedoCapture()</code>可以捕获摄像头，用数字来控制不同的设备，例如0,1</p>
<p>如果是视频文件直接指定路径就行</p>
<p><code>cap = cv2.VideoCapture()</code>创建视频捕捉对象<strong>cap</strong><br>其中参数可以可以写本地路径或者打开设备摄像头。<br><code>ret, frame = cap.read()；</code><br>1）ret,frame是获read()方法的两个返回值，其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就False；<br>2）frame就是每一帧的图像，是个三维矩阵（按帧读取）。<br>这里需要注意的是由于<code>read</code>是一帧一帧读取，要么读取一张操作一张，要么将所有的帧全部存到list中统一处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">vc=cv2.VideoCapture(<span class="string">&#x27;C:/Users/XYT/Desktop/机械创新设计大赛/Modern Forest Planting Machine   Amazing life  #1 00_00_00-00_01_36.mp4&#x27;</span>)   <span class="comment">#视频文件指定路径  记得改斜杠</span></span><br><span class="line"><span class="keyword">if</span> vc.isOpened(): </span><br><span class="line">    <span class="built_in">open</span>,frame=vc.read()  <span class="comment"># read() 返回两个值，其中open是布尔类型，就是如果你读取到了视频中的这一帧，那么就返回True 反之。frame接收到的是这一帧图像</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">open</span>=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">open</span>:  <span class="comment">#利用循环一帧一帧的播放视频，每次获取一帧</span></span><br><span class="line">    ret,frame=vc.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) <span class="comment">#将这一帧图像转换成灰度图</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;gray_img&#x27;</span>,gray)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">10</span>)&amp;<span class="number">0xFF</span>==<span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">vc.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="获取摄像头属性（视频捕捉属性）cap-get-propId"><a href="#获取摄像头属性（视频捕捉属性）cap-get-propId" class="headerlink" title="获取摄像头属性（视频捕捉属性）cap.get(propId)"></a>获取摄像头属性（视频捕捉属性）<code>cap.get(propId)</code></h4><p>通过<code>cap.get(propId)</code>采集摄像头的一些属性，比如设备属性的属性，可以参考从0~18的属性</p>
<p>也可以使用<code>cap.set(propId,value)</code>来修改属性值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取捕获的分辨率</span></span><br><span class="line"><span class="comment"># propId可以直接写数字，也可以用OpenCV的符号表示</span></span><br><span class="line">width, height = capture.get(<span class="number">3</span>), capture.get(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(width, height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以原分辨率的一倍来捕获</span></span><br><span class="line">capture.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, width * <span class="number">2</span>)</span><br><span class="line">capture.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, height * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;import cv2</span></span><br><span class="line"><span class="string">cap=cv2.VideoCapture(0)</span></span><br><span class="line"><span class="string">print(cap.get(3),cap.get(4))  # 640 489   分别代表h， 与 w</span></span><br><span class="line"><span class="string">cap.set(3,cap.get(3)*2)</span></span><br><span class="line"><span class="string">cap.set(4,cap.get(4)*2)</span></span><br><span class="line"><span class="string">if cap.isOpened():</span></span><br><span class="line"><span class="string">    ret,frame=cap.read()</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&#x27;摄像头未正常开启&#x27;)</span></span><br><span class="line"><span class="string">while ret :</span></span><br><span class="line"><span class="string">    ret,frame=cap.read()</span></span><br><span class="line"><span class="string">    if frame is None:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">    if ret == True:</span></span><br><span class="line"><span class="string">        cv2.imshow(&#x27;cap_mp4&#x27;,frame)</span></span><br><span class="line"><span class="string">        if cv2.waitKey(25) == ord(&#x27;s&#x27;):</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">cap.release()</span></span><br><span class="line"><span class="string">cv2.destroyAllWindows()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<pre><code>&#39;[VideoCaptureProperties](https://docs.opencv.org/4.0.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d)&#39; 
</code></pre>
<table>
<thead>
<tr>
<th align="left"><code>CAP_PROP_POS_MSEC Python：cv.CAP_PROP_POS_MSEC</code></th>
<th>0</th>
<th>以毫秒为单位的视频文件的当前位置。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CAP_PROP_POS_FRAMES Python：cv.CAP_PROP_POS_FRAMES</code></td>
<td>1</td>
<td>下一个要解码&#x2F;捕获的帧的基于 0 的索引。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_POS_AVI_RATIO Python：cv.CAP_PROP_POS_AVI_RATIO</code></td>
<td>2</td>
<td>视频文件的相对位置：0&#x3D;影片开头，1&#x3D;影片结尾。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_WIDTH Python：cv.CAP_PROP_FRAME_WIDTH</code></td>
<td>3</td>
<td>视频流中帧的宽度。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_HEIGHT Python：cv.CAP_PROP_FRAME_HEIGHT</code></td>
<td>4</td>
<td>视频流中帧的高度。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FPS Python：cv.CAP_PROP_FPS</code></td>
<td>5</td>
<td>帧率。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FOURCC Python：cv.CAP_PROP_FOURCC</code></td>
<td>6</td>
<td>编解码器的 4 字符代码。见<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html#afec93f94dc6c0b3e28f4dd153bc5a7f0">VideoWriter::fourcc</a>。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_COUNT Python：cv.CAP_PROP_FRAME_COUNT</code></td>
<td>7</td>
<td>视频文件中的帧数。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FORMAT Python：cv.CAP_PROP_FORMAT</code></td>
<td>8</td>
<td><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html#a9ac7f4b1cdfe624663478568486e6712">VideoCapture::retrieve()</a>返回的 Mat 对象的格式。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_MODE Python：cv.CAP_PROP_MODE</code></td>
<td>9</td>
<td>指示当前捕获模式的后端特定值。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_BRIGHTNESS Python：cv.CAP_PROP_BRIGHTNESS</code></td>
<td>10</td>
<td>图像的亮度（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_CONTRAST Python：cv.CAP_PROP_CONTRAST</code></td>
<td>11</td>
<td>图像对比度（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_SATURATION Python：cv.CAP_PROP_SATURATION</code></td>
<td>12</td>
<td>图像的饱和度（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_HUE Python：cv.CAP_PROP_HUE</code></td>
<td>13</td>
<td>图像的色调（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_GAIN Python：cv.CAP_PROP_GAIN</code></td>
<td>14</td>
<td>图像增益（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_EXPOSURE Python：cv.CAP_PROP_EXPOSURE</code></td>
<td>15</td>
<td>曝光（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_CONVERT_RGB Python：cv.CAP_PROP_CONVERT_RGB</code></td>
<td>16</td>
<td>指示图像是否应转换为 RGB 的布尔标志。</td>
</tr>
</tbody></table>
<p>注：部分摄像头设置经验等参数时会被禁用，因为它们有固定的大小支持，一般可以在摄像头的资料页中找到。</p>
<h4 id="录制并保存视频-VideoWriter"><a href="#录制并保存视频-VideoWriter" class="headerlink" title="录制并保存视频 VideoWriter"></a>录制并保存视频 <code>VideoWriter</code></h4><p>之前我们用的是<code>cv2.imwrite()</code>保存图片，要保存视频，我们需要创建一个<code>VideoWriter</code>对象，需要给它保存四个参数：</p>
<ul>
<li>输出的文件名，如’output.avi’</li>
<li>编码方式四<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin">CC</a>码</li>
<li>帧率<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/FPS/3227416">FPS</a></li>
<li>要保存大小 (h,w)</li>
</ul>
<p><code>FourCC</code>是指定视频编码方式的四字节码，所有的编码可参考<a target="_blank" rel="noopener" href="http://www.fourcc.org/codecs.php">Video Codecs</a>。如<code>MJPG</code>编码可以这样写：</p>
<p><code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code></p>
<p>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编码方式并创建VideoWriter对象</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;MJPG&#x27;</span>)</span><br><span class="line">outfile = cv2.VideoWriter(<span class="string">&#x27;output.avi&#x27;</span>, fourcc, <span class="number">55</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(capture.isOpened()):</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        outfile.write(frame)  <span class="comment"># 写入文件</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="练习：实现一个可以选择播放播放的属性"><a href="#练习：实现一个可以选择播放播放的属性" class="headerlink" title="练习：实现一个可以选择播放播放的属性"></a>练习：实现一个可以选择播放播放的属性</h4><p><code>cv2.createTrackbar(&#39;R&#39;,&#39;image&#39;,0,255,call_back)</code></p>
<p>创建一个轨迹栏并将其附加到指定的窗口</p>
<p>参数</p>
<p>滑动条名称</p>
<p>所在窗口名称</p>
<p>当前的值</p>
<p>最大值</p>
<p>回调函数名称，回调函数默认有一个表示当前值的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">track_back</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    ### 回调函数，x表示滑块的位置</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 更改视频的帧位置 cv.CAP_PROP_POS_FRAME是下一个要捕获的帧的基于0的索引</span></span><br><span class="line">    capture.<span class="built_in">set</span>(cv2.CAP_PROP_POS_FRAMES, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;window&#x27;</span>)</span><br><span class="line"></span><br><span class="line">capture = cv2.VideoCapture(<span class="string">&#x27;./demo_video.mp4&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取视频总共多少帧</span></span><br><span class="line">frames = capture.get(cv2.CAP_PROP_FRAME_COUNT)</span><br><span class="line"><span class="comment"># 创建滑动条</span></span><br><span class="line">cv2.createTrackbar(<span class="string">&#x27;process&#x27;</span>, <span class="string">&#x27;window&#x27;</span>, <span class="number">1</span>, <span class="built_in">int</span>(frames), track_back)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(capture.isOpened()):</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;window&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h2><h3 id="固定图像阈值处理-threshold"><a href="#固定图像阈值处理-threshold" class="headerlink" title="固定图像阈值处理 threshold"></a>固定图像阈值处理 threshold</h3><p><code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code></p>
<p>scr: 输入需要处理的原图，只能输入单通道图像，一般是灰度图</p>
<p>dst:输出图</p>
<p>thresh:设置的阈值</p>
<p><code>maxval</code>:对于<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code>阈值方法用的最大阈值，一般为255</p>
<p>type:阈值的方式，主要有5种，详情可见：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576">ThresholdTypes</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#五种不同的阈值方法</span></span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  <span class="comment">#大于阈值127的部分区最大值255也就是白色，小于127部分取0 也就是黑色</span></span><br><span class="line">ret, th2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)<span class="comment">#与THRESH_BINARY 结果相反</span></span><br><span class="line">ret, th3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC) <span class="comment">#所有大于127的就取127在这里进行截断， 而小于的部分不进行改变</span></span><br><span class="line">ret, th4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO) <span class="comment">#大于127的部分保持不变，而其他部分都变为黑色</span></span><br><span class="line">ret, th5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)  <span class="comment">#反转</span></span><br></pre></td></tr></table></figure>

<h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><h2 id="卷积基础–图形边框"><a href="#卷积基础–图形边框" class="headerlink" title="卷积基础–图形边框"></a>卷积基础–图形边框</h2><h3 id="二维卷积："><a href="#二维卷积：" class="headerlink" title="二维卷积："></a>二维卷积：</h3><p><img src="http://cos.codec.wang/cv2_understand_convolution.jpg" alt="img"></p>
<p>卷积就是循环对<strong>图像跟一个核逐个元素相乘再求和得到另外一副图像的操作</strong>，比如结果图中第一个元素5是由原图中3×3的区域与3×3的核逐个元素相乘再相加：</p>
<p>算完之后，整个框再往右移一步继续计算，横向计算完后，再往下移一步继续计算……网上有一副很经典的动态图，方便我们理解卷积：</p>
<p><img src="http://cos.codec.wang/cv2_understand_cnn.gif" alt="img"></p>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫填充padding</strong>。</p>
<blockquote>
<p>事实上，原图为n×n，卷积核为f×f，最终结果图大小为**(n-f+1) × (n-f+1)。**</p>
</blockquote>
<p><img src="http://cos.codec.wang/cv2_understand_padding.jpg" alt="img"></p>
<p>那么扩展的这一层应该填充什么值呢？<code>OpenCV</code>中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现，一起来看看。</p>
<h4 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h4><p><code>cv2.copyMakeBorder()</code>用来给图片添加边框，它有下面几个参数：</p>
<ul>
<li>src：要处理的原图</li>
<li>top, bottom, left, right：上下左右要扩展的像素数( 相应方向上的边框宽度 )</li>
<li>**<code>borderType</code>**：边框类型，这个就是需要关注的填充方式，详情请参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5"> BorderTypes </a>   下图中第二个镜面反射是默认的边框类型</li>
<li><img src="D:\typora\src\image-20211015211738420.png" alt="image-20211015211738420"></li>
</ul>
<p>其中默认方式和固定值方式最常用，我们详细说明一下：</p>
<h4 id="固定值填充"><a href="#固定值填充" class="headerlink" title="固定值填充"></a>固定值填充</h4><p>顾名思义，<code>cv2.BORDER_CONSTANT</code>这种方式就是边框都填充成一个固定的值，比如下面的程序都填充0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;6_by_6.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定值边框，统一都填充0也称为zero padding</span></span><br><span class="line">cons = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_CONSTANT, value=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(cons)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_zero_padding_output.jpg" alt="img"></p>
<h3 id="默认边框类型"><a href="#默认边框类型" class="headerlink" title="默认边框类型"></a>默认边框类型</h3><p>默认边框<code>cv2.BORDER_DEFAULT</code>其实是取镜像对称的像素填充，比较拗口，一步步解释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_DEFAULT)</span><br><span class="line"><span class="built_in">print</span>(default)</span><br></pre></td></tr></table></figure>

<p>首先进行上下填充，填充成与原图像边界对称的值，如下图：</p>
<p><img src="http://cos.codec.wang/cv2_up_down_padding_first.jpg" alt="img"></p>
<p>同理再进行左右两边的填充，最后把四个顶点补充上就好了：</p>
<p><img src="http://cos.codec.wang/cv2_right_left_padding_second2.jpg" alt="img"></p>
<blockquote>
<p>经验之谈：一般情况下默认方式更加合理，因为边界的像素值更加接近。具体应视场合而定。</p>
</blockquote>
<h3 id="OpenCV进行卷积"><a href="#OpenCV进行卷积" class="headerlink" title="OpenCV进行卷积"></a><code>OpenCV</code>进行卷积</h3><p><code>OpenCV</code>中用<code>cv2.filter2D()</code>实现卷积操作，比如我们的核是下面这样（3×3区域像素的和除以10）：</p>
<p><img src="D:\typora\src\image-20211015212412694.png" alt="image-20211015212412694"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.float32) / <span class="number">10</span></span><br><span class="line"><span class="comment"># 卷积操作，-1表示通道数与原图相同</span></span><br><span class="line">dst = cv2.filter2D(img, -<span class="number">1</span>, kernel)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_convolution_kernel_3_3.jpg" alt="img"></p>
<p>可以看到这个核对图像进行了模糊处理，这是卷积的众多功能之一。</p>
<h2 id="图像平滑操作"><a href="#图像平滑操作" class="headerlink" title="图像平滑操作"></a>图像平滑操作</h2><h3 id="滤波与模糊"><a href="#滤波与模糊" class="headerlink" title="滤波与模糊"></a>滤波与模糊</h3><p>关于滤波和模糊:</p>
<ul>
<li>它们都属于卷积，不同滤波方法之间只是卷积核不同（对线性滤波而言）</li>
<li>低通滤波器是模糊，高通滤波器是锐化</li>
</ul>
<p><strong>低通滤波器</strong>就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。<strong>高通滤波器</strong>则反之，用来增强图像边缘，进行锐化处理。</p>
<blockquote>
<p>常见噪声有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958?fr=aladdin">椒盐噪声</a>(脉冲噪声)和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。</p>
</blockquote>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p>
<p><img src="D:\typora\src\image-20211016133058089.png" alt="image-20211016133058089"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">blur = cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 均值模糊</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有的滤波函数都有一个可选参数borderType，这个参数就是<em><strong>卷积基础–图形边框</strong></em>中所说的边框填充方式。</p>
</blockquote>
<h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p>
<p><img src="D:\typora\src\image-20211016133349723.png" alt="image-20211016133349723"></p>
<p>用<code>cv2.boxFilter()</code>函数实现，当可选参数normalize为True的时候，方框滤波就是均值滤波，上式中的a就等于1&#x2F;9；normalize为False的时候，a&#x3D;1，相当于求区域内的像素和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span></span><br><span class="line">blur = cv2.boxFilter(img, -<span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>), normalize=<span class="literal">True</span>) <span class="comment">#卷积操作 -1表示通道数与原图相同</span></span><br></pre></td></tr></table></figure>

<h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小，还记得标准正态分布的曲线吗？</p>
<p><img src="http://cos.codec.wang/cv2_gaussian_kernel_function_theory.jpg" alt="img"></p>
<p>显然这种处理元素间权值的方式更加合理一些。图像是2维的，所以我们需要使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gaussian_filter">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核（具体原理和卷积核生成方式请参考文末的<a target="_blank" rel="noopener" href="http://codec.wang/#/">番外小篇</a>）：</p>
<p><img src="D:\typora\src\image-20211016133709083.png" alt="image-20211016133709083"></p>
<p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;gaussian_noise.bmp&#x27;</span>)</span><br><span class="line"><span class="comment"># 均值滤波vs高斯滤波</span></span><br><span class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></span><br><span class="line">gaussian = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">1</span>)  <span class="comment"># 高斯滤波</span></span><br></pre></td></tr></table></figure>

<p>参数3 σx值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p>
<p><img src="http://cos.codec.wang/cv2_gaussian_vs_average.jpg" alt="img"></p>
<h4 id="高斯滤波卷积核-OpenCV中7-7以下的卷积核是算好了的。"><a href="#高斯滤波卷积核-OpenCV中7-7以下的卷积核是算好了的。" class="headerlink" title="高斯滤波卷积核   OpenCV中7*7以下的卷积核是算好了的。"></a>高斯滤波卷积核   OpenCV中7*7以下的卷积核是算好了的。</h4><p><img src="D:\typora\src\image-20211016134947978.png" alt="image-20211016134947978"></p>
<p>我们可以用<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv2.getGaussianKernel(ksize,sigma)</code></a>来生成一维卷积核：</p>
<ul>
<li>sigma&lt;&#x3D;0时，<code>sigma=0.3*((ksize-1)*0.5 - 1) + 0.8</code></li>
<li>sigma&gt;0时，sigma&#x3D;sigma</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(cv2.getGaussianKernel(<span class="number">3</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 结果：[[0.25][0.5][0.25]]</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20211016135226745.png" alt="image-20211016135226745"></p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>中值又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，<strong>适用于去除椒盐噪声和斑点噪声</strong>。中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p>
<p>比如下面这张斑点噪声图，用中值滤波显然更好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;salt_noise.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 均值滤波vs中值滤波</span></span><br><span class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></span><br><span class="line">median = cv2.medianBlur(img, <span class="number">5</span>)  <span class="comment"># 中值滤波</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_median_vs_average.jpg" alt="img"></p>
<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2">双边滤波</a>。用<code>cv2.bilateralFilter()</code>函数实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 双边滤波vs高斯滤波</span></span><br><span class="line">gau = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)  <span class="comment"># 高斯滤波</span></span><br><span class="line">blur = cv2.bilateralFilter(img, <span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>)  <span class="comment"># 双边滤波</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_bilateral_vs_gaussian.jpg" alt="img"></p>
<p><strong>双边滤波明显保留了更多边缘信息，但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code>。</li>
<li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code>。</li>
<li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code>。</li>
<li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。</li>
<li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37">cv2.blur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3">cv2.boxFilter()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1">cv2.GaussianBlur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa">cv2.getGaussianKernel()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9">cv2.medianBlur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed">cv2.bilateralFilter()</a></li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html">图像平滑处理</a></li>
</ul>
<h2 id="图像梯度（理论基础）："><a href="#图像梯度（理论基础）：" class="headerlink" title="图像梯度（理论基础）："></a>图像梯度（理论基础）：</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2334bee37de5">https://www.jianshu.com/p/2334bee37de5</a></p>
<p>低通滤波器是模糊，高通滤波器是锐化</p>
<h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YZ4y1s7Ra?from=search&amp;seid=18409194473369625551&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1YZ4y1s7Ra?from=search&amp;seid=18409194473369625551&amp;spm_id_from=333.337.0.0</a></p>
<p>水平方向的边界  也就是左右的；  就是假如这里是边界，那么P5的左右两边他P4和P6的值会相差很大，然后P5的值算出来就会很明显，如果P4和P6很接近那么计算的P5就会很接近0  没那么明显  然后就可以根据这个计算出图像的边界。</p>
<img src="D:\typora\src\image-20211016140326016.png" alt="image-20211016140326016" style="zoom:50%;" />

<p>同理。垂直方向就是吧卷积核改一下</p>
<img src="D:\typora\src\image-20211016140853557.png" alt="image-20211016140853557" style="zoom:50%;" />

<p>垂直方向和水平方向的梯度都计算出来了  那么图像的梯度就可以计算</p>
<img src="D:\typora\src\image-20211016140939825.png" alt="image-20211016140939825" style="zoom:50%;" />

<img src="D:\typora\src\image-20211016141022498.png" alt="image-20211016141022498" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#代码表示</span></span><br><span class="line">sobelx = cv2.Sobel(img, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算x方向</span></span><br><span class="line">sobely = cv2.Sobel(img, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算y方向</span></span><br></pre></td></tr></table></figure>



<h3 id="Laplacian（拉普拉斯）算子"><a href="#Laplacian（拉普拉斯）算子" class="headerlink" title="Laplacian（拉普拉斯）算子"></a><img src="http://cos.codec.wang/cv2_horizen_vertical_edge_detection.jpg" alt="垂直和水平边界下降">Laplacian（拉普拉斯）算子</h3><p>拉普拉斯算子类似于<strong>二阶</strong>Sobel导数。</p>
<p>在OpenCV中通过调用sobel算子来计算拉普拉斯算子，使用公式：</p>
<p><img src="D:\typora\src\image-20211016142426256.png" alt="image-20211016142426256"></p>
<p>使用卷积核：</p>
<p><img src="D:\typora\src\image-20211016142440656.png" alt="image-20211016142440656"></p>
<p>就算出来就是上下左右全部减一次中间，然后再相加</p>
<img src="D:\typora\src\image-20211017095425784.png" alt="image-20211017095425784"  />

<p>然后判断的依据和sobel算子类似，值小那就是梯度值小，非边界，值大就是梯度大，是边界</p>
<p>OpenCV中直接使用<code>cv2.Laplacian()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(img, -<span class="number">1</span>)  <span class="comment"># 使用Laplacian算子</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_laplacian.jpg" alt="img"></p>
<p>也可如此理解，更加深入一点。</p>
<p><img src="D:\typora\src\image-20211016142242956.png" alt="image-20211016142242956"></p>
<h2 id="边缘检测："><a href="#边缘检测：" class="headerlink" title="边缘检测："></a>边缘检测：</h2><p>cv2.Canny()</p>
<p>Canny边缘检测方法被誉为边缘检测的最优方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(img, <span class="number">30</span>, <span class="number">70</span>)  <span class="comment"># canny边缘检测</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;canny&#x27;</span>, np.hstack((img, edges)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>之前采用低通滤波模糊图片，也就是去噪点，而想要得到图像边缘就需要用到高通滤波，锐化图像</p>
<h3 id="Canny边界检测"><a href="#Canny边界检测" class="headerlink" title="Canny边界检测"></a>Canny边界检测</h3><ol>
<li><p>使用5×5高斯排除噪音：</p>
<p>边缘操作本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理</p>
</li>
<li><p>计算图像梯度方向</p>
</li>
</ol>
<p>   使用sobel算子计算两个方向上的GX和GY，然后算出梯度方向：</p>
<p>   <img src="D:\typora\src\image-20211017100727722.png" alt="image-20211017100727722"></p>
<ol start="3">
<li>取局部极大值：</li>
</ol>
<p>   梯度已经有了轮廓，但为了进一步筛选，可以从（0°&#x2F;45°&#x2F;90°&#x2F;135°）这四个角度方向上取局部极大值</p>
<p>   比如A点在45°方向上大于B&#x2F;C点，那就保留A然后将B&#x2F;C设置为0.</p>
<p>   <img src="http://cos.codec.wang/cv2_understand_canny_direction.jpg" alt="img"></p>
<ol start="4">
<li>滞后阈值：Canny推荐的高低阈值比在2:1到3:1之间。</li>
</ol>
<p>   经过前面三步，就只剩下0和可能的边缘梯度值了，为了最终确定下来，需要设定高低阈值：</p>
<pre><code>   像素点的值大于最高阈值,那肯定是边缘
   
   像素值小于最低阈值那肯定不是边缘
   
   像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘
</code></pre>
<p>   AC是边缘   B不是。</p>
<p>   <img src="http://cos.codec.wang/cv2_understand_canny_max_min_val.jpg" alt="img"></p>
<h3 id="先阈值分割后检测"><a href="#先阈值分割后检测" class="headerlink" title="先阈值分割后检测"></a>先阈值分割后检测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)  <span class="comment">#自适应阈值分割 python中如果某个值不用，可以用下划线代替</span></span><br><span class="line">edges = cv2.Canny(thresh, <span class="number">30</span>, <span class="number">70</span>)  <span class="comment">#边缘检测，上阈值70 ，下阈值30</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;canny&#x27;</span>, np.hstack((img, thresh, edges)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_canny_edge_detection_threshold.jpg"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#滑动条调节阈值，理解高地阈值效果：</span><br><span class="line">import cv2</span><br><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">def track<span class="constructor">_back(<span class="params">x</span>)</span>:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">ori_img=cv2.imread(&#x27;<span class="module-access"><span class="module"><span class="identifier">NV</span>.</span></span>jpg&#x27;,<span class="number">0</span>)</span><br><span class="line">cv2.named<span class="constructor">Window(&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">cv2.create<span class="constructor">Trackbar(&#x27;<span class="params">upper</span>&#x27;,&#x27;<span class="params">window</span>&#x27;,100,255,<span class="params">track_back</span>)</span></span><br><span class="line">cv2.create<span class="constructor">Trackbar(&#x27;<span class="params">low</span>&#x27;,&#x27;<span class="params">window</span>&#x27;,200,255,<span class="params">track_back</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(True):</span><br><span class="line">    upper_= cv2.get<span class="constructor">TrackbarPos(&#x27;<span class="params">upper</span>&#x27;,&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">    low_=cv2.get<span class="constructor">TrackbarPos(&#x27;<span class="params">low</span>&#x27;,&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">    edges=cv2.<span class="constructor">Canny(<span class="params">ori_img</span>,<span class="params">low_</span>,<span class="params">upper_</span>)</span></span><br><span class="line">    cv2.imshow(&#x27;window&#x27;,edges)</span><br><span class="line">    <span class="keyword">if</span> cv2.wait<span class="constructor">Key(30)</span>==ord(<span class="character">&#x27;q&#x27;</span>):  #键入 q 关闭窗口   记得一定不要设置为<span class="number">0</span>  无限等待  不然循环无法进行下去</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h2 id="腐蚀与膨胀"><a href="#腐蚀与膨胀" class="headerlink" title="腐蚀与膨胀"></a>腐蚀与膨胀</h2><p>形态学操作  腐蚀  膨胀  开运算和闭运算</p>
<p>cv2.erode()  cv2.dilate()  cv2.morpho;ogyEx()</p>
<h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p><code>cv2.erode(src, kernel, iteration)</code></p>
<p>参数说明：</p>
<p>src表示图片 </p>
<p>kernel指腐蚀操作的内核，默认是一个简单的3X3矩阵，我们也可以利用<code>getStructuringElement（）</code>函数指明它的形状</p>
<p>iterations指的是腐蚀次数，省略是默认为1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;j.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8) <span class="comment">#指定核大小</span></span><br><span class="line">erosion = cv2.erode(img, kernel)  <span class="comment"># 腐蚀</span></span><br></pre></td></tr></table></figure>

<p>这个核也叫结构元素，因为形态学操作其实也是应用卷积来实现的结构元素可以是矩形&#x2F;椭圆&#x2F;十字形，可以用。<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 矩形结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 椭圆结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 十字形结构</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_morphological_struct_element.jpg" alt="img"></p>
<h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p><code>dilate()</code>可以对输入图像用特定结构元素进行膨胀操作，该结构元素确定膨胀操作过程中的邻域的形状，各点像素值将被替换为对应邻域上的最大值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dilation = cv2.dilate(img, kernel)  <span class="comment"># 膨胀</span></span><br></pre></td></tr></table></figure>

<h3 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h3><p><code>cv2.morphologyEx()</code></p>
<p>先腐蚀后膨胀开运算 </p>
<p>作用：分开物体，分解区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 定义结构元素  矩形结构</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;j_noise_out.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></span><br></pre></td></tr></table></figure>

<h3 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h3><p>先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除&#x2F;“闭合”物体里面的小黑洞，所以叫闭运算）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;j_noise_in.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul>
<li>形态学梯度：膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;school.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_morphological_gradient.jpg" alt="img"></p>
<ul>
<li>顶帽：原图减去开运算后的图：<code>src - opening</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<ul>
<li>黑帽：闭运算后的图减去原图：<code>closing - src</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>

<h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p><img src="https://img-blog.csdnimg.cn/20200622220127452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5czQzMDM4MV8x,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>轮廓是连续的，边缘并不全都连续</strong>（下图）。其实<strong>边缘主要是作为图像的特征使用</strong>，比如可以用边缘特征可以区分脸和手，而<strong>轮廓主要用来分析物体的形态</strong>，比如物体的周长和面积等，可以说边缘包括轮廓。</p>
<p><img src="http://cos.codec.wang/cv2_understand_contours.jpg" alt="边缘和轮廓的区别"></p>
<p><strong>寻找轮廓一般用于二值化图像，所以通常会使用阈值分割或者Canny边缘检测得到二值图</strong></p>
<p>寻找轮廓是针对白色物体的，一定要保证物体是白色，背景是黑色，不然很多人在新专辑轮廓是会找到图片最外面的一个框</p>
<h3 id="第一步：寻找轮廓"><a href="#第一步：寻找轮廓" class="headerlink" title="第一步：寻找轮廓"></a>第一步：寻找轮廓</h3><p>使用<code>cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]])</code></p>
<p>返回两个值：contours;hierarchy</p>
<p>参数：</p>
<p>image 表示寻找轮廓的图像</p>
<p>mode表示轮廓的检索模式，有四种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.RETR_EXTERNAL   <span class="comment">#表示只检测外轮廓</span></span><br><span class="line">cv2.RETR_LIST   <span class="comment">#检测的轮廓不建立等级关系</span></span><br><span class="line">cv2.RETR_CCOMP <span class="comment">#建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。</span></span><br><span class="line">cv2.RETR_TREE   <span class="comment">#建立一个等级树结构的轮廓</span></span><br></pre></td></tr></table></figure>
<p>method是轮廓的近似方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.CHAIN_APPROX_NONE<span class="comment">#存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即max（abs（x1-x2），abs（y2-y1））==1</span></span><br><span class="line">cv2.CHAIN_APPROX_SIMPLE<span class="comment">#压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息</span></span><br><span class="line">cv2.CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain <span class="comment">#近似算法</span></span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line">img = cv2.imread(<span class="string">&#x27;D:\\test\\contour.jpg&#x27;</span>)</span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"> </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  <span class="comment">#寻找轮廓</span></span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>原图：<img src="https://img-blog.csdn.net/20131030153346984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VubnkyMDM4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:33%;" />检测图<img src="https://img-blog.csdn.net/20131030153441656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VubnkyMDM4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:33%;" /></p>
<p><strong>findcontours函数会“原地”修改输入的图像</strong>  也就是说原图被改变了</p>
<p><strong>contour返回值</strong><br>    cv2.findContours()函数首先返回一个list，list中每个元素都是图像中的一个轮廓，用numpy中的ndarray表示。这个概念非常重要。在下面drawContours中会看见。通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(contours))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(contours[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours))</span><br><span class="line"><span class="comment">#可以验证上述信息。会看到本例中有两条轮廓，一个是五角星的，一个是矩形的。每个轮廓是一个ndarray，每个ndarray是轮廓上的点的集合。</span></span><br><span class="line">由于我们知道返回的轮廓有两个，因此可通过</span><br><span class="line">cv2.drawContours(img,contours,<span class="number">0</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line">和</span><br><span class="line">cv2.drawContours(img,contours,<span class="number">1</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">分别绘制两个轮廓，关于该参数可参见下面一节的内容。同时通过</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours[<span class="number">1</span>]))</span><br><span class="line">输出两个轮廓中存储的点的个数，可以看到，第一个轮廓中只有<span class="number">4</span>个元素，这是因为轮廓中并不是存储轮廓上所有的点，而是只存储可以用直线描述轮廓的点的个数，比如一个“正立”的矩形，只需<span class="number">4</span>个顶点就能描述轮廓了。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>hierarchy返回值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">此外，该函数还可返回一个可选的hiararchy结果，这是一个ndarray，其中的元素个数和轮廓个数相同，每个轮廓contours[i]对应<span class="number">4</span>个hierarchy元素hierarchy[i][<span class="number">0</span>] ~hierarchy[i][<span class="number">3</span>]，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，则该值为负数。</span><br><span class="line">通过</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(hierarchy))</span><br><span class="line"><span class="built_in">print</span> (hierarchy.ndim)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span> (hierarchy[<span class="number">0</span>].ndim)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span> (hierarchy.shape) <span class="comment"># (1, 2, 4)</span></span><br></pre></td></tr></table></figure>

<h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><img src="D:\typora\src\image-20211018233258899.png" alt="image-20211018233258899" style="zoom:150%;" />

<p><code>cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset ]]]]])</code></p>
<p>第一个参数是指明在哪幅图像上绘制轮廓；<br>第二个参数是轮廓本身，在Python中是一个list。<br>第三个参数指定绘制轮廓list中的哪条轮廓，如果是-1，则绘制其中的所有轮廓。</p>
<p>后面的参数很简单。其中thickness表明轮廓线的宽度，如果是-1（cv2.FILLED），则为填充模式。绘制参数将在以后独立详细介绍。</p>
<h2 id="轮廓层级"><a href="#轮廓层级" class="headerlink" title="轮廓层级"></a>轮廓层级</h2><p>很多情况下，图像中的形状之间是有关联的</p>
<p><img src="http://cos.codec.wang/cv2_understand_hierarchy.jpg" alt="img"></p>
<p>图中总共有8条轮廓，2和2a分别表示外层和里层的轮廓，3和3a也是一样。从图中看得出来：</p>
<ul>
<li>轮廓0&#x2F;1&#x2F;2是最外层的轮廓，我们可以说它们处于同一轮廓等级：0级</li>
<li>轮廓2a是轮廓2的子轮廓，反过来说2是2a的父轮廓，轮廓2a算一个等级：1级</li>
<li><strong>同样3是2a的子轮廓，轮廓3处于一个等级：2级</strong></li>
<li>类似的，3a是3的子轮廓</li>
</ul>
<p>这里面OpenCV关注的就是两个概念：<strong>同一轮廓等级</strong>和<strong>轮廓间的子属关系</strong>。</p>
<h3 id="OpenCV中轮廓等级的表示"><a href="#OpenCV中轮廓等级的表示" class="headerlink" title="OpenCV中轮廓等级的表示"></a>OpenCV中轮廓等级的表示</h3><p>如果我们打印出<code>cv2.findContours()</code>函数的返回值hierarchy，会发现它是一个包含4个值的数组：**[Next, Previous, First Child, Parent]**</p>
<ul>
<li><em>Next：与当前轮廓处于同一层级的下一条轮廓</em></li>
</ul>
<p>举例来说，前面图中跟0处于同一层级的下一条轮廓是1，所以Next&#x3D;1；同理，对轮廓1来说，Next&#x3D;2；<em>那么没有与它同一层级的轮廓的下一条轮廓了时，此时Next&#x3D;-1。</em></p>
<ul>
<li><em>Previous：与当前轮廓处于同一层级的上一条轮廓</em></li>
</ul>
<p>跟前面一样，对于轮廓1来说，Previous&#x3D;0；对于轮廓2，Previous&#x3D;1；对于轮廓1，没有上一条轮廓了，所以Previous&#x3D;-1。</p>
<ul>
<li><em>First Child：当前轮廓的第一条子轮廓</em></li>
</ul>
<p>比如对于轮廓2，第一条子轮廓就是轮廓2a，所以First Child&#x3D;2a；对轮廓3a，First Child&#x3D;4。</p>
<ul>
<li><em>Parent：当前轮廓的父轮廓</em></li>
</ul>
<p>比如2a的父轮廓是2，Parent&#x3D;2；轮廓2没有父轮廓，所以Parent&#x3D;-1。</p>
<p>下面我们通过代码验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.读入图片</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;hierarchy.jpg&#x27;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, thresh = cv2.threshold(img_gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.寻找轮廓</span></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.绘制轮廓</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(contours),hierarchy)  <span class="comment"># 8条</span></span><br><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)  <span class="comment">#画出所有的轮廓  红色线条</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经验之谈：OpenCV中找到的轮廓序号跟前面讲的不同噢，如下图：</p>
</blockquote>
<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_TREE.jpg" alt="img"></p>
<p>现在既然我们了解了层级的概念，那么类似cv2.RETR_TREE的轮廓寻找方式又是啥意思呢？</p>
<h3 id="轮廓寻找方式"><a href="#轮廓寻找方式" class="headerlink" title="轮廓寻找方式"></a>轮廓寻找方式</h3><p>OpenCV中有四种轮廓寻找方式<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71">RetrievalModes</a>，下面分别来看下：</p>
<h3 id="1-RETR-LIST"><a href="#1-RETR-LIST" class="headerlink" title="1. RETR_LIST"></a>1. RETR_LIST</h3><p>这是最简单的一种寻找方式，它不建立轮廓间的子属关系，也就是所有轮廓都属于同一层级。这样，hierarchy中的后两个值[First Child, Parent]都为-1。比如同样的图，我们使用cv2.RETR_LIST来寻找轮廓：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, _, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(hierarchy)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">3</span>  <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">2</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">5</span>  <span class="number">3</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">4</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">7</span>  <span class="number">5</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">6</span> -<span class="number">1</span> -<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>

<p>因为没有从属关系，所以轮廓0的下一条是1，1的下一条是2……</p>
<blockquote>
<p>经验之谈：<strong>如果你不需要轮廓层级信息的话，cv2.RETR_LIST更推荐使用，因为性能更好。</strong></p>
</blockquote>
<h3 id="2-RETR-TREE"><a href="#2-RETR-TREE" class="headerlink" title="2. RETR_TREE"></a>2. RETR_TREE</h3><p>cv2.RETR_TREE就是之前我们一直在使用的方式，它会完整建立轮廓的层级从属关系，前面已经详细说明过了。</p>
<h3 id="3-RETR-EXTERNAL"><a href="#3-RETR-EXTERNAL" class="headerlink" title="3. RETR_EXTERNAL"></a>3. RETR_EXTERNAL</h3><p>这种方式只寻找最高层级的轮廓，也就是它只会找到前面我们所说的3条0级轮廓：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(contours), hierarchy, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_EXTERNAL.jpg" alt="img"></p>
<h3 id="4-RETR-CCOMP"><a href="#4-RETR-CCOMP" class="headerlink" title="4. RETR_CCOMP"></a>4. RETR_CCOMP</h3><p>相比之下cv2.RETR_CCOMP比较难理解，但其实也很简单：它把所有的轮廓只分为2个层级，不是外层的就是里层的。结合代码和图片，我们来理解下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(hierarchy)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">1</span>  <span class="number">3</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">2</span>  <span class="number">5</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>  <span class="number">4</span>]</span><br><span class="line">  [ <span class="number">7</span>  <span class="number">4</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">6</span> -<span class="number">1</span> -<span class="number">1</span>]]]Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_CCOMP.jpg" alt="img"></p>
<blockquote>
<p>注意：使用这个参数找到的轮廓序号与之前不同。</p>
</blockquote>
<p>图中括号里面1代表外层轮廓，2代表里层轮廓。比如说对于轮廓2，Next就是4，Previous是1，它有里层的轮廓3，所以First Child&#x3D;3，但因为只有两个层级，它本身就是外层轮廓，所以Parent&#x3D;-1。大家可以针对其他的轮廓自己验证一下。</p>
<h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><img src="http://cos.codec.wang/cv2_min_rect_rect_bounding.jpg" alt="img" style="zoom:50%;" />

<p>在计算轮廓特征前，先寻找轮廓</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以数字3的轮廓为例</span></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="http://cos.codec.wang/cv2_31_handwriting_sample.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshLEold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以数字3的轮廓为例</span></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>为了便于绘制，我们创建出两幅彩色图，并把轮廓画在第一幅图上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</span><br><span class="line">img_color2 = np.copy(img_color1)</span><br><span class="line">cv2.drawContours(img_color1, [cnt], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)  <span class="comment"># 4386.5</span></span><br></pre></td></tr></table></figure>

<p>注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。</p>
<blockquote>
<p>如果统计二值图中像素点个数，应尽量避免循环，**可以使用<code>cv2.countNonZero()</code>**，更加高效。</p>
</blockquote>
<h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">perimeter = cv2.arcLength(cnt, <span class="literal">True</span>)  <span class="comment"># 585.7</span></span><br></pre></td></tr></table></figure>

<p>参数2表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是True。</p>
<h3 id="图像矩"><a href="#图像矩" class="headerlink" title="图像矩"></a>图像矩</h3><p>矩可以理解为图像的各类几何特征，详情请参考：[<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Image_moment">Image Moments</a>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = cv2.moments(cnt)</span><br></pre></td></tr></table></figure>

<p>M中包含了很多轮廓的特征信息，比如M[‘m00’]表示轮廓面积，与前面<code>cv2.contourArea()</code>计算结果是一样的。质心也可以用它来算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cx, cy = M[<span class="string">&#x27;m10&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>], M[<span class="string">&#x27;m01&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>]  <span class="comment"># (205, 281)</span></span><br></pre></td></tr></table></figure>

<h3 id="外接矩形"><a href="#外接矩形" class="headerlink" title="外接矩形"></a>外接矩形</h3><p>形状的外接矩形有两种，如下图，绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转：</p>
<p><img src="http://cos.codec.wang/cv2_min_rect_rect_bounding.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)  <span class="comment"># 外接矩形</span></span><br><span class="line">cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)Copy to clipboardErrorCopied</span><br><span class="line">rect = cv2.minAreaRect(cnt)  <span class="comment"># 最小外接矩形</span></span><br><span class="line">box = np.int0(cv2.boxPoints(rect))  <span class="comment"># 矩形的四个角点取整</span></span><br><span class="line">cv2.drawContours(img_color1, [box], <span class="number">0</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>其中np.int0(x)是把x取整的操作，比如377.93就会变成377，也可以用x.astype(np.int)。</p>
<h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>外接圆跟外接矩形一样，找到一个能包围物体的最小圆：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(x, y), radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">(x, y, radius) = np.int0((x, y, radius))  <span class="comment"># 圆心和半径取整</span></span><br><span class="line">cv2.circle(img_color2, (x, y), radius, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_min_enclosing_circle.jpg" alt="img"></p>
<h3 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h3><p>我们可以用得到的轮廓拟合出一个椭圆：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ellipse = cv2.fitEllipse(cnt)</span><br><span class="line">cv2.ellipse(img_color2, ellipse, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_fitting_ellipse.jpg" alt="img"></p>
<h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回<strong>值越小，越相似</strong>。先读入下面这张图片：</p>
<p><img src="http://cos.codec.wang/cv2_match_shape_shapes.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;shapes.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)  <span class="comment"># 用于绘制的彩色图</span></span><br></pre></td></tr></table></figure>

<p>图中有3条轮廓，我们用A&#x2F;B&#x2F;C表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cnt_a, cnt_b, cnt_c = contours[<span class="number">0</span>], contours[<span class="number">1</span>], contours[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_b, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.0</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 2.17e-05</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_a, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.418</span></span><br></pre></td></tr></table></figure>

<p>可以看到BC相似程度比AB高很多，并且图形的旋转或缩放并没有影响。其中，参数3是匹配方法，详情可参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f">ShapeMatchModes</a>，参数4是OpenCV的预留参数，暂时没有实现，可以不用理会。</p>
<p>形状匹配是通过图像的Hu矩来实现的(<code>cv2.HuMoments()</code>)，大家如果感兴趣，可以参考：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Image_moment#Rotation_invariant_moments">Hu-Moments</a></p>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p><img src="http://cos.codec.wang/cv2_understand_histogram.jpg" alt="img"></p>
<ul>
<li>计算并绘制直方图</li>
<li>（自适应）直方图均衡化</li>
<li>OpenCV函数：<code>cv2.calcHist()</code>, <code>cv2.equalizeHist()</code></li>
</ul>
<h3 id="啥叫直方图"><a href="#啥叫直方图" class="headerlink" title="啥叫直方图"></a>啥叫直方图</h3><p>简单来说，直方图就是图像中每个像素值的个数统计，比如说一副灰度图中像素值为0的有多少个，1的有多少个……:</p>
<p><img src="http://cos.codec.wang/cv2_understand_histogram.jpg" alt="img"></p>
<p>在计算直方图之前，有几个术语先来了解一下：</p>
<ul>
<li>dims: 要计算的通道数，对于灰度图dims&#x3D;1，普通彩色图dims&#x3D;3</li>
<li>range: 要计算的像素值范围，一般为[0,256)</li>
<li>bins: 子区段数目，如果我们统计0<code>~</code>255每个像素值，bins&#x3D;256；如果划分区间，比如0<code>~</code>15, 16<code>~</code>31…240<code>~</code>255这样16个区间，bins&#x3D;16</li>
</ul>
<h3 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h3><p>OpenCV和Numpy中都提供了计算直方图的函数，我们对比下它们的性能。</p>
<h4 id="OpenCV中直方图计算"><a href="#OpenCV中直方图计算" class="headerlink" title="OpenCV中直方图计算"></a>OpenCV中直方图计算</h4><p>使用<code>cv2.calcHist(images, channels, mask, histSize, ranges)</code>计算，其中：</p>
<ul>
<li>参数1：要计算的原图，以方括号的传入，如：[img]</li>
<li>参数2：类似前面提到的dims，<strong>灰度图写[0]就行，彩色图B&#x2F;G&#x2F;R分别传入[0]&#x2F;[1]&#x2F;[2]</strong></li>
<li>参数3（mask）：要计算的区域，计算整幅图的话，写None</li>
<li>参数4：前面提到的bins</li>
<li>参数5：前面提到的range</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;hist.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.025288 s</span></span><br></pre></td></tr></table></figure>

<h3 id="计算部分图像直方图"><a href="#计算部分图像直方图" class="headerlink" title="计算部分图像直方图"></a>计算部分图像直方图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=cv2.imread(<span class="string">&#x27;hist.jpg&#x27;</span>,<span class="number">0</span>)  <span class="comment"># (1024,683)</span></span><br><span class="line">mask=np.zeros(img.shape,dtype=np.uint8)</span><br><span class="line">mask[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">200</span>]=<span class="number">255</span></span><br><span class="line">hist=cv2.calcHist([img],[<span class="number">0</span>],mask,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20211026210142552.png" alt="image-20211026210142552" style="zoom:50%;" /><img src="D:\typora\src\image-20211026210157181.png" alt="image-20211026210157181" style="zoom:50%;" /></p>
<h4 id="Numpy中直方图计算"><a href="#Numpy中直方图计算" class="headerlink" title="Numpy中直方图计算"></a>Numpy中直方图计算</h4><p>也可用Numpy的函数计算，其中<a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html">ravel()</a>函数将二维矩阵展平变成一维数组，之前有提到过：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hist, bins = np.histogram(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.020628 s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经验之谈：Numpy中还有一种更高效的方式：（还记得怎么评估性能吗：代码性能优化]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hist = np.bincount(img.ravel(), minlength=<span class="number">256</span>)  <span class="comment"># 性能：0.003163 s</span></span><br></pre></td></tr></table></figure>

<p>计算出直方图之后，怎么把它画出来呢？</p>
<h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><p>其实Matplotlib自带了一个计算并绘制直方图的功能，不需要用到上面的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>当然，也可以用前面计算出来的结果绘制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_calc_draw_histogram.jpg" alt="img"></p>
<p>从直方图上可以看到图片的大部分区域集中在150偏白的附近，这其实并不是很好的效果，下面我们来看看如何改善它。</p>
<blockquote>
<p>使用OpenCV的画线功能也可以画直方图，不过太麻烦了</p>
</blockquote>
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。其实从观感上就可以发现，前面那幅图对比度不高，偏灰白。对均衡化算法感兴趣的同学可参考：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96">维基百科：直方图均衡化</a></p>
<p><img src="http://cos.codec.wang/cv2_understand_histogram_equalization.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br></pre></td></tr></table></figure>

<p>OpenCV中用<code>cv2.equalizeHist()</code>实现均衡化。我们把两张图片并排显示，对比一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;equalization&#x27;</span>, np.hstack((img, equ)))  <span class="comment"># 并排显示</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_before_after_equalization.jpg" alt="img"></p>
<p><img src="http://cos.codec.wang/cv2_before_after_equalization_histogram.jpg" alt="均衡化前后的直方图对比"></p>
<p>可以看到均衡化后图片的亮度和对比度效果明显好于原图。</p>
<h3 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h3><p>不难看出来，直方图均衡化是应用于整幅图片的，会有什么问题呢？看下图：</p>
<p><img src="http://cos.codec.wang/cv2_understand_adaptive_histogram.jpg" alt="img"></p>
<p>很明显，因为全局调整亮度和对比度的原因，脸部太亮，大部分细节都丢失了。</p>
<p>自适应均衡化就是用来解决这一问题的：它在每一个小区域内（默认8×8）进行直方图均衡化。当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制，所以这个算法全称叫：<strong>对比度受限的自适应直方图均衡化</strong>CLAHE(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization">Contrast Limited Adaptive Histogram Equalization</a>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自适应均衡化，参数可选</span></span><br><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">cl1 = clahe.apply(img)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_adaptive_histogram.jpg" alt="img"></p>
<h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><p>[模板匹配]: <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D">https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D</a>	“模板匹配”</p>
<p>用来在大图中找小图，也就是说在一副图像中寻找另外一张模板图像的位置</p>
<img src="http://cos.codec.wang/cv2_understand_template_matching.jpg" alt="img" style="zoom:50%;" />

<p>用<code>cv2.matchTemplate()</code>实现模板匹配。首先我们来读入图片和模板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;face.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]  <span class="comment"># rows-&gt;h, cols-&gt;</span></span><br></pre></td></tr></table></figure>

<p>匹配函数返回的是一副灰度图，最白的地方表示最大的匹配。使用<code>cv2.minMaxLoc()</code>函数可以得到最大匹配值的坐标，以这个点为左上角角点，模板的宽和高画矩形就是匹配的位置了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span></span><br><span class="line">res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF)</span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line"></span><br><span class="line">left_top = max_loc  <span class="comment"># 左上角</span></span><br><span class="line">right_bottom = (left_top[<span class="number">0</span>] + w, left_top[<span class="number">1</span>] + h)  <span class="comment"># 右下角</span></span><br><span class="line">cv2.rectangle(img, left_top, right_bottom, <span class="number">255</span>, <span class="number">2</span>)  <span class="comment"># 画出矩形位置</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_ccoeff_matching_template.jpg" alt="img"></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>这部分可看可不看，不太理解也没关系，还记得前面的方法吗？不懂得就划掉(✿◕‿◕✿)</p>
</blockquote>
<p>模板匹配的原理其实很简单，就是不断地在原图中移动模板图像去比较，有6种不同的比较方法，详情可参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d">TemplateMatchModes</a></p>
<ul>
<li>平方差匹配CV_TM_SQDIFF：用两者的平方差来匹配，最好的匹配值为0</li>
<li>归一化平方差匹配CV_TM_SQDIFF_NORMED</li>
<li>相关匹配CV_TM_CCORR：用两者的乘积匹配，数值越大表明匹配程度越好</li>
<li>归一化相关匹配CV_TM_CCORR_NORMED</li>
<li>相关系数匹配CV_TM_CCOEFF：用两者的相关系数匹配，1表示完美的匹配，-1表示最差的匹配</li>
<li>归一化相关系数匹配CV_TM_CCOEFF_NORMED</li>
</ul>
<p>归一化的意思就是将值统一到0~1，这些方法的对比代码可到<a target="_blank" rel="noopener" href="http://codec.wang/#/">源码处</a>查看。模板匹配也是应用卷积来实现的：假设原图大小为W×H，模板图大小为w×h，那么生成图大小是(W-w+1)×(H-h+1)，生成图中的每个像素值表示原图与模板的匹配程度。</p>
<h3 id="匹配多个物体"><a href="#匹配多个物体" class="headerlink" title="匹配多个物体"></a>匹配多个物体</h3><p>前面我们是找最大匹配的点，所以只能匹配一次。我们可以设定一个匹配阈值来匹配多次：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.读入原图和模板</span></span><br><span class="line">img_rgb = cv2.imread(<span class="string">&#x27;mario.jpg&#x27;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;mario_coin.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.标准相关模板匹配</span></span><br><span class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = <span class="number">0.8</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.这边是Python/Numpy的知识，后面解释</span></span><br><span class="line">loc = np.where(res &gt;= threshold)  <span class="comment"># 匹配程度大于%80的坐标y,x</span></span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):  <span class="comment"># *号表示可选参数</span></span><br><span class="line">    right_bottom = (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h)</span><br><span class="line">    cv2.rectangle(img_rgb, pt, right_bottom, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_template_matching_multi.jpg" alt="img"></p>
<p>第3步有几个Python&#x2F;Numpy的重要知识，来大致看下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html">np.where()</a>在这里返回res中值大于0.8的所有坐标，如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(np.where(x &gt; <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果(先y坐标，再x坐标)：(array([2, 2, 2]), array([0, 1, 2]))</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_np_where_function.jpg" alt="img"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/functions.html#zip">zip()</a>函数，功能强大到难以解释，举个简单例子就知道了：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(x, y)))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br></pre></td></tr></table></figure>

<p>这样大家就能理解前面代码的用法了吧：因为loc是先y坐标再x坐标，所以用loc[::-1]翻转一下，然后再用zip函数拼接在一起。</p>
<h2 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h2><p><img src="http://cos.codec.wang/cv2_understand_hough_transform.jpg" alt="img"></p>
<p>学习使用霍夫变换识别出图像中的直线和圆。图片等可到文末引用处下载。</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>理解霍夫变换的实现</li>
<li>分别使用霍夫线变换和圆变换检测图像中的直线和圆</li>
<li>OpenCV函数：<code>cv2.HoughLines()</code>, <code>cv2.HoughLinesP()</code>, <code>cv2.HoughCircles()</code></li>
</ul>
<h3 id="理解霍夫变换"><a href="#理解霍夫变换" class="headerlink" title="理解霍夫变换"></a>理解霍夫变换</h3><p>霍夫变换常用来在图像中提取直线和圆等几何形状，我来做个简易的解释：</p>
<p><img src="http://cos.codec.wang/cv2_understand_hough_transform.jpg" alt="img"></p>
<p>学过几何的都知道，直线可以分别用直角坐标系和极坐标系来表示：</p>
<p><img src="http://cos.codec.wang/cv2_line_expression_in_coordinate.jpg" alt="img"></p>
<p>那么经过某个点(x0,y0)的所有直线都可以用这个式子来表示：</p>
<p>r_\theta&#x3D;x_0\cdot\cos \theta+y_0\cdot\sin \thetarθ&#x3D;x0⋅cosθ+y0⋅sinθ</p>
<p>也就是说每一个(r,θ)都表示一条经过(x0,y0)直线，那么同一条直线上的点必然会有同样的(r,θ)。如果将某个点所有的(r,θ)绘制成下面的曲线，那么同一条直线上的点的(r,θ)曲线会相交于一点：</p>
<p><img src="http://cos.codec.wang/cv2_curve_of_r_theta.jpg" alt="img"></p>
<p>OpenCV中首先计算(r,θ) 累加数，累加数超过一定值后就认为在同一直线上。</p>
<h3 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h3><p>OpenCV中用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的(r,θ)数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.加载图片，转为二值图</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;shapes.jpg&#x27;</span>)</span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.霍夫直线变换</span></span><br><span class="line">lines = cv2.HoughLines(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure>

<p>函数中：</p>
<ul>
<li>参数1：要检测的二值图（一般是阈值分割或边缘检测后的图）</li>
<li>参数2：距离r的精度，值越大，考虑越多的线</li>
<li>参数3：角度θ的精度，值越小，考虑越多的线</li>
<li>参数4：累加数阈值，值越小，考虑越多的线</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.将检测的线画出来（注意是极坐标噢）</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    rho, theta = line[<span class="number">0</span>]</span><br><span class="line">    a = np.cos(theta)</span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a * rho</span><br><span class="line">    y0 = b * rho</span><br><span class="line">    x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (-b))</span><br><span class="line">    y1 = <span class="built_in">int</span>(y0 + <span class="number">1000</span> * (a))</span><br><span class="line">    x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (-b))</span><br><span class="line">    y2 = <span class="built_in">int</span>(y0 - <span class="number">1000</span> * (a))</span><br><span class="line"></span><br><span class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hough_line_function.jpg" alt="img"></p>
<h3 id="统计概率霍夫直线变换"><a href="#统计概率霍夫直线变换" class="headerlink" title="统计概率霍夫直线变换"></a>统计概率霍夫直线变换</h3><p>前面的方法又称为标准霍夫变换，它会计算图像中的每一个点，计算量比较大，另外它得到的是整一条线（r和θ），并不知道原图中直线的端点。所以提出了统计概率霍夫直线变换(Probabilistic Hough Transform)，是一种改进的霍夫变换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line"><span class="comment"># 3.统计概率霍夫线变换</span></span><br><span class="line">lines = cv2.HoughLinesP(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>,</span><br><span class="line">                        minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>前面几个参数跟之前的一样，有两个可选参数：</p>
<ul>
<li><code>minLineLength</code>：最短长度阈值，比这个长度短的线会被排除</li>
<li><code>maxLineGap</code>：同一直线两点之间的最大距离</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.将检测的线画出来</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1, y1, x2, y2 = line[<span class="number">0</span>]</span><br><span class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure>

<p><code>cv2.LINE_AA</code>在之前绘图功能中讲解过，表示抗锯齿线型。</p>
<p><img src="http://cos.codec.wang/cv2_hough_lines_p_function.jpg" alt="img"></p>
<h3 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h3><p>霍夫圆变换跟直线变换类似，只不过线是用(r,θ)表示，圆是用(x_center,y_center,r)来表示，从二维变成了三维，数据量变大了很多；所以一般使用霍夫梯度法减少计算量，对该算法感兴趣的同学可参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circle_Hough_Transform">Circle Hough Transform</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line"><span class="comment"># 2.霍夫圆变换</span></span><br><span class="line">circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">20</span>, param2=<span class="number">30</span>)</span><br><span class="line">circles = np.int0(np.around(circles))</span><br></pre></td></tr></table></figure>



<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h1>]]></content>
      <categories>
        <category>Python-learn</category>
        <category>Python 库</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>视觉识别</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译工具整理以及沉浸式翻译</title>
    <url>/2023/03/09/%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E4%BB%A5%E5%8F%8A%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>最近毕业设计，在弄文献翻译嘛，所以找了下合适的翻译工具，大学四年自己用过的翻译工具挺多的，整理一下吧，顺便强推下这个插件—沉浸式翻译，我只能说，无敌！</p>
<h1 id="沉浸式翻译"><a href="#沉浸式翻译" class="headerlink" title="沉浸式翻译"></a>沉浸式翻译</h1><p>本来是先介绍翻译工具再介绍这个的，但是翻译工具没啥好推的，能用DeePL就用，所以先介绍下这个。</p>
<ol>
<li>安装的话，油猴搜沉浸式翻译就行，当然Github也有项目，地址在这：<br> <a target="_blank" rel="noopener" href="https://github.com/immersive-translate/immersive-translate/">https://github.com/immersive-translate/immersive-translate/</a></li>
<li>也可以直接安装拓展，目前主流浏览器都上架了。<a target="_blank" rel="noopener" href="https://immersive-translate.owenyoung.com/installation">官方推荐安装文档</a></li>
</ol>
<span id="more"></span>

<p><img src="https://s2.loli.net/2023/03/09/1h9ZDFqnQdEtejM.png" alt="image-20230309111252328"></p>
<p>主要特性官方说的比较清楚了，这介绍下我认为它的主要优点吧，首先是翻译区域，以往类似的网页翻译都是整个界面全部翻译，而这个有双语对照，等于在不破化原文布局的情况下，给你加一篇区域，嵌入翻译结果，直接上效果图。页面中蓝色虚线下划线就是翻译结果，这个显示样式是可以设定的。</p>
<p><img src="https://s2.loli.net/2023/03/09/yjzaV695ZOcivRI.png" alt="image-20230309111725492"></p>
<p>还有一个巨大优点就是对于PDF，Epub电子书的双语翻译；两者的使用官方都给出了具体教程</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://immersive-translate.owenyoung.com/usage">PDF文件翻译</a>  PDF翻译效果很一般，至于准确性，纯看你用的是谁的翻译了，我用的DeePL.</p>
<p><img src="https://s2.loli.net/2023/03/09/F931RxenUyqrVp8.png" alt="image-20230309113852360"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://immersive-translate.owenyoung.com/usage">Epub文件翻译</a>：这里Epub网页工具我推荐这个<a target="_blank" rel="noopener" href="https://epub-reader.online/">Epub-reader</a> 如下图所示，Epub格式文档用Epub-reader打开然后加上沉浸式翻译，这不是无敌？</p>
<p><img src="https://s2.loli.net/2023/03/09/g6GOVPe8wRTa4NA.png" alt="image-20230309114042796"></p>
</li>
</ol>
<h2 id="关于拓展选用的翻译工具"><a href="#关于拓展选用的翻译工具" class="headerlink" title="关于拓展选用的翻译工具"></a>关于拓展选用的翻译工具</h2><p>目前官方提供如下这些，能直接用的有腾讯交互翻译、必应翻译还有谷歌翻译，但是正常情况下谷歌翻译是用不了的。</p>
<p><img src="https://s2.loli.net/2023/03/09/fYR7oaUpndMxmuy.png" alt="image-20230309114213971"></p>
<p>这里简单介绍下如何使用DeePL，其他的直接进官方提供文档，按照教程去弄就行。</p>
<p>选择DeePL以后，他会让你填DeePL的API然后填进去，测试以下，能用就行了。问题来了，API怎么弄呢？ 有一个东西，叫淘宝、还有一个东西，叫闲鱼；不愿花小钱就用其他的也行，都还可以，百度翻译也不差。</p>
<p><img src="https://s2.loli.net/2023/03/09/RZX26sYIdUj4w5p.png" alt="image-20230309114432026"><br><img src="https://s2.loli.net/2023/03/09/ziO7DRroI1Q2dTK.png" alt="image-20230309114516467"></p>
<h1 id="翻译工具整理（支持文档输入）"><a href="#翻译工具整理（支持文档输入）" class="headerlink" title="翻译工具整理（支持文档输入）"></a>翻译工具整理（支持文档输入）</h1><h2 id="DeePL"><a href="#DeePL" class="headerlink" title="DeePL"></a><a target="_blank" rel="noopener" href="https://www.deepl.com/translator">DeePL</a></h2><p>DeePL翻译结果的准确性还有本地化相比于其他翻译工具，毋庸置疑的更加强大，翻译TOP1的地位也得到了诸多认可。机翻很大的一个缺陷就是本地化，而DeePL在这方面做的确实十分优秀，首推的翻译工具自然是它，而且在文献一些名词方面它的翻译也比较准确。更重要的一点是，DeepL翻译应用程序是完全免费的，但是DeepL的翻译质量却远胜于竞争对手。</p>
<p><img src="https://s2.loli.net/2023/03/09/1o2FeXQMpRkAyzi.png" alt="image-20230309105331599"></p>
<p>单说我自己的体验，有图有真相，如下所示，图一是DeePL的翻译，图二是谷歌的，高下立判。<br>都是基于沉浸式翻译插件的，谷歌在这英译英呢，这里展示的DeePL需要使用API，DeePL的api下文会提到；单纯从结果来说就算是谷歌自带的全网页翻译，文献翻译方面也和粑粑一样。</p>
<p>DeePL的</p>
<img src="https://s2.loli.net/2023/03/09/N9j3krXEuFwBQCb.png" alt="image-20230309104412970"  />

<p>谷歌的</p>
<img src="https://s2.loli.net/2023/03/09/6zCBRepvnMKdLiU.png" alt="image-20230309104449254"  />



<h2 id="谷歌翻译"><a href="#谷歌翻译" class="headerlink" title="谷歌翻译"></a><a target="_blank" rel="noopener" href="https://translate.google.com/?hl=zh-CN">谷歌翻译</a></h2><p>Google 翻译支持对PDF文件进行翻译，您只需要上传PDF文件即可。但是，Google 翻译并不完美，可能会出现一些翻译错误。此外，如果PDF文件中有很多图片或格式，Google 翻译可能无法处理。虽然说谷歌翻译和DeePL存在差距，但是说句第二不过分吧，不过目前好像，emmm，用不了。</p>
<p><img src="https://s2.loli.net/2023/03/09/o7QUzJGBH9w5plv.png" alt="image-20230309105256673"></p>
<h2 id="百度翻译"><a href="#百度翻译" class="headerlink" title="百度翻译"></a><a target="_blank" rel="noopener" href="https://fanyi.baidu.com/">百度翻译</a></h2><p>这应该是平时用的最多的，质量中规中矩。</p>
<p><img src="https://s2.loli.net/2023/03/09/TmspgXPxCYyuQ6W.png" alt="image-20230309114839033"></p>
<h2 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a><a target="_blank" rel="noopener" href="https://fanyi.youdao.com/index.html">有道翻译</a></h2><p>一款在线翻译软件，同样支持多种格式文档输入，但是在翻译准确度上与前两者存在一定差距。</p>
<p><img src="https://s2.loli.net/2023/03/09/SlZ1ofLnD5FEKBJ.png" alt="image-20230309105700758"></p>
<h2 id="Doctranslate"><a href="#Doctranslate" class="headerlink" title="Doctranslate"></a><a target="_blank" rel="noopener" href="https://www.onlinedoctranslator.com/zh-CN/">Doctranslate</a></h2><p>Doctranslate支持在线整篇文档直接翻译，并且能够<strong>完整保留文档中的公式、排版和布局</strong>，对于论文中需要保留大量公式的同学来说十分不错。同时，整个翻译都是免费的，但是翻译质量相对于谷歌和DeePL当然存在差距。</p>
<p><img src="https://s2.loli.net/2023/03/09/ijh2vs3gXocQDOH.png" alt="image-20230309110133647"></p>
<h2 id="CNKI翻译助手"><a href="#CNKI翻译助手" class="headerlink" title="CNKI翻译助手"></a><a target="_blank" rel="noopener" href="https://dict.cnki.net/index">CNKI翻译助手</a></h2><p>这不能用来作为主流翻译软件，只能用来作为辅助工具，主要翻译文献里面的名词啥的，网页主页如下，可以自己看看</p>
<p><img src="https://s2.loli.net/2023/03/09/OJbAQxMHv7WgwF6.png" alt="image-20230309111003378"></p>
<h2 id="其他翻译工具"><a href="#其他翻译工具" class="headerlink" title="其他翻译工具"></a>其他翻译工具</h2><p>其实推荐用的只有DeePL还有谷歌，然后谷歌用不了，等于只推荐DeePL，其他的都放这了，仁者见仁，智者见智。</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="http://www.iciba.com/">金山词霸</a>：同样支持文档翻译，但是他自己说文档翻译结果只做参考。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://fanyi.caiyunapp.com/#/">彩云小译</a>：也是在线翻译，同样支持文档翻译<br><img src="https://s2.loli.net/2023/03/09/eX7kjgvQ16zhDKC.png" alt="image-20230309110537954"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://jianwai.youdao.com/">网易见外工作台</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>浏览器插件</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机的启动---操作系统的引导</title>
    <url>/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/</url>
    <content><![CDATA[<p>学408当时听课时，这里讲的基本就是说BIOS引导什么的，属实不是很清楚，索性找了几个详解的文章学习了下，梳理了大体流程，这里简单概括下。</p>
<p>首先简要过一遍流程：按下开机按钮上电—主板上写死的固件(硬件电路)运行—CPU将所有寄存器的值都设为默认值—CPU指向BIOS(在主板ROM中的固定位置)–BIOS程序进行硬件检测和初始化操作—搜索启动盘—（读取 MBR）将启动盘中的 0 盘 0 道 1 扇区的 512 个字节原封不动的写入(拷贝)内存中<code>0x7c00</code>开始的位置—确定活动分区—确定引导扇区，将其加载到内存中—操作系统加载。</p>
<span id="more"></span>

<h1 id="按下开关-不重要"><a href="#按下开关-不重要" class="headerlink" title="按下开关(不重要)"></a>按下开关(不重要)</h1><ol>
<li><p>CPU会执行一个复位（Reset）过程：CPU内置有一个复位电路，该电路会向CPU的所有寄存器发送一个特殊的复位信号，以重置所有寄存器。</p>
</li>
<li><p>CPU将所有寄存器的值都设为默认值</p>
<ul>
<li><p>PC 寄存器被强制初始化为 0xFFFF0 ，这也是BIOS程序的入口地址。</p>
<ul>
<li>段基址寄存器 cs 初始化为 0xF000</li>
<li>偏移地址寄存器 IP 初始化为 0xFFF0</li>
<li>根据实模式下的最终地址计算规则，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。</li>
</ul>
</li>
<li><p>复位信号会将通用寄存器AX、BX、CX、DX等以及其他寄存器如标志寄存器FLAGS、指令指针寄存器IP等重置为默认值。默认值通常是0或者一些固定的值，具体取决于CPU架构和制造商。</p>
</li>
</ul>
</li>
<li><p>其他…</p>
</li>
</ol>
<h1 id="启动BIOS"><a href="#启动BIOS" class="headerlink" title="启动BIOS"></a>启动BIOS</h1><ol>
<li>BIOS上电自检POST（Power-On Self Test）</li>
<li>初始化硬件设备</li>
<li>按照顺序搜索启动设备</li>
<li>BIOS在启动时会按照一定的顺序搜索可用的启动设备，通常包括硬盘、CD&#x2F;DVD光驱、USB闪存驱动器等。这个顺序可以通过BIOS设置进行配置，并被称为“启动顺序”或“启动顺序”。</li>
</ol>
<h1 id="BIOS加载启动区"><a href="#BIOS加载启动区" class="headerlink" title="BIOS加载启动区"></a>BIOS加载启动区</h1><ol>
<li>BIOS 会按照设备顺序，读取主引导记录MBR，即读取0 盘 0 道 1 扇区的内容，如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区。<ul>
<li>MBR（Master Boot Record，主引导记录，大小为 512 字节）<ul>
<li>第1-446 字节：包含了引导程序的代码，即调用操作系统的机器码，可以被 CPU 直接执行。</li>
<li>第 447-510 字节：分区表（Partition Table）信息，将硬盘分为了若干个分区。<ul>
<li>分区表（Partition Table）记录了硬盘上的所有分区信息，包括每个分区的起始位置、大小和分区类型等。</li>
</ul>
</li>
<li>第 511-512 字节：“MBR结束标志”（MBR End of Sector Marker），记录签名（0x55 和 0xAA），若记录签名正确，表示设备可以用于启动—也就是说这个区是启动区。</li>
</ul>
</li>
</ul>
</li>
<li>如果计算机确定了当前盘的MBR是启动区，那么BIOS会将硬盘中启动区的 512 字节的数据，原封不动复制到内存中的 0x7c00处<ul>
<li><img src="https://s2.loli.net/2023/04/09/OHZa8d5YL4SPR32.png" alt="BIOS将启动区复制进内存中">{:height 717, :width 663}</li>
</ul>
</li>
</ol>
<h1 id="查找活动分区（引导分区）"><a href="#查找活动分区（引导分区）" class="headerlink" title="查找活动分区（引导分区）"></a>查找活动分区（引导分区）</h1><ol>
<li>PC寄存器的值变为0x7c00，从这里开始运行—启动区开始跑起来！</li>
<li>当BIOS将MBR加载到内存中后，它会读取分区表中的<strong>活动分区</strong>标识位。若分区表中的活动分区标识位被设置为1，则表示该分区是可引导的。<ul>
<li>分区表记录了磁盘上所有分区的位置、类型和大小等信息，在分区表中，有一个标识位被称为<strong>“活动分区”（Active Partition）</strong>，一般为某个主分区，也就是至多四个主分区之一。此标识位指示了系统应该从哪个分区引导操作系统</li>
<li><strong>每个硬盘最多只能有一个活动分区。</strong>如果硬盘上存在多个操作系统，那么每个操作系统都需要独立的活动分区来引导启动。</li>
</ul>
</li>
<li>BIOS会跳转到该分区上的的<strong>引导扇区（Boot Sector）</strong>上，并将其加载到内存中执行。<ul>
<li>引导扇区是一个特定的扇区，通常包含了操作系统引导程序的代码和数据，例如Windows操作系统的<code>bootmgr</code>或<code>grub</code>引导程序。</li>
</ul>
</li>
</ol>
<h1 id="操作系统加载（不重要）"><a href="#操作系统加载（不重要）" class="headerlink" title="操作系统加载（不重要）"></a>操作系统加载（不重要）</h1><ol>
<li>一旦引导扇区（Boot Sector）被加载到内存中执行，它会继续加载操作系统的其他部分。通常，这涉及到在文件系统中查找操作系统的核心文件，并将其加载到内存中。在 Windows 操作系统中，这个核心文件可能是 ntoskrnl.exe，而在 Linux 操作系统中，它可能是 vmlinuz。</li>
<li>操作系统的核心文件被加载到内存后，它就开始初始化操作系统，包括创建进程、分配内存等。</li>
<li>接下来，操作系统会开始运行第一个进程，这通常是 init 进程或 systemd 进程，它负责启动其他进程和服务。最终，操作系统完成了启动过程，并准备好接受用户的交互请求。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>ChatCPT回答</li>
<li>九曲阑干计算机操作系统课程</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247499226&idx=1&sn=1ff3d54a3608423b7781142ae3ac62ca&chksm=c2c58777f5b20e61664a51d31ab779bbe68c317c3459218c7cd4b9530887dbb33470628c3248&cur_album_id=2123743679373688834&scene=178&subscene=10000&sessionid=0&clicktime=1680866166&enterid=1680866166&ascene=3&fasttmpl_type=0&fasttmpl_fullversion=6624157-zh_CN-zip&fasttmpl_flag=0&realreporttime=1680866396392&devicetype=android-31&version=280021bd&nettype=ctnet&abtest_cookie=AAACAA==&lang=zh_CN&countrycode=CN&exportkey=n_ChQIAhIQCyZc6Yv5z6dy2QVteNwcHxLcAQIE97dBBAEAAAAAAPtNGgF0q1cAAAAOpnltbLcz9gKNyK89dVj0Du2uiGcJqb8sHF7c2U2ij/b1CFiEhbUp8mVvdOz/xIs2zDIQ3brTKgtycIfKAkKlayYbYQMBIm6WXwMsU2L7z+gh0Kfqyfyf+rEaNY9K/7gtjEP5eq5M93ABeVZJmYqG08bUj9g+0287IQOcBKnZnzQ4iUP1RaJZXZheVCyPIqgmZeigDneK3E5XhMUWbZbA/5Zc4KLf0VInmzJH9Lda0S7JqVbaIqnK3m9EjszFaU6l04m3u1Y=&pass_ticket=XcWSJctQOhG8pwa0eQOrUbdf8Ys1LQVUfhi198uiWp2rQ4FPIsYikPGtEdpQog1oXhFbKZFsjygJG7S+63Fzxw==&wx_header=3">你管这破玩意叫操作系统源码 | 第一回 最开始的两行代码</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247483867&idx=1&sn=76ece31324d32922a7cb9db129decd3f&chksm=c2c67b76f5b1f260bb459e12c029f8e6a7a813055811ab8ed794a3f36d0d7d50e66df27f4f0a&scene=21#wechat_redirect">全网最硬核讲解计算机的启动过程</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>关于开源软件与我的分享目的</title>
    <url>/2023/04/21/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E4%B8%8E%E6%88%91%E7%9A%84%E5%88%86%E4%BA%AB%E7%9B%AE%E7%9A%84/</url>
    <content><![CDATA[<p>开源软件还有一个名字，叫自由软件，与之相对于有一类软件叫闭源软件，比如我们常用的QQ，微信等。接下来接简单介绍下两者的区别</p>
<ul>
<li><p>开源软件—open source software顾名思义就是开放软件源代码的软件，这意味着任何人都可以修改软件的源代码。相当于一个工具，大家可以在初代的基础上对其进行修改，并重新发布软件。这也是为什么其被称作自由软件。至于重新发布甚至商业化这里涉及到不同开源协议的要求不同，便不赘述，可自行了解。</p>
</li>
<li><p>闭源软件则与其正好相反，其源代码是私有的，只能被制造商或授权用户查看和修改。因此，普通用户无法访问、修改或重新分发该软件的源代码。闭源软件常见于需要保护隐私或者需要用于盈利的软件。</p>
</li>
</ul>
<span id="more"></span>

<p>综上开源软件的好处便很明显了，不知道你们用闭源软件的时候有没有这种担忧，就是你资源全放一个篮子里了，哪天平台跑路了我不是啥也没了，这也是我为什么要买大硬盘存资源的原因，网盘固然好，但解决不了我的忧虑，更不用说国内目前国内两大网盘—阿里和百度都是和谐高手。这里的和谐涉及范围很广，比如我阿里大部分wlop的壁纸都寄了，周杰伦的歌也是。</p>
<p>~嘶，跑题了</p>
<p>从上面来说，开源软件的第一个特点就是稳，创始人不更了没事，最坏也就是没人维护了，甚至社区还有人在继续维护，那更不用担心。</p>
<p>另外一个关键点便是开源软件，极少有后门，当然，这里要排除那些拿别人的开源软件，塞了点东西，然后买给你的那种，很少，但确实存在。正常情况，一个源代码公开的软件，塞后门…emm</p>
<p>其他的杂七杂八好处，太多了，反正现在我纯纯开源拥护者，虽然目前能力止步于使用者，但是希望成为一名开源者。真是屑啊</p>
<h1 id="正文？"><a href="#正文？" class="headerlink" title="正文？"></a>正文？</h1><p>接下来会慢慢介绍一些自己目前正在使用，或者以前使用过的优秀开源工具，注意是开源工具哦，上手用的那种。</p>
<p>简单介绍几个贼爽的，bilix、Codesker、pot、snipaste…</p>
]]></content>
      <categories>
        <category>开源软件</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>开源软件</tag>
      </tags>
  </entry>
  <entry>
    <title>关于书签与书签同步工具的分享</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8E%E4%B9%A6%E7%AD%BE%E4%B8%8E%E4%B9%A6%E7%AD%BE%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>Bookmark and sync</p>
<p>纯share blog</p>
<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><h2 id="为什么需要书签"><a href="#为什么需要书签" class="headerlink" title="为什么需要书签"></a>为什么需要书签</h2><p>书签相信大家都不陌生，尤其是对于像我这样高强度冲浪的人来说，书签绝对是必不可少的，互联网花花世界这么大，碰到感兴趣的要是不收藏起来，之后想找无异于大海捞针。</p>
<h2 id="为什么需要BookmarkHub"><a href="#为什么需要BookmarkHub" class="headerlink" title="为什么需要BookmarkHub"></a>为什么需要BookmarkHub</h2><p>Hub在计算机里是集线器的意思，这里BookmarkHub可理解为书签库，这也是接下来我介绍的插件名。</p>
<p>我起初在网络上闲逛时经常用书签把自己感兴趣的东西加入书签栏，久而久之，书签的数量也就与日俱增，各种各样的书签迷人眼。有意思的视频网站、强大的工具网站、感兴趣的文章、常用的学校官网等等等。数量不断增加，种类也是，这时在书签中找记忆中似是而非的网站本身就成为了一个问题。</p>
<span id="more"></span>

<p>当然大多数浏览器或者软件都提供了在书签栏&#x2F;收藏夹中创建文件夹的功能。我们可以网页或者工具的作用或者内容给他分类。但是！这里有俩个情况：</p>
<ul>
<li>我浏览器不止一个Chrome常用于学习或者看CS相关的内容，Firefox则覆盖我生活中方法面面使用浏览器的情况，于此同时我手机用的浏览器也不止一个，夸克、Chrome。至于为什么不能<code>all in one</code>，我的回答是有时候单一的浏览器不能解决所有问题，不得不<code>all in all</code>。那么不同设备&#x2F;浏览器之间的书签便时不一致的，找东西的时候难不成还把所有设备过一遍？太low啦！！</li>
<li>书签栏分类等同于给书签打上了标签，以后找相关的就在这里面找，但是问题来了，并不是所有网站都是单一的，他可能与图片相关因此我将它放在了Photo文件夹，但其实际是一个处理图片的工具。那么我也可以将其放在工具集文件夹中…，怎么办呢？不好找啊。<br><img src="https://s2.loli.net/2023/04/23/OgUR1VsxPYhIQeq.png" alt="image-20230423123944435"></li>
</ul>
<h1 id="怎么办—介绍几个正在用或者用过的工具"><a href="#怎么办—介绍几个正在用或者用过的工具" class="headerlink" title="怎么办—介绍几个正在用或者用过的工具"></a>怎么办—介绍几个正在用或者用过的工具</h1><p>为了解决上述问题，我也找了挺多软件和插件。找到两个非常优秀的开源项目，真的非常nice！！！</p>
<h2 id="BookmarkHub"><a href="#BookmarkHub" class="headerlink" title="BookmarkHub"></a>BookmarkHub</h2><p><a target="_blank" rel="noopener" href="https://github.com/dudor/BookmarkHub">项目地址</a></p>
<p>项目有中文介绍教程，<a target="_blank" rel="noopener" href="https://github.com/dudor/BookmarkHub/blob/main/README_cn.md">教程网址</a></p>
<p>这是一个浏览器插件，目前支持Chrome、Firefox、edge等浏览器<img src="https://s2.loli.net/2023/04/23/GSIfvU8TtqxbWyw.png" alt="image-20230423125026448"></p>
<ul>
<li>简洁，操作及其方便</li>
<li>主打一个各浏览器书签同步其他么得，功能单一但有效</li>
<li>使用 GitHub 的 Gist 记录来存储浏览器的书签—有GitHub账户就行，教程会教你弄，保密性挺好很安全。</li>
</ul>
<p>使用方法（我直接照抄官方文档的，就加了点图）</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/login">登陆</a> GitHub，如果没有账号请点此<a target="_blank" rel="noopener" href="https://github.com/join">注册</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/settings/tokens/new">创建一个可以管理 gist 的 token</a>。</p>
<p>这里Note填BookmarkHub就行，下面token重置时间看你自己了，然后去最下面点创建</p>
<p><img src="https://s2.loli.net/2023/04/23/olWB8m1kUqhsMrZ.png" alt="image-20230423125247278"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://gist.github.com/">创建一个私有的 gist</a>。<strong>注意：如果是公开的 gist，你的书签是可以被他人搜索到的。</strong></p>
<p><img src="https://s2.loli.net/2023/04/23/i8hNzVIGlRCZnr6.png" alt="image-20230423125444413"></p>
</li>
<li><p>在你用的浏览器的应用商店下载 BookmarkHub，点击插件的设置按钮，在弹出的设置窗口填入 token 和 gist ID，然后你就可以上传下载书签了。</p>
<ul>
<li><p>这个token点设置里面的get token去弄就行。</p>
</li>
<li><p>gist ID 就是你在上一步创建的时候，网址框最后那一串<img src="C:\knowledge\blog\BLOG\source_posts\assets\image-20230423125925463.png" alt="image-20230423125925463"></p>
</li>
</ul>
</li>
</ol>
<h3 id="BookmarkHub如何解决第二个问题"><a href="#BookmarkHub如何解决第二个问题" class="headerlink" title="BookmarkHub如何解决第二个问题"></a>BookmarkHub如何解决第二个问题</h3><p>从上面功能描述来看，只可以解决第一个问题，第二个怎么办呢？</p>
<p>hhhh，软件没办法，但是可以从书签入手。火狐提供了书签描述、Chrome的话就只可以在书签名字做手脚，在名字后面加功能描述或者书签就行。在搜索框搜索就可以检索出来。</p>
<h2 id="xBrowserSync—同时解决两个问题"><a href="#xBrowserSync—同时解决两个问题" class="headerlink" title="xBrowserSync—同时解决两个问题"></a>xBrowserSync—同时解决两个问题</h2><p><a target="_blank" rel="noopener" href="https://www.xbrowsersync.org/">官方网站</a></p>
<p>emmm，说在前面，使用和介绍全是纯英文的。</p>
<ul>
<li><p>支持浏览器书签同步(插件)、手机同样可以通过app进行同步</p>
<img src="https://s2.loli.net/2023/04/23/N1me7OTgfBiYZ3d.png" alt="image-20230423130406192" style="zoom:50%;" />
</li>
<li><p>保护隐私安全—完全匿名、不用注册</p>
</li>
<li><p>不仅可以同步，还可以<strong>添加描述和标签来丰富你的本地浏览器书签</strong>，所有可以直接解决第二个问题</p>
</li>
</ul>
<p>相比于上一个，功能更强大了，但是安装和使用可能没那么简单，具体的装上用就是，上手即用。具体看其提供的Guide</p>
<ol>
<li><p>浏览器安装，然后设置密码</p>
<p><img src="https://s2.loli.net/2023/04/23/JNu5C3sTmL6njIS.png" alt="image-20230423132118064"></p>
</li>
<li><p>然后点sync，就ok啦，后面的就是日常使用了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>开源软件</category>
      </categories>
      <tags>
        <tag>开源软件</tag>
        <tag>工具</tag>
        <tag>书签</tag>
      </tags>
  </entry>
  <entry>
    <title>看万里归途时我在想什么？</title>
    <url>/2023/06/12/%E7%9C%8B%E4%B8%87%E9%87%8C%E5%BD%92%E9%80%94%E6%97%B6%E6%88%91%E5%9C%A8%E6%83%B3%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>刚看完万里归途，趁着感触还在，写点东西。</p>
<p>emmm，之前看过类似的战狼。但二者还是有很大不同的，相比于战狼的吴京个人花式秀，我其实更觉得张译这种“赌”，更加贴合实际也更让人满怀敬意，更像一个有血有肉有信念的人。</p>
<span id="more"></span>

<p>在战乱中，在枪械下，个人的力量显得如此不堪一击，也许一颗飞溅的子弹便会让人生戛然而止。但两次放弃撤侨，一次描写渺渺，一笔带过将位置让给了台湾同胞。第二次则前后脉络清晰，嘴硬的宗大伟看着最好的伙伴章宁死在眼前，有一次“没座位”回来找白婳。此前与边境官哈桑就华人出境的拉扯将张译身为一个外交官的能力与水平体现的淋漓尽致。</p>
<p>此后寻白婳，并带领125号人前往迪拉特的情节才是电影的主线，也是宗大伟身为外交官死里求生的一次次豪赌。</p>
<p>死里逃生找到白婳，结果需要带走的人远不是预想的七八个，而是从未预想的百来人。在交战区带出百来人，而且失去与大使馆联系，宗大伟选择了赌，与其坐以待毙等着轰炸机淹没不如死里求生赌，徒步前往迪拉特赌救援。</p>
<p>中途自以为是且初出茅庐的成朗与自作聪明的刘明辉，再次将宗大伟拉上了赌桌。在ak枪口下，宗大伟与叛军首领再次豪赌，赌他不敢杀他这个外交官。赌来了一次俄罗斯转盘，最终以司机瓦迪尔的死亡结尾。从最终结局的戏剧性来看，宗大伟输给了勇气，但我以为这是再正常不过的人之常情，若救了，反倒显得有些圣母。</p>
<p>最后一次豪赌，仍然是俄罗斯转盘，只不过这次赌注换成了章宁的女儿法提玛。所有三次颤抖的手扣动扳机，换来叛军首领的无地自容与不可置信。随后成朗与其对赌，赌其不敢在摄像头下开枪，更无可能杀了所有人。</p>
<p>是的，就现实而言，在枪械下，普通人能做的，便是靠脑子和勇气去赌那一线生机，抓住了方可得活。若对方是个轴军官，一枪下去，一切皆休。所幸，蠢货也当不上叛军首领，也当不上边境官。</p>
<p>问题来了，对方的赌注是宗大伟等人的生命，宗大伟的赌注呢？是国家给予的底气！就像第三次豪赌时，他掏出护照告诉叛军首领，血债血偿！</p>
<p>最后重逢的画面真的很美，以年味，以市井气息，将人从战乱拉回了这个国泰民安的国家，这个撤离时高呼的“家”。</p>
<p><img src="https://s2.loli.net/2023/06/12/gZAdXoV2fbm9uaC.png" alt="image-20230612141651615"></p>
<p><img src="https://s2.loli.net/2023/06/12/VwplJhc4mkM3RI2.png" alt="image-20230612141659194"></p>
]]></content>
      <tags>
        <tag>生活杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用Socket获取IP地址---顺便初学Socket</title>
    <url>/2023/07/26/python%E4%BD%BF%E7%94%A8Socket%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80-%E9%A1%BA%E4%BE%BF%E5%88%9D%E5%AD%A6Socket-md/</url>
    <content><![CDATA[<p>偶然看的一个使用Socket获取本机IP的方式，感觉还挺有意思的，于是便有了这篇Blog，同时通过这个简单的项目，初步了解下在网络通信里面经常看的的Socket。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_host_ip</span>():</span><br><span class="line">    ip = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">with</span> closing(socket.socket(socket.AF_INET,socket.SOCK_STREAM)) <span class="keyword">as</span> _socket:</span><br><span class="line">        _socket.connect((<span class="string">&#x27;1.1.1.1&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">        ip = _socket.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(ip) <span class="comment"># 192.168.1.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_host_ip()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>从代码可以看出核心是socket模块，无论是<code>connect</code>还是<code>getsockname</code>都是其中的方法。因此我们最好可以先简单学习一下—Socket(套接字)</p>
</li>
<li><p>在学习过程中，有这样一个概念—当你使用<code>connect()</code>方法将<strong>套接字连接到远程主机时，套接字对象的本地<code>IP</code>地址是由操作系统自动分配的。操作系统通常会使用本机上的一个可用IP地址作为套接字对象的本地<code>IP</code>地址，这个<code>IP</code>地址通常是本机的一个局域网<code>IP</code>地址或公网<code>IP</code>地址，取决于本机与远程主机之间的网络环境。</strong></p>
</li>
<li><p>同时，再看<code>getsockname</code>方法的作用—用于获取套接字的本地地址和端口号。它返回一个元组，包含套接字绑定的本地地址和端口号。这个本地地址可以用于告诉其他套接字如何连接到它。</p>
</li>
<li><p>这样一来，上面代码的作用就知道了，先创建一个<code>Socket</code>对象<code>_socket</code>，随后将其与<code>(&#39;1.1.1.1&#39;, 80)</code>建立连接，客户端发送的是一个 TCP 连接请求。这里的80指的是端口号，一般是对于Web服务的端口—<strong>在使用网络编程时，便于正确地指定端口号，因此需要对其有一定的了解</strong>，比如DNS使用的53端口。</p>
</li>
<li><p>然后我可以通过<code>_socket.getsockname()</code>，获取操作系统自动给套接字分配的<code>ip</code>地址，通常是本机的一个局域网<code>IP</code>地址或公网<code>IP</code>地址。</p>
</li>
</ul>
<blockquote>
<p>可以注意到，在上面代码中使用的with语句与我们平时见到的不一样，它后面还使用了contextlib.closing()方法，这是为什么呢？</p>
<p> contextlib.closing() <strong>方法可以将一个对象封装成上下文管理器</strong>，使其在使用完毕后自动关闭。而<strong>with 语句是一种上下文管理器</strong>，可以自动管理资源的生命周期，一旦代码块执行完毕，无论是否发生异常，with语句会自动调用资源的__exit__()方法来关闭资源。</p>
<p>并不是所有的资源都是上下文管理器，也就是说，<strong>并不是所有的资源都可以直接使用with语句来关闭</strong>。这时就**可以使用contextlib.closing()方法来将资源包装成上下文管理器，以便能够在with语句中使用</p>
</blockquote>
<p>python官方关于socket的介绍可以看<a href="https://link.zhihu.com/?target=http://docs.python.org/library/socket.html">这里</a></p>
<p>后续，基于上面所使用到的内容，初步学习一下。</p>
<span id="more"></span>

<h1 id="with语句结合contextlib-closing"><a href="#with语句结合contextlib-closing" class="headerlink" title="with语句结合contextlib.closing"></a><code>with</code>语句结合<code>contextlib.closing</code></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `contextlib.closing(xxx)`的原理如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">closing</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Context to automatically close something at the end of a block.</span></span><br><span class="line"><span class="string">    Code like this:</span></span><br><span class="line"><span class="string">        with closing(&lt;module&gt;.open(&lt;arguments&gt;)) as f:</span></span><br><span class="line"><span class="string">            &lt;block&gt;</span></span><br><span class="line"><span class="string">    is equivalent to this:</span></span><br><span class="line"><span class="string">        f = &lt;module&gt;.open(&lt;arguments&gt;)</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            &lt;block&gt;</span></span><br><span class="line"><span class="string">        finally:</span></span><br><span class="line"><span class="string">            f.close()</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, thing</span>):</span><br><span class="line">        self.thing = thing</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.thing</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, *exc_info</span>):</span><br><span class="line">        self.thing.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>closing</code> 类包含了一个构造方法和两个特殊方法：<code>__enter__</code> 和 <code>__exit__</code>。<code>__init__</code> 方法用于初始化 <code>closing</code> 对象，接受一个参数 <code>thing</code>，表示需要关闭的对象。</li>
<li><code>__enter__</code> 方法返回 <code>thing</code>，即需要关闭的对象，表示进入 <code>with</code> 语句块时要执行的操作。</li>
<li><code>__exit__</code> 方法在 <code>with</code> 语句块执行完毕后被调用，表示退出 <code>with</code> 语句块时要执行的操作。在 <code>__exit__</code> 方法中，调用 <code>thing.close()</code> 方法可以关闭 <code>thing</code> 对象，释放占用的资源。</li>
<li>使用 <code>closing</code> 结合<code>with</code>可以将代码从繁琐的 <code>try/finall</code>y 代码块中解放出来.</li>
</ul>
<h1 id="到底什么是socket？"><a href="#到底什么是socket？" class="headerlink" title="到底什么是socket？"></a>到底什么是socket？</h1><p><strong>Socket是一个抽象层，它提供了一种通用的接口，让应用程序可以使用不同的协议进行网络通信。</strong></p>
<p>我们先看wiki对socket的描述，这可能需要对于计算机网络有一个初步认识 — <strong>socket是一种操作系统提供的进程间通信机制</strong></p>
<blockquote>
<p>网络套接字（英语：Network socket；又译网络套接字、网络接口、网络插槽）在计算机科学中是电脑网络中进程间资料流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。 </p>
<p>socket是一种操作系统提供的进程间通信机制。</p>
<p>  在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行资料交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。 </p>
<p>  在套接字接口中，以IP地址及端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连线后，再加上使用的协议（protocol），这个五元组（fiveelement tuple），作为套接字对（socket pairs），之后就可以彼此交换资料。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将资料送达特定的进程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。 </p>
</blockquote>
<p>​     </p>
<p>是不是看完有点迷糊？我们形象的理解下。</p>
<blockquote>
<p>想象一下你和你的朋友们在玩一个网络游戏，你们需要在游戏中进行实时的聊天和数据交换。这时，每个人的电脑就像是一个节点，而节点之间的数据交换需要通过网络进行。  </p>
<p> 为了实现这个数据交换，每个电脑上的游戏程序需要使用套接字接口来创建一个socket。这个socket会有一个唯一的IP地址和端口号，表示这个socket的地址。在这个游戏中，每个玩家都需要创建一个socket，使得他们能够相互交换数据。</p>
<p>当你发送一条消息给你的朋友时，你的游戏程序会将这条消息写入你创建的socket中，然后通过网络将这条消息发送给你的朋友的电脑。当你的朋友的电脑接收到这条消息时，他的游戏程序会从他创建的socket中读取这条消息，并且在游戏中显示出来。</p>
<p>  这里的socket就像是一个管道，连接了两个电脑上的游戏程序，使得它们能够在网络中相互交换数据。而socket地址就像是这个管道的两端，每个电脑上的游戏程序都需要知道自己的socket地址和对方的socket地址，才能够建立起通信连接。</p>
<p>而在上面的例子中，我与朋友在实际应用中就对应着客户端与服务端，而socket地址由ip地址与端口组成，它处理的是进程之间的通信。</p>
</blockquote>
<h1 id="简单使用socket"><a href="#简单使用socket" class="headerlink" title="简单使用socket"></a>简单使用socket</h1><h2 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h2><p>在使用socket之前我们需要使用socket提供的<code>socket()</code>方法创建一个Socket。例如，以下代码创建一个TCP套接字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   </span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Socket Created&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>socket.AF_INET</code>是一个常量，表示使用IPV4协议族的套接字。用于指定套接字使用IPv4地址和端口号。</li>
<li><code>SOCK_STREAM</code>表示使用TCP协议进行通讯。如果这里是<code>SOCK_DGRAM</code>则表示使用UDP协议进行通信，创建的也是UDP套接字</li>
</ul>
<p>错误处理，当<code>socket.socket()</code>函数执行失败时，会抛出一个<code>socket.error</code>异常，异常的内容就是一个元组，包含两个值，第一个值是一个错误码(error code)，第二个值是一个错误信息(error message)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error, msg:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Failed to create socket. Error code: &#x27;</span> + <span class="built_in">str</span>(msg[<span class="number">0</span>]) + <span class="string">&#x27; , Error message : &#x27;</span> + msg[<span class="number">1</span>]</span><br><span class="line">    sys.exit();</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Socket Created&#x27;</span></span><br></pre></td></tr></table></figure>





<h2 id="客户端Socket操作"><a href="#客户端Socket操作" class="headerlink" title="客户端Socket操作"></a>客户端Socket操作</h2><p>在客户端，需要创建一个套接字，并指定服务器的地址和端口来连接到服务器。</p>
<h3 id="获取远程主机IP地址"><a href="#获取远程主机IP地址" class="headerlink" title="获取远程主机IP地址"></a>获取远程主机IP地址</h3><p>在连接到服务器之前，客户端需要获取服务器的IP地址。</p>
<p>可以使用<code>socket.gethostbyname()</code>函数来获取远程主机的IP地址，如下所示：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line">  sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.google.net&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  remote_ip = socket.gethostbyname( host )</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> socket.gaierror:</span><br><span class="line">  <span class="comment">#could not resolve</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hostname could not be resolved. Exiting&#x27;</span>)</span><br><span class="line">  sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;Ip address of &#x27;</span> + host + <span class="string">&#x27; is &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Socket Created</span></span><br><span class="line"><span class="comment"># Ip address of www.baidu.com is 36.152.44.96</span></span><br></pre></td></tr></table></figure>

<p><code>gethostbyname()</code>方法是用于将主机名解析为IP地址。它接受一个主机名作为参数，并返回该主机名对应的IP地址。这个IP地址可以用于创建套接字，以便连接到远程服务器或绑定到本地地址。</p>
<h3 id="连接到服务器"><a href="#连接到服务器" class="headerlink" title="连接到服务器"></a>连接到服务器</h3><ul>
<li><p>首先，客户端需要连接到服务器，以建立网络连接。</p>
</li>
<li><p>在建立连接前，需要知道服务器的IP地址和端口号。</p>
</li>
<li><p>客户端可以使用<code>socket.connect()</code>函数来连接服务器。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">remote_ip = socket.gethostbyname( host )</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> socket.gaierror:</span><br><span class="line"><span class="comment">#could not resolve</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hostname could not be resolved. Exiting&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;Ip address of &#x27;</span> + host + <span class="string">&#x27; is &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Connect to remote server</span></span><br><span class="line">s.connect((remote_ip , port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Connected to &#x27;</span> + host + <span class="string">&#x27; on ip &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Socket Created</span></span><br><span class="line"><span class="comment"># Ip address of www.baidu.com is 36.152.44.96</span></span><br><span class="line"><span class="comment"># Socket Connected to www.baidu.com on ip 36.152.44.96</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意，<code>connect()</code>方法需要传入一个元组<code>(host, port)</code>，其中<code>host</code>是服务器的IP地址，<code>port</code>是服务器的端口号。</li>
<li><code>connect()</code>方法是<code>socket</code>模块中用于创建TCP连接的方法之一。它的作用是连接到一个远程服务器并与之建立TCP连接。</li>
</ul>
<h3 id="向服务器端发送数据"><a href="#向服务器端发送数据" class="headerlink" title="向服务器端发送数据"></a>向服务器端发送数据</h3><ul>
<li>连接成功后，客户端可以向服务器发送数据。</li>
<li>可以使用<code>socket.send()</code>函数来发送数据，如下所示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">remote_ip = socket.gethostbyname( host )</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> socket.gaierror:</span><br><span class="line"><span class="comment">#could not resolve</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hostname could not be resolved. Exiting&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;Ip address of &#x27;</span> + host + <span class="string">&#x27; is &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Connect to remote server</span></span><br><span class="line">s.connect((remote_ip , port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Connected to &#x27;</span> + host + <span class="string">&#x27; on ip &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send some data to remote server</span></span><br><span class="line">message = <span class="string">&quot;&#x27;GET / HTTP/1.1\r\nHost: baidu.com\r\n\r\n&#x27;&quot;</span></span><br><span class="line">message =  message.encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#Set the whole string</span></span><br><span class="line">s.send(message)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line"><span class="comment">#Send failed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Send failed&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Message send successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，客户端连接到了baidu的端口号80，并使用<code>send()</code>方法向服务器发送了一个消息，消息内容是<code>Hello, server!</code>。</li>
<li>需要注意的是，如果使用的是python3，如果不加message &#x3D;  message.encode()将str转换为byte，可能会出现报错<code>TypeError: a byteslike object is required, not ‘str’</code></li>
<li>这是因为Python3中，str 类型和 unicode 类型是同一种类型。Python2中，str 类型和 bytes 类型是同一种类型。</li>
</ul>
<h3 id="从服务器端接收数据"><a href="#从服务器端接收数据" class="headerlink" title="从服务器端接收数据"></a>从服务器端接收数据</h3><p>客户端可以使用<code>socket.recv()</code>函数从服务器端接收数据，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">remote_ip = socket.gethostbyname( host )</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> socket.gaierror:</span><br><span class="line"><span class="comment">#could not resolve</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hostname could not be resolved. Exiting&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;Ip address of &#x27;</span> + host + <span class="string">&#x27; is &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Connect to remote server</span></span><br><span class="line">s.connect((remote_ip , port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Connected to &#x27;</span> + host + <span class="string">&#x27; on ip &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send some data to remote server</span></span><br><span class="line">message = <span class="string">&quot;&#x27;GET / HTTP/1.1\r\nHost: baidu.com\r\n\r\n&#x27;&quot;</span></span><br><span class="line">message =  message.encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#Set the whole string</span></span><br><span class="line">s.send(message)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line"><span class="comment">#Send failed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Send failed&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Message send successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Now receive data</span></span><br><span class="line">reply = s.recv(<span class="number">4096</span>)</span><br><span class="line">re_list = reply.split(<span class="string">&#x27;\r\n&#x27;</span>.encode())</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> re_list:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Socket Created</span></span><br><span class="line"><span class="string">Ip address of www.baidu.com is 36.152.44.95</span></span><br><span class="line"><span class="string">Socket Connected to www.baidu.com on ip 36.152.44.95</span></span><br><span class="line"><span class="string">Message send successfully</span></span><br><span class="line"><span class="string">b&#x27;HTTP/1.1 302 Found&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Bdpagetype: 3&#x27;</span></span><br><span class="line"><span class="string">b&#x27;ContentLength: 154&#x27;</span></span><br><span class="line"><span class="string">b&quot;ContentSecurityPolicy: frameancestors &#x27;self&#x27; https://chat.baidu.com http://mirrorchat.baidu.com https://fjchat.baidu.com https://hbachat.baidu.com https://hbechat.baidu.com https://njjschat.baidu.com https://njchat.baidu.com https://hnachat.baidu.com https://hnbchat.baidu.com http://debug.baiduint.com;&quot;</span></span><br><span class="line"><span class="string">b&#x27;ContentType: text/html&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Date: Sun, 23 Jul 2023 15:09:34 GMT&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Location: https://www.baidu.com/search/error.html&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Server: BWS/1.1&#x27;</span></span><br><span class="line"><span class="string">b&#x27;SetCookie: BDSVRTM=0; path=/&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Traceid: 1690124974056851201016077367759043291635&#x27;</span></span><br><span class="line"><span class="string">b&#x27;XUaCompatible: IE=Edge,chrome=1&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;html&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;body bgcolor=&quot;white&quot;&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;/body&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;/html&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">进程已结束,退出代码0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端发送了一条HTTP请求，请求内容是<code>GET / HTTP/1.1\r\nHost: baidu.com\r\n\r\n</code>。关于该请求的含义需要去了解HTTP协议，这里不过多赘述<br>collapsed:: true</li>
<li>请求行：<code>GET / HTTP/1.1</code>，其中<code>GET</code>表示请求方法，<code>/</code>表示请求的URI路径，<code>HTTP/1.1</code>表示使用的HTTP协议版本。</li>
<li>请求头：<code>Host: baidu.com</code>，其中<code>Host</code>是HTTP&#x2F;1.1协议中的一个必选请求头字段，用于指定请求的目标服务器的域名或IP地址。</li>
<li>空行：<code>\r\n</code>表示一个空行，用于分隔请求头和请求体。由于这个请求没有请求体，因此空行后面没有数据。</li>
<li>由于HTTP协议中使用<code>\r\n</code>作为行结束符，因此请求报文中每行结尾都需要添加<code>\r\n</code>。在请求头和请求体之间需要添加一个空行，即两个<code>\r\n</code>，表示请求头已经结束，后面没有请求体数据。</li>
<li>这条请求会向<code>baidu.com</code>的默认HTTP端口80发起请求，<strong>要求获取主页内容</strong>。然后，客户端使用<code>client_socket.recv()</code>方法从服务器接收了一条消息，数据大小为4096字节。最后，客户端在控制台输出了从服务器接收到的数据。</li>
<li>上述reply后续的处理是为了便于人类阅读加上的。</li>
</ul>
<h3 id="关闭socket"><a href="#关闭socket" class="headerlink" title="关闭socket"></a>关闭socket</h3><p>完成数据交换后，服务器需要关闭socket，以释放网络资源。可以使用<code>socket.close()</code>函数来关闭socket</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<h2 id="服务器端Socket操作"><a href="#服务器端Socket操作" class="headerlink" title="服务器端Socket操作"></a>服务器端Socket操作</h2><ul>
<li>在服务器端，需要创建一个套接字并将其绑定到一个特定的网络地址，以便客户端可以连接到它。</li>
</ul>
<h3 id="服务器端绑定Socket"><a href="#服务器端绑定Socket" class="headerlink" title="服务器端绑定Socket"></a>服务器端绑定Socket</h3><ul>
<li>在创建完套接字后，我们可以使用<code>bind()</code>方法将套接字绑定到一个特定的IP地址和端口。</li>
<li>例如，以下代码将TCP套接字绑定到本地主机的8000端口</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将套接字绑定到本地主机的8000端口</span></span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>使用的方法便是<code>bind()</code>，其用于<strong>将一个套接字绑定到一个具体的IP地址和端口号上，从而使得其他套接字可以通过该地址和端口号找到这个套接字并与之通信。</strong></li>
</ul>
<h3 id="Socket侦听连接"><a href="#Socket侦听连接" class="headerlink" title="Socket侦听连接"></a>Socket侦听连接</h3><ul>
<li>接下来，我们可以使用<code>listen()</code>方法开始监听连接请求。</li>
<li>例如，以下代码开始监听TCP连接请求：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将套接字绑定到本地主机的8000端口</span></span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始监听连接请求</span></span><br><span class="line">sock.listen(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h3><ul>
<li>在监听请求期间，我们可以使用<code>accept()</code>方法接受客户端的连接请求。</li>
<li>例如，以下代码接受一个TCP连接请求</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将套接字绑定到本地主机的8000端口</span></span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始监听连接请求</span></span><br><span class="line">sock.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受客户端的连接请求</span></span><br><span class="line">client_sock, client_addr = sock.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出客户端的地址信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;客户端地址：&#x27;</span>, client_addr)</span><br></pre></td></tr></table></figure>



<h1 id="服务器端与客户端的异同"><a href="#服务器端与客户端的异同" class="headerlink" title="服务器端与客户端的异同"></a>服务器端与客户端的异同</h1><ul>
<li>创建和绑定：在服务器端，需要创建一个套接字并将其绑定到一个特定的网络地址，以便客户端可以连接到它。而在客户端，只需要创建一个套接字，并指定服务器的地址和端口来连接到服务器。</li>
<li>监听和接受连接：服务器端需要调用<code>listen()</code>函数来监听传入的连接请求。一旦有客户端请求连接，服务器端会调用<code>accept()</code>函数来接受连接，并创建一个新的套接字来处理与该客户端的通信。而客户端只需要调用<code>connect()</code>函数来连接到服务器。</li>
<li>数据交换：在服务器端，可以同时处理多个客户端的连接请求，并与每个客户端进行数据交换。服务器端可以使用多线程或多进程来实现并发处理。而客户端通常只与服务器进行一对一的通信。</li>
<li>关闭连接：在服务器端，当与客户端的通信结束后，需要调用<code>close()</code>函数来关闭与该客户端的连接。而客户端在完成通信后，也需要调用<code>close()</code>函数来关闭与服务器的连接。</li>
</ul>
<h1 id="常用方法语法"><a href="#常用方法语法" class="headerlink" title="常用方法语法"></a>常用方法语法</h1><ul>
<li>socket: <code>socket(family, type, proto)</code><ul>
<li>创建一个新的套接字对象其中</li>
<li><code>family</code> 指定地址族（如 <code>AF_INET</code> 表示 IPv4）</li>
<li><code>type</code> 指定套接字类型（如 <code>SOCK_STREAM</code> 表示 TCP 套接字）</li>
<li><code>proto</code> 指定协议类型（如 <code>IPPROTO_TCP</code> 表示 TCP 协议）。</li>
</ul>
</li>
<li>connect: <code>connect(address)</code><ul>
<li>连接到指定的地址</li>
<li><code>address</code> 是一个表示远程主机地址和端口号的元组。</li>
</ul>
</li>
<li>bind: <code>bind(address)</code><ul>
<li>绑定指定的地址到套接字</li>
<li><code>address</code> 是一个表示本地主机地址和端口号的元组。</li>
</ul>
</li>
<li>gethostbyname: <code>gethostbyname(hostname)</code><ul>
<li>解析指定主机名的 IP 地址，返回一个表示 IP 地址的字符串。</li>
</ul>
</li>
<li>gethostname: <code>gethostname()</code><ul>
<li>返回本地主机名。</li>
</ul>
</li>
<li>send: <code>send(data)</code><ul>
<li>发送数据到连接的套接字，其中 <code>data</code> 是要发送的数据。</li>
</ul>
</li>
<li>recv: <code>recv(bufsize)</code><ul>
<li>从连接的套接字接收数据，其中 <code>bufsize</code> 是要接收的最大字节数。</li>
</ul>
</li>
<li>listen: <code>listen(backlog)</code><ul>
<li>开始监听连接，其中 <code>backlog</code> 指定连接请求队列的最大长度。</li>
</ul>
</li>
</ul>
<h1 id="理解时遇到的一些问题"><a href="#理解时遇到的一些问题" class="headerlink" title="理解时遇到的一些问题"></a>理解时遇到的一些问题</h1><ul>
<li>创建的套接字对象的ip地址是不是就是本机的？<ul>
<li>在使用<code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code><strong>创建套接字对象时，它并没有绑定到任何本地地址或端口上</strong>。因此，在调用<code>bind()</code>方法之前，套接字对象并没有本地IP地址。</li>
<li>当调用<code>bind()</code>方法将套接字对象绑定到一个本地IP地址和端口号上时，它的本地IP地址就是你指定的本地IP地址。如果你在调用<code>bind()</code>方法时将IP地址参数设置为<code>&#39;&#39;</code>，则表示将套接字绑定到所有可用的IP地址上，这时套接字的本地IP地址将是本机的一个有效IP地址。</li>
<li>另外，当使用<code>connect()</code>方法将<strong>套接字连接到远程主机时，套接字对象的本地IP地址是由操作系统自动分配的。操作系统通常会使用本机上的一个可用IP地址作为套接字对象的本地IP地址，这个IP地址通常是本机的一个局域网IP地址或公网IP地址，取决于本机与远程主机之间的网络环境。</strong></li>
<li>因此，套接字对象的本地IP地址是否就是本机的IP地址，取决于你如何使用套接字对象，并且在使用套接字对象之前是否将其绑定到本地地址和端口号上。</li>
</ul>
</li>
<li><code>gethostbyname</code>与<code>getsockname</code>之间存在什么关系呢？<ul>
<li><code>gethostbyname()</code>方法是<strong>用于将主机名解析为IP地址</strong>。它接受一个主机名作为参数，并返回该主机名对应的IP地址。这个IP地址可以用于创建套接字，以便连接到远程服务器或绑定到本地地址。</li>
<li><code>getsockname()</code>方法是<strong>用于获取套接字的本地地址和端口号</strong>。它返回一个元组，包含套接字绑定的本地地址和端口号。这个本地地址可以用于告诉其他套接字如何连接到它。</li>
</ul>
</li>
</ul>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260139078">用大白话解释什么是Socket</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39982451">Python 的 Socket 编程教程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lbj1260200629/article/details/114823170">解决 Python3 中 TypeError: a byteslike object is required, not ‘str‘</a></li>
<li>chatgpt</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>项目式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉底不会写诗---周记02</title>
    <url>/2023/07/27/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B002-md/</url>
    <content><![CDATA[<p>只能说，标题没问题，确实是周记02，因为周记01里说了好些胡话，不想发，但肯定是不愿删的，所幸就直接从周记02开始了。</p>
<p>又是躺着拿工资的一周，爽！</p>
<span id="more"></span>

<h1 id="学了个锤子"><a href="#学了个锤子" class="headerlink" title="学了个锤子"></a>学了个锤子</h1><p>这周比上周略好，但是学习状态仍然很一般，当然这是指我自己学想学东西的状态。不过略好吧，下周再接再厉了咯。唉，英语真是折磨，也参了一些方法论，但是对于时间的要求确实比较苛刻了，我在考虑要不要早起一会，每天走之前抽空学一会，一进公司整个人就不太能沉下心来，学一会就切屏了qwq，好烦啊。继续尽力把它当作一门工具语言慢慢融入生活把，加油！</p>
<h1 id="终究周末才是美滋滋"><a href="#终究周末才是美滋滋" class="headerlink" title="终究周末才是美滋滋"></a>终究周末才是美滋滋</h1><p>周四在B站刷到了封神第一步的宣发片，当时就觉得这画面不错，而且封神这一题材作为东方玄幻的祖师爷之一我还是很感兴趣的。毫不掩饰的说，妲己确实有魅惑到我！</p>
<p>于是乎，周六便有了这一次进城，所幸相较于上次踩坑，这次体验好上太多。吸取了上次教训，这次在吃饭前提前问了林姐附近有没有什么地道的湘菜—我实在不想吃甜到腻歪的菜了，我想吃辣！！！！</p>
<p>事实证明，这确实是一个明智之举，洞庭湖湘菜馆—这家的爆炒鱿鱼真的非常不错，瑕不掩瑜，其他几个菜虽然平平庸庸，但这个真的不错，下次去我还要吃。不知道老板是不是地地道道的岳阳人，或许就是玥姐老乡了。</p>
<p>我也不知道为什么，福鼎这样一个在宁德下面的6线小城市，物价丝毫不逊色长沙，美团上想找个剪头发的地方，随随便便一家洗剪吹都得60左右，真哈人。最后挑挑拣拣终于找到一家35的，还算不错，我的发际线又有了保障。</p>
<p>电影院是我最后去的，虽然开局不利，但是电影看完真是意犹未尽。为什么说开局不利呢？再次重演了上次看电影的尴尬情况，不过这次还好，仅仅是字幕位置不对且最后也调整好了。封神第一部前面部分我觉得还算不错，线索明朗，从头到尾娓娓道来，逐步引出封神里的关键人物—姬发、妲己、殷寿(纣王)。但不得不吐槽的是姜子牙与二郎神杨戬的形象，不说截然不同，但确实与我印象中的相差甚远，也或许是我期望太高，毕竟相较于其他硬是作品中的这二位。姜子牙不过修道40余载，二郎神也算是初哥，略显青涩倒也正常，但这着实颠覆了我印象中他桀骜不驯的样子，你可是杨戬啊！！！！随后剧情的跌宕起伏，伴随着殷寿“传销头子”形象的逐渐丰满与妲己的步步登天、姬发在兄友的先后祭天中醒悟，剧情也逐渐演变向高潮，最后以殷寿“身死”戛然而止。当然，大幕才刚拉开帷幕。我对后续充满期待。</p>
<h1 id="新尝试"><a href="#新尝试" class="headerlink" title="新尝试"></a>新尝试</h1><p>公司的游泳馆规格早有耳闻，使用臭氧消毒，不可谓不奢侈，作为内地的旱鸭子我已经很久没有下过水了，上次游泳应该还是在初中，当时学着怎么飘起了，鼻子在外面呼吸。</p>
<p>这次买的设备也都到了，于是乎便拉上人，在水里扑棱。估计还是有点肌肉记忆，在水里泡了半小时，蛙泳倒也能一口气游个十多米，当然，换气换不来，只能憋着谁手脚尽量协调着做蛙泳，有些慢，但确实动了。</p>
<p>这次游泳倒是一口水没喝，但是鼻子吸的水可一点也不少，每游一会都得跑旁边擤一会，排排水，着实刺鼻。</p>
<p>这还没有开始换气，如果练习换气估计我会喝不少水，要不要看看视频学习学习，请教练我自然是不愿意的，舍不得那个钱。况且我也觉得没必要，人大了反而比较拘谨，自己摸索倒是畅快许多。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉底不会写诗-周记03</title>
    <url>/2023/07/31/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B003-md/</url>
    <content><![CDATA[<p>这周开始正经上课了，两个手机都得交，逮到直接重学qwq。这周过的比较充实，浅浅的记录一下。</p>
<span id="more"></span>

<h1 id="新东西"><a href="#新东西" class="headerlink" title="新东西"></a>新东西</h1><h2 id="安全盲区"><a href="#安全盲区" class="headerlink" title="安全盲区"></a>安全盲区</h2><p>每天上课交了手机还专抓睡觉，终究是没法肆意摸鱼了，老老实实听课哩~~</p>
<p>终究还是接触了一些新东西，新名词的。课堂上有些曾经的安全事故设身处地的想，我也许也有可能成为视频里那个“愚者”。比如，汽油在空气中放置不当，非常容易级转瞬即“逝”，我对于这些不说毫不知情，只能说一窍不通，之前从未接触。</p>
<p>比如说衡量气体的爆炸极限、液体的闪点。至于固体，燃点不会有人不知道吧o.0。</p>
<p><strong>关于课堂上只要与安全相关几乎次次提到的红沿河事件，我由衷的怜悯那位下楼梯看手机失足脑袋卡住的老哥，同时也反省自己。在大学期间，走路玩手机基本是我的常态，和兄弟们三五成群的“横行”时我总是通过他们的肩膀定位，而另外一只手常常握着手机。倘若这样的事故发生在我头上，自然是连后悔的机会也没有，因此在某些方面按安全规章做事显然是有必要的—安全保障的是自己。</strong></p>
<p>这就不得不提我对公司非常满意的一点，目前来看在各个方面各个领域都严格按照固有的规章，按图索骥，按部就班来准定是一件非常了不起的事情—当然这是一个新员工从公司介绍中的了解，实际如何还得入了岗才知道。虽然有些时候跨过规矩会省事，但随之而来的是风险，而在这个领域，风险或许等同于不可预知的威胁。</p>
<h2 id="ESP32"><a href="#ESP32" class="headerlink" title="ESP32"></a>ESP32</h2><p>此前接触的嵌入式路线基本是51—stm32—嵌入式Linux。但是这周偶然在B站看到了使用ESP32实现的墨水瓶，还挺有意思的。于是乎便稍微关注了下，随后发现这东西制作小玩意还真挺方便的，蓝牙与WiFi的存在使得其可以通过API与互联网进行交互完成许多有意思的功能—天气、股票曲线、动图、TODO提示、墨水屏手表等等。关键是这芯片是真的很便宜，价格非常美丽，买来玩玩完全不心疼，而且似乎可以通过Python对功能进行编译，此前使用Python编译的我仅知道树莓派，但那价格与目标用户与我暂时对不上。</p>
<p>进一步了解后，发现我关注的知名UP主稚晖君对于ESP32也有过应用，自研了一个透明小电视</p>
<p>当时他这个项目似乎是手头有什么就用什么(好想也像这样融会贯通啊！！！！)，完全照搬会踩很多坑，因此可以直接参考这个改良过后的版本—<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1d3411T77a/?spm_id_from=333.337.search-card.all.click">视频链接</a>，当然加群是必须的，开源资源整理的非常全面<br><img src="https://s2.loli.net/2023/07/31/W3DbVfu7E8zUgkA.png" alt="image-20230731230146725"></p>
<p>目前我的想法是用ESP32做一个墨水屏天气+时间显示器(暂时想要这些功能)的小摆件，然后稍微懂点ESP32再去做小电视，不过托发工资的福，买东西倒无需像大学一样束手束脚。好耶！！</p>
<h2 id="手办—有点尴尬"><a href="#手办—有点尴尬" class="headerlink" title="手办—有点尴尬"></a>手办—有点尴尬</h2><p>在B站上刷到了一个感觉挺不错的手办—纯白精灵，居然可以用口罩给她做衣服，看了测评视频，似乎也不贵，于是就果断下单了。</p>
<p>到了以后。。。我在快递点拆开了外面的快递盒，因为它实在太大了，我寻思一个手办怎么这么大。然后就有些社死，这外壳，好色qwq！！！怎么说呢，别人不会以为我手里的是情趣玩具吧，哭！&#x2F;(ㄒoㄒ)&#x2F;~~</p>
<p>当时我就是假装镇定，说“手办有点大啊，回去看看”。</p>
<p>拆开以后，只能庆幸还好没在快递点拆完—她是全裸的，衣服还得我帮她穿，我…第一次买手办，真不知道啊。(穿上了还是好涩QWQ，但我好喜欢QAQ)</p>
<h1 id="物价带来的一点点思考"><a href="#物价带来的一点点思考" class="headerlink" title="物价带来的一点点思考"></a>物价带来的一点点思考</h1><p>之间进城里剪个头发，问一圈全是四五十，找了一阵才看的一个三十多的。当时就为福鼎这六线城市但是近乎一线城市(这里说的是长沙)的物价感到诧异，随便吃点冒菜也嘎嘎贵就更让人不能理解了。</p>
<p>现在终于知道(也许是真相？)福鼎这边物价不便宜的原因了，从某种意义上来说这里便是江浙一带的后花园，虽然在福建，但这里的人距离温州却是最近的，而且大部分人都在江浙那边发了财，因此豪车也不罕见。类似打进福建的内奸？富哥多的很，非常多的豪车豪宅—当然这是我道听途说的，才来三周呢。</p>
<p>但是让人奇怪的是，虽然这里的部分人也许确实很有钱，但宁德—福鼎在整个福建确实属于很穷的，几个人的富裕与当地财政又有多大影响呢？似乎老家也是这样，虽然刚经过国家帮扶摘掉贫困县帽子，当地绝不缺穷人—或者说基本是都是温饱。但绝不缺富豪，豪车豪宅也见过不少(也许都是再外地发了财的)。当地物价这几年也长得离谱，毫不避讳地说和福鼎一样，这些城市所拥有的硬实力根本配不上当地的物价，非常离谱。</p>
<p>讲到这就不得不提一嘴工作前去玩过的岳阳了，那确实是一座非常宜居的城市—至少见识浅薄的我是这么认为的，作为湖南第二梯队的城市，岳阳的物价并不算贵—但是如果爽吃烧烤那可真是便宜不了一点！而且近几年捕鱼禁了，洞庭湖旁工业禁了，在岳阳的人闲暇时逛一逛湖畔风景(不止洞庭湖哦，还有南湖)那凉爽的湖风当真让人畅意。当然，房价也是需要考虑的，这边房价自然不便宜，当然也定然不会太贵，只能说正常吧—类似长沙。风景+美食+交通便利+生活节奏较慢种种原因让我对这个城市印象格外的不错。希望以后没有培训时候11长假可以多出去看看，好好体验下大好河山的自然美景与人文风俗，想想真是让人期待。</p>
<h1 id="工资到了"><a href="#工资到了" class="headerlink" title="工资到了"></a>工资到了</h1><p>工资到手了，4k+，我蛮满意的，笔记这个月基本都是摸鱼中度过的。这并算不上人生的第一桶金，也算不上第一笔工资，无论是大二当倒🐕还是实习，都拿了点钱。但这对于我来说仍然意义非凡，因为这是我第一份正式工作的第一笔工资。</p>
<p>直接开始小清一手购物车，4k+说少也不少了，只要不觊觎相机、无人机、升级电脑之内的，小玩意自然是可以想买就买。剁手剁手！！！</p>
<h1 id="忙碌的周末"><a href="#忙碌的周末" class="headerlink" title="忙碌的周末"></a>忙碌的周末</h1><p>整个周末基本都在宿舍，周六忙于拼积木—整整一天。周日则持续摆烂状态，玩一会学一会，玩一会学一会，不过精神倒是放松了不少，挺舒服的。而且做出来的积木也差强人意—毕竟第一次做。<br><img src="https://s2.loli.net/2023/07/31/TsuoQLxtIBjNfKi.png" alt="image-20230731230542899"></p>
<p><img src="https://s2.loli.net/2023/07/31/dNuEx7K3stlwYnV.png" alt="image-20230731230551252"></p>
<p>我就想啊，能不能把周末也加入可以调休，狠狠的工作狠狠的玩。当然，我也知道这只能是自己YY一下。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉底不会写诗---周记04</title>
    <url>/2023/08/07/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B004-md/</url>
    <content><![CDATA[<h1 id="怀念"><a href="#怀念" class="headerlink" title="怀念"></a>怀念</h1><p>最近总是想学校、想长沙、想家。突如其来，也许走着走着，刷着手机，吃着饭，突如其来涌上心头。有点想吃校门口的烤面筋、烧烤、鸡公煲，哪怕是吃到腻歪的黄焖茄子，都很怀念。那种张着嘴巴，呼哈呼哈，拍着小肚子散着步回宿舍，漫谈着天南地北，憧憬着那个叫做以后的东西。时不时叫上人，去大碗先生爽吃干锅鱿鱼，或是出个小远门体验下五一各种小吃，也很怀念湖南的蛙来哒。正在写这段话的我刚淋完雨还饿着肚皮，不由吞咽了一口口水。想吃吴酥生的绿豆糕了捏。</p>
<p>从未距离故乡如此之远，生活方式的不同，让我有时在餐桌上看着一桌的菜却无从下手，在小吃街逛了一圈却空手而归。同时，也确实想家了，也不知老人家在家身体怎么样了，写完这里打个电话慰问下。</p>
<p>怀念湖南了，我知道那里我有去处，也有归宿…我也不知道何时能适应，或者是忘却。</p>
<span id="more"></span>

<h1 id="新玩意"><a href="#新玩意" class="headerlink" title="# 新玩意"></a># 新玩意</h1><h2 id="typora插件"><a href="#typora插件" class="headerlink" title="typora插件"></a>typora插件</h2><p><a target="_blank" rel="noopener" href="https://github.com/obgnail/typora_plugin">typora插件集合，功能增强工具</a></p>
<p>在网上闲逛时，偶然看到这个关于typora插件的项目，仔细看了看插件的功能，直呼舒服了。</p>
<p>typora我一直是用来做总结性或者写一些比较短的东西的，很少用来写会频繁更新的。虽然其非常简洁，而且用起来很舒服，但是章节折叠的问题一直让我很难受，如果篇幅一旦长了想找之前的某个内容会显得有些困难。当然新版的typora提供了侧边栏的目录功能，这一缺陷其实还好，但是如果可以折叠章节，敲字体验也许会好一点，而恰巧这个插件里面有这一功能。</p>
<p>其他插件功能也各种各样，有许多是我未曾考虑，当然某种意义上也是并不在需求范围之内的，不过插件功能启用与否是基于自己需求的，不需要不启动这一个就行了。</p>
<p><img src="https://s2.loli.net/2023/08/07/7KzxtDE8uocfa65.png" alt="image-20230807201908380"></p>
<h2 id="激活正版IDM"><a href="#激活正版IDM" class="headerlink" title="激活正版IDM"></a>激活正版IDM</h2><p><a target="_blank" rel="noopener" href="https://github.com/lstprjct/IDM-Activation-Script">项目地址</a></p>
<p>之前用的IDM都是网上蹭来的，也一直没有更新，这个项目刚好可以解决这个问题，而且属于一劳永逸式，是支持继续更新的—只要不被官方逮捕。</p>
<h2 id="将下述代码复制到Windows的powershell中并运行，然后会弹出一个命令描述符窗口，输入1进行选择即可"><a href="#将下述代码复制到Windows的powershell中并运行，然后会弹出一个命令描述符窗口，输入1进行选择即可" class="headerlink" title="将下述代码复制到Windows的powershell中并运行，然后会弹出一个命令描述符窗口，输入1进行选择即可"></a>将下述代码复制到Windows的powershell中并运行，然后会弹出一个命令描述符窗口，输入1进行选择即可</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enable TLSv1.2 <span class="keyword">for</span> compatibility with older clients</span></span><br><span class="line">[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor [System.Net.SecurityProtocolType]::Tls12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DownloadURL = <span class="string">&#x27;https://raw.githubusercontent.com/lstprjct/IDM-Activation-Script/main/IAS_0.8.cmd&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FilePath = <span class="string">&quot;<span class="variable">$env</span>:TEMP\IAS.cmd&quot;</span></span></span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Invoke-WebRequest -Uri $DownloadURL -UseBasicParsing -OutFile $FilePath</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    Write-Error $_</span><br><span class="line">        Return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Test-Path $FilePath) &#123;</span><br><span class="line">    Start-Process $FilePath -Wait</span><br><span class="line">    $item = Get-Item -LiteralPath $FilePath</span><br><span class="line">    $item.Delete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后弹窗中会让你取一个用户名，随便写即可，回车就行了，最后命令行会出现successful activate，代表激活成功</p>
<p>打开IDM，点击上方工具栏中注册，就可以看的已经激活了</p>
<p><img src="https://s2.loli.net/2023/08/07/2KYgvBEZFrcIthq.png" alt="image-20230807201928450"></p>
<h1 id="忙碌"><a href="#忙碌" class="headerlink" title="忙碌"></a>忙碌</h1><p>这周的节奏都很紧凑，或者说充实，培训+捯饬ESP32+python等等。</p>
<h2 id="捯饬ESP32"><a href="#捯饬ESP32" class="headerlink" title="捯饬ESP32"></a>捯饬ESP32</h2><p>本来是想用ESP32参考网上开源项目做一个水墨屏，功能也就需要显示简单的图片+时间+天气。要求不高，但是我犯错了，因为微雪与汉朔价格差的还是比较多的，而且做这个玩意其实主要也是为了练练手。最初想法是通过这个简单接触下ESP32，后续想复刻稚辉君的HoloCubic项目。</p>
<p>然而，我选择使用微雪的替代品，汉朔价签，然后拆掉墨水屏进行使用。因此我需要考虑的问题就多了，驱动板，驱动程序—需要适配micro python。但是在官网找了一圈 ，对应ESP32的程序目前只有C版本，同时汉朔的价签驱动板也肯定是需要替换的，它是内嵌了处理器的。网上教程倒是很丰富，学就行了，但是驱动板这块自己飞线改还是太费劲了，找一块适配24P墨水瓶的驱动板并不难，闲鱼也就6.5。</p>
<p>但驱动程序就需要一点时间，自己基于能找的现有资料慢慢去改了，目前买的东西已经在路上了，希望到手后能够成功点亮。</p>
<p>这里不得不提一嘴，Cursor是真的好用，代码不懂直接问，上下文语境也很到位。基于ChatGPT4果真非常NICE。</p>
<h2 id="游泳学换气"><a href="#游泳学换气" class="headerlink" title="游泳学换气"></a>游泳学换气</h2><p>说白了就是喝水，憋气游倒是能动了，虽然速度不快，但游个一半倒也可以，但是不换气很快就会力竭。</p>
<p>换气的话事先学习了教程，简单来说就是水下鼻子缓慢呼气，扒拉出水一瞬间嘴巴吸气，然后再下去。这个过程似乎很简单，但当我真正游起来，只能说水管饱。</p>
<p>一个人在水边练习倒还好，节奏似乎找到了，吸气下去呼气出来。但自己一游，尝试换气，惨不忍睹。首先是呼气，鼻子呼气气没吐掉，总是感觉肺部怪怪的，想让头顶出水面都是一个问题。其次是出水，我练习的是蛙泳，出水方式是手往外张顺势往下压，结合脚的动作让头冲出水面。但动作不协调，总是让我的脑袋只能将将出去。这时候我嘴巴张开吸一口气，好家伙，猛猛一大口灌进去，给我呛的啊。</p>
<p>所以说理论还是理论，一定要边实践边学习，这玩意不多吃几次水估计还是不好掌握。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>python程序中经常出现的是干嘛的?</title>
    <url>/2023/08/09/python%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-md/</url>
    <content><![CDATA[<p>简单来说，这句话的作用就是判断你执行的是不是当前文件？如果是，则执行if块里面的，如果不是就不会执行。</p>
<p>是不是有些拗口，什么叫我执行的是不是当前文件？这就得从python的模块概念说起。</p>
<span id="more"></span>

<p>首先得先明白python是一个解释型语言，它与C不一样并不是先全部编译并链接好再进行执行的，而是从你运行的那个模块的最顶行开始，逐行解释执行。所以，最顶层（没有被缩进）的代码都会被执行，而<strong>我们<code>import module</code>的操作就是把<code>module</code>这个模块导入到当前模块里面，并且把它执行一遍。</strong>可以通过例子理解下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;Welcome to my module&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line"></span><br><span class="line">test1.greet(<span class="string">&quot;Alice&quot;</span>)  <span class="comment"># 调用模块中的函数</span></span><br><span class="line"><span class="built_in">print</span>(test1.message)  <span class="comment"># 访问模块中的变量</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Welcome to my module</span></span><br><span class="line"><span class="string">Hello, Alice!</span></span><br><span class="line"><span class="string">Welcome to my module</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从输出结果判断我们可以看出，确实是导入module再执行module，然后继续往下执行。</p>
<p>[^tips]: 如此一来，我们也能理解在很多python项目中使用方法为什么一般都是from XXX import XXX，如果直接import，开销也就太大了。</p>
<p>每次import都会把导入的模块执行一遍，但又不是所有的模块都只有函数，如果里面有输出或者其他操作，这些又不是我需要的，怎么处理呢。<strong>简而言之，如何避免某些代码在模块被导入后被执行？</strong> — 这恰恰是<code> if __name__ == &#39;__main__&#39;</code>的作用。</p>
<p><code>__name__ </code>是python的一个内置属性，其用于标识当前模块的名称。当一个模块被直接执行时，其名称被设置为 <code>&quot;__main__&quot;</code>。而当一个模块被导入到其他模块中时，其名称则被设置为模块的实际名称。这里可以举例理解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这里是模块：&#x27;</span>, __name__)</span><br><span class="line"><span class="comment"># 这里是模块： __main__</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这里是模块：&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># main_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这里是模块：&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这里是模块： test1</span></span><br><span class="line"><span class="string">这里是模块： __main__</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>了解了<code>__name__</code>是什么，那么<code>if __name__ == &#39;__main__&#39;</code>的作用就显而易见了。就是判断当前执行的模块是不是我，如果不是，我后面的程序就不执行，如果是就执行。</p>
]]></content>
      <categories>
        <category>Python-learn</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
