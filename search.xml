<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python Selenium库</title>
    <url>/2023/03/06/Python-Selenium%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Python-Selenium库"><a href="#Python-Selenium库" class="headerlink" title="Python Selenium库"></a>Python Selenium库</h1><h2 id="Selenium基础"><a href="#Selenium基础" class="headerlink" title="Selenium基础"></a>Selenium基础</h2><p>​	Selenium是一个用于测试网站的自动化测试工具，支持各种浏览器包括Chrome、Firefox、Safari等主流界面浏览器，同时也支持phantomJS无界面浏览器。</p>
<h3 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h3><p>​	<code>pip install Selenium</code></p>
<h3 id="安装浏览器驱动"><a href="#安装浏览器驱动" class="headerlink" title="安装浏览器驱动"></a>安装浏览器驱动</h3><p>​	谷歌浏览器下载链接 <a target="_blank" rel="noopener" href="https://chromedriver.storage.googleapis.com/index.html?path=2.35/">https://chromedriver.storage.googleapis.com/index.html?path=2.35/</a></p>
<p>​	火狐浏览器下载链接 <a target="_blank" rel="noopener" href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>​	设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： F:\GeckoDriver , 将下载的浏览器驱动文件（例如：chromedriver、geckodriver）丢到该目录下。</p>
<p><strong>我的电脑–&gt;属性–&gt;系统设置–&gt;高级–&gt;环境变量–&gt;系统变量–&gt;Path，将“F:\GeckoDriver”目录添加到Path的值中。比如：Path字段;F:\GeckoDriver</strong></p>
<span id="more"></span>


<h2 id="Selenium-快速入门"><a href="#Selenium-快速入门" class="headerlink" title="Selenium 快速入门"></a>Selenium 快速入门</h2><h3 id="Selenium提供了8种定位方式"><a href="#Selenium提供了8种定位方式" class="headerlink" title="Selenium提供了8种定位方式"></a>Selenium提供了8种定位方式</h3><ol>
<li>id</li>
<li>name</li>
<li>class name</li>
<li>tag name</li>
<li>link text</li>
<li>partial link text</li>
<li>xpath</li>
<li>css selector</li>
</ol>
<h3 id="定位元素的8种方式"><a href="#定位元素的8种方式" class="headerlink" title="定位元素的8种方式"></a>定位元素的8种方式</h3><table>
<thead>
<tr>
<th>定位一个元素</th>
<th>定位多个元素</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td>find_element_by_id</td>
<td>find_elements_by_id</td>
<td align="center">通过元素id定位</td>
</tr>
<tr>
<td>find_element_by_name</td>
<td>find_elements_by_name</td>
<td align="center">通过元素name定位</td>
</tr>
<tr>
<td>find_element_by_xpath</td>
<td>find_elements_by_xpath</td>
<td align="center">通过xpath表达式定位</td>
</tr>
<tr>
<td>find_element_by_link_text</td>
<td>find_elements_by_link_tex</td>
<td align="center">通过完整超链接定位</td>
</tr>
<tr>
<td>find_element_by_partial_link_text</td>
<td>find_elements_by_partial_link_text</td>
<td align="center">通过部分链接定位</td>
</tr>
<tr>
<td>find_element_by_tag_name</td>
<td>find_elements_by_tag_name</td>
<td align="center">通过标签定位</td>
</tr>
<tr>
<td>find_element_by_class_name</td>
<td>find_elements_by_class_name</td>
<td align="center">通过类名进行定位</td>
</tr>
<tr>
<td>find_elements_by_css_selector</td>
<td>find_elements_by_css_selector</td>
<td align="center">通过css选择器进行定位</td>
</tr>
</tbody></table>
<h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><h4 id="web页面："><a href="#web页面：" class="headerlink" title="web页面："></a>web页面：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">link</span>=<span class="string">&quot;#0000cc&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;result_logo&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">onmousedown</span>=<span class="string">&quot;return c(&#123;&#x27;fm&#x27;:&#x27;tab&#x27;,&#x27;tab&#x27;:&#x27;logo&#x27;&#125;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/s&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;soutu-btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;kw&quot;</span> <span class="attr">class</span>=<span class="string">&quot;s_ipt&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;255&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先需要先导入模块然后进行一些操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">dr=webdriver.Chrome()</span><br><span class="line">dr.get(<span class="string">&#x27;url&#x27;</span>)  <span class="comment">#这里的url就是对应页面的url</span></span><br></pre></td></tr></table></figure>



<h5 id="通过id定位"><a href="#通过id定位" class="headerlink" title="通过id定位:"></a>通过id定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_id(<span class="string">&quot;kw&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过name定位"><a href="#通过name定位" class="headerlink" title="通过name定位:"></a>通过name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_name(<span class="string">&quot;wd&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过class-name定位"><a href="#通过class-name定位" class="headerlink" title="通过class name定位:"></a>通过class name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_class_name(<span class="string">&quot;s_ipt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过tag-name定位"><a href="#通过tag-name定位" class="headerlink" title="通过tag name定位:"></a>通过tag name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_tag_name(<span class="string">&quot;input&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过xpath定位-常用写法"><a href="#通过xpath定位-常用写法" class="headerlink" title="通过xpath定位,常用写法"></a>通过xpath定位,<em>常用写法</em></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;kw&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//*[@name=&#x27;wd&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;/html/body/form/span/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//span[@class=&#x27;soutu-btn&#x27;]/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//form[@id=&#x27;form&#x27;]/span/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//input[@id=&#x27;kw&#x27; and @name=&#x27;wd&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过css定位-常用写法"><a href="#通过css定位-常用写法" class="headerlink" title="通过css定位_常用写法_"></a>通过css定位_常用写法_</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;#kw&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;[name=wd]&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;.s_ipt&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;html &gt; body &gt; form &gt; span &gt; input&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;span.soutu-btn&gt; input#kw&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;form#form &gt; span &gt; input&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>假如页面上有一组文本链接</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;mnav&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://news.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tj_trnews&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;mnav&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.hao123.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tj_trhao123&quot;</span>&gt;</span>hao123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="通过link-text定位"><a href="#通过link-text定位" class="headerlink" title="通过link text定位"></a>通过link text定位</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_link_text(<span class="string">&quot;新闻&quot;</span>)</span><br><span class="line">dr.find_element_by_link_text(<span class="string">&quot;hao123&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过partial link text定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;新&quot;</span>)</span><br><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;hao&quot;</span>)</span><br><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Selenium库下webdriver模块常用方法"><a href="#Selenium库下webdriver模块常用方法" class="headerlink" title="Selenium库下webdriver模块常用方法"></a>Selenium库下webdriver模块常用方法</h3><h4 id="控制浏览器操作的一些方法"><a href="#控制浏览器操作的一些方法" class="headerlink" title="控制浏览器操作的一些方法"></a>控制浏览器操作的一些方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>set_window_size()</td>
<td>设置浏览器的大小</td>
</tr>
<tr>
<td>back()</td>
<td>控制浏览器后退</td>
</tr>
<tr>
<td>forward()</td>
<td>控制浏览器前进</td>
</tr>
<tr>
<td>refresh()</td>
<td>刷新当前页面</td>
</tr>
<tr>
<td>clear()</td>
<td>清除文本</td>
</tr>
<tr>
<td>send_keys (value)</td>
<td>模拟按键输入</td>
</tr>
<tr>
<td>click()</td>
<td>单击元素</td>
</tr>
<tr>
<td>submit()</td>
<td>用于提交表单</td>
</tr>
<tr>
<td>get_attribute(name)</td>
<td>获取元素属性值</td>
</tr>
<tr>
<td>is_displayed()</td>
<td>设置该元素是否用户可见</td>
</tr>
<tr>
<td>size</td>
<td>返回元素的尺寸</td>
</tr>
<tr>
<td>text</td>
<td>获取元素的文本</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment">#1.创建Chrome浏览器对象，这会在电脑上在打开一个浏览器窗口</span></span><br><span class="line">browser = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)               <span class="comment">#这个就是电脑上存放驱动的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过浏览器向服务器发送URL请求</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.刷新浏览器</span></span><br><span class="line">browser.refresh()</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.设置浏览器的大小</span></span><br><span class="line">browser.set_window_size(<span class="number">1400</span>,<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在浏览器上进行操作</span></span><br><span class="line">element=browser.find_element_by_link_text(<span class="string">&quot;新闻&quot;</span>)</span><br><span class="line">element.click()      <span class="comment">#模拟鼠标左键单击</span></span><br><span class="line"></span><br><span class="line">element=browser.find_element_by_link_text(<span class="string">&quot;“下团组”时间&quot;</span>)</span><br><span class="line">element.click()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>​	在 WebDriver 中， 将这些关于鼠标操作的方法封装在 ActionChains 类提供</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ActionChains(driver)</td>
<td>构造ActionChains对象</td>
</tr>
<tr>
<td>context_click()</td>
<td>右击</td>
</tr>
<tr>
<td>move_to_element(above)</td>
<td>执行鼠标悬停操作</td>
</tr>
<tr>
<td>double_click()</td>
<td>双击</td>
</tr>
<tr>
<td>drag_and_drop()</td>
<td>拖动</td>
</tr>
<tr>
<td>move_to_element(above)</td>
<td>执行鼠标悬停操作</td>
</tr>
<tr>
<td>context_click()</td>
<td>用于模拟鼠标右键操作， 在调用时需要指定元素定位</td>
</tr>
<tr>
<td>perform()</td>
<td>执行所有 ActionChains 中存储的行为，可以理解成是对整个操作的提交动作</td>
</tr>
</tbody></table>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMzA4MTIwODU5MzEx?x-oss-process=image/format,png" alt="实例演示在百度首页用selenium进行设置操作"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment">#1.引入 ActionChains 类</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建Chrome浏览器对象，这会在电脑上在打开一个浏览器窗口</span></span><br><span class="line">driver = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.定位到要悬停的元素</span></span><br><span class="line">element= driver.find_element_by_link_text(<span class="string">&quot;设置&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.对定位到的元素执行鼠标悬停操作</span></span><br><span class="line">ActionChains(driver).move_to_element(element).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到要进行操作的选项</span></span><br><span class="line">elem1=driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>)</span><br><span class="line">elem1.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过元素选择器找到id=sh_2,并点击设置</span></span><br><span class="line">elem2=driver.find_element_by_id(<span class="string">&quot;sh_1&quot;</span>)</span><br><span class="line">elem2.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存设置</span></span><br><span class="line">elem3=driver.find_element_by_class_name(<span class="string">&quot;prefpanelgo&quot;</span>)</span><br><span class="line">elem3.click()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>​	Selenium中的Key模块为我们提供了模拟键盘按键的方法，那就是send_keys()方法。它不仅可以模拟键盘输入，也可以模拟键盘的操作。</p>
<p>模拟键盘操作</p>
<table>
<thead>
<tr>
<th>模拟键盘按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.BACK_SPACE)</td>
<td>删除键（BackSpace）</td>
</tr>
<tr>
<td>send_keys(Keys.SPACE)</td>
<td>空格键(Space)</td>
</tr>
<tr>
<td>send_keys(Keys.TAB)</td>
<td>制表键(Tab)</td>
</tr>
<tr>
<td>send_keys(Keys.ESCAPE)</td>
<td>回退键（Esc）</td>
</tr>
<tr>
<td>send_keys(Keys.ENTER)</td>
<td>回车键（Enter）</td>
</tr>
</tbody></table>
<p>模拟键盘组合键</p>
<table>
<thead>
<tr>
<th>模拟键盘按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.CONTROL,‘a’)</td>
<td>全选（Ctrl+A）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘c’)</td>
<td>复制（Ctrl+C）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘x’)</td>
<td>剪切（Ctrl+X）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘v’)</td>
<td>粘贴（Ctrl+V）</td>
</tr>
<tr>
<td>send_keys(Keys.F1…Fn)</td>
<td>键盘 F1…Fn</td>
</tr>
</tbody></table>
<h4 id="获取断言信息"><a href="#获取断言信息" class="headerlink" title="获取断言信息"></a>获取断言信息</h4><p>​	不管是在做功能测试还是自动化测试，最后一步需要拿实际结果与预期进行比较。这个比较的称之为断言。通过我们获取title 、URL和text等信息进行断言。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>用于获得当前页面的标题</td>
</tr>
<tr>
<td>current_url</td>
<td>用户获得当前页面的URL</td>
</tr>
<tr>
<td>text</td>
<td>获取搜索条目的文本信息</td>
</tr>
</tbody></table>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before search================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面title</span></span><br><span class="line">title = driver.title</span><br><span class="line"><span class="built_in">print</span>(title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面URL</span></span><br><span class="line">now_url = driver.current_url</span><br><span class="line"><span class="built_in">print</span>(now_url)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After search================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次打印当前页面title</span></span><br><span class="line">title = driver.title</span><br><span class="line"><span class="built_in">print</span>(title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面URL</span></span><br><span class="line">now_url = driver.current_url</span><br><span class="line"><span class="built_in">print</span>(now_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取结果数目  text</span></span><br><span class="line">user = driver.find_element_by_class_name(<span class="string">&#x27;nums&#x27;</span>).text</span><br><span class="line"><span class="built_in">print</span>(user)</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭所有窗口</span></span><br><span class="line">driver.quit()</span><br><span class="line"><span class="comment">#结果如下</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Before search================</span></span><br><span class="line"><span class="string">百度一下，你就知道</span></span><br><span class="line"><span class="string">https://www.baidu.com/</span></span><br><span class="line"><span class="string">After search================</span></span><br><span class="line"><span class="string">selenium_百度搜索</span></span><br><span class="line"><span class="string">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=selenium&amp;rsv_pq=a1d51b980000e36e&amp;rsv_t=a715IZaMpLd1w92I4LNUi7gKuOdlAz5McsHe%2FSLQeBZD44OUIPnjY%2B7pODM&amp;rqlang=cn&amp;rsv_enter=0&amp;rsv_sug3=8&amp;inputT=758&amp;rsv_sug4=759</span></span><br><span class="line"><span class="string">搜索工具</span></span><br><span class="line"><span class="string">百度为您找到相关结果约7,170,000个</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="设置元素等待"><a href="#设置元素等待" class="headerlink" title="设置元素等待"></a>设置元素等待</h4><h4 id="定位一组元素-注意：是一组元素"><a href="#定位一组元素-注意：是一组元素" class="headerlink" title="定位一组元素(注意：是一组元素)"></a>定位一组元素(注意：是一组元素)</h4><p>​	定位一组元素的方法与定位单个元素的方法类似，唯一的区别是在单词element后面多了一个s表示复数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver =webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.定位一组元素</span></span><br><span class="line">elements = driver.find_elements_by_xpath(<span class="string">&#x27;//div/h3/a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(elements))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.循环遍历出每一条搜索结果的标题</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> elements:</span><br><span class="line">    <span class="built_in">print</span>(t.text)</span><br><span class="line">    element=driver.find_element_by_link_text(t.text)</span><br><span class="line">    element.click()</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="多表单切换"><a href="#多表单切换" class="headerlink" title="多表单切换"></a>多表单切换</h4><p>​	在Web应用中经常会遇到frame&#x2F;iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame&#x2F;iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame&#x2F;iframe表单的内嵌页面中。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>switch_to.frame()</td>
<td>将当前定位的主体切换为frame&#x2F;iframe表单的内嵌页面中</td>
</tr>
<tr>
<td>switch_to.default_content()</td>
<td>跳回最外层的页面</td>
</tr>
</tbody></table>
<p>126邮箱登录框的结构大概是这样子的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;x-URS-iframe&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           ...</span><br><span class="line">           <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>想要操作登录框必须要先切换到iframe表单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;http://www.126.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.switch_to.frame(<span class="string">&#x27;x-URS-iframe&#x27;</span>)</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;email&quot;</span>).clear()</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;email&quot;</span>).send_keys(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;password&quot;</span>).clear()</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;password&quot;</span>).send_keys(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;dologin&quot;</span>).click()</span><br><span class="line">driver.switch_to.default_content()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="comment">#先通过xpth定位到iframe</span></span><br><span class="line">xf = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;x-URS-iframe&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#再将定位对象传给switch_to.frame()方法</span></span><br><span class="line">driver.switch_to.frame(xf)</span><br><span class="line">……</span><br><span class="line">driver.switch_to.parent_frame()</span><br></pre></td></tr></table></figure>

<h4 id="多窗口切换："><a href="#多窗口切换：" class="headerlink" title="多窗口切换："></a>多窗口切换：</h4><p>​	在页面操作过程中有时候点击某个链接会弹出新的窗口，这时就需要主机切换到新打开的窗口上进行操作。WebDriver提供了switch_to.window()方法，可以实现在不同的窗口之间切换。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>current_window_handle</td>
<td align="center">获得当前窗口句柄</td>
</tr>
<tr>
<td>window_handles</td>
<td align="center">返回所有窗口的句柄到当前会话</td>
</tr>
<tr>
<td>switch_to.window()</td>
<td align="center">用于切换到相应的窗口，与上一节的switch_to.frame()类似，前者用于不同窗口的切换，后者用于不同表单之间的切换。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.获得百度搜索窗口句柄</span></span><br><span class="line">sreach_windows = driver.current_window_handle</span><br><span class="line"></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&#x27;登录&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;立即注册&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.获得当前所有打开的窗口的句柄</span></span><br><span class="line">all_handles = driver.window_handles</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.进入注册窗口</span></span><br><span class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> all_handles:</span><br><span class="line">    <span class="keyword">if</span> handle != sreach_windows:</span><br><span class="line">        driver.switch_to.window(handle)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;跳转到注册窗口&#x27;</span>)</span><br><span class="line">        driver.find_element_by_name(<span class="string">&quot;account&quot;</span>).send_keys(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">        driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>).send_keys(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="警告框处理"><a href="#警告框处理" class="headerlink" title="警告框处理"></a>警告框处理</h4><p>​	在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用  switch_to.alert 方法定位到 alert&#x2F;confirm&#x2F;prompt，然后使用text&#x2F;accept&#x2F;dismiss&#x2F;  send_keys等方法进行操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>返回 alert&#x2F;confirm&#x2F;prompt 中的文字信息</td>
</tr>
<tr>
<td>accept()</td>
<td>接受现有警告框</td>
</tr>
<tr>
<td>dismiss()</td>
<td>解散现有警告框</td>
</tr>
<tr>
<td>send_keys(keysToSend)</td>
<td>发送文本至警告框。keysToSend：将文本发送至警告框。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标悬停至“设置”链接</span></span><br><span class="line">link = driver.find_element_by_link_text(<span class="string">&#x27;设置&#x27;</span>)</span><br><span class="line">ActionChains(driver).move_to_element(link).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开搜索设置并点击</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#在此处设置等待2s否则可能报错</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 保存设置</span></span><br><span class="line">driver.find_element_by_class_name(<span class="string">&quot;prefpanelgo&quot;</span>).click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受警告框</span></span><br><span class="line">driver.switch_to.alert.accept()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="下拉框选择操作"><a href="#下拉框选择操作" class="headerlink" title="下拉框选择操作"></a>下拉框选择操作</h4><p>​	导入类</p>
<p><code>from selenium.webdriver.support.select import Select</code></p>
<p>Select类的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>select_by_value(“选择值”)</td>
<td>select标签的value属性的值</td>
</tr>
<tr>
<td>select_by_index(“索引值”)</td>
<td>下拉框的索引</td>
</tr>
<tr>
<td>select_by_visible_testx(“文本值”)</td>
<td>下拉框的文本值</td>
</tr>
</tbody></table>
<p>百度搜索设置的下拉框</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.鼠标悬停至“设置”链接</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&#x27;设置&#x27;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#2.打开搜索设置</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.搜索结果显示条数</span></span><br><span class="line">sel = driver.find_element_by_xpath(<span class="string">&quot;//select[@id=&#x27;nr&#x27;]&quot;</span>)</span><br><span class="line">Select(sel).select_by_value(<span class="string">&#x27;50&#x27;</span>)  <span class="comment"># 显示50条</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>​	对于通过input标签实现的上传功能，可以将其看作是一个输入框，即通过send_keys()指定本地文件路径的方式实现文件上传。</p>
<p>通过send_keys()方法来实现文件上传:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">file_path = <span class="string">&#x27;file:///&#x27;</span> + os.path.abspath(<span class="string">&#x27;upfile.html&#x27;</span>)</span><br><span class="line">driver.get(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位上传按钮，添加本地文件</span></span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;file&quot;</span>).send_keys(<span class="string">&#x27;D:\\upload_file.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h4><p>​	有时候我们需要验证浏览器中cookie是否正确，因为基于真实cookie的测试是无法通过白盒和集成测试进行的。WebDriver提供了操作Cookie的相关方法，可以读取、添加和删除cookie信息。</p>
<p>WebDriver操作cookie的方法:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get_cookies()</td>
<td>获得所有cookie信息</td>
</tr>
<tr>
<td>get_cookie(name)</td>
<td>返回字典的key为“name”的cookie信息</td>
</tr>
<tr>
<td>add_cookie(cookie_dict)</td>
<td>添加cookie。“cookie_dict”指字典对象，必须有name 和value 值</td>
</tr>
<tr>
<td>delete_cookie(name,optionsString)</td>
<td>删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”</td>
</tr>
<tr>
<td>delete_all_cookies()</td>
<td>删除所有cookie信息</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">browser.get(<span class="string">&quot;http://www.youdao.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.打印cookie信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印所有的cookie信息为：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加cookie信息</span></span><br><span class="line"><span class="built_in">dict</span>=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&quot;name&quot;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;Kaina&#x27;</span>&#125;</span><br><span class="line">browser.add_cookie(<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;添加cookie信息为：&#x27;</span>)</span><br><span class="line"><span class="comment">#3.遍历打印cookie信息</span></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#4.删除一个cookie</span></span><br><span class="line">browser.delete_cookie(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除一个cookie&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除所有cookie后：&#x27;</span>)</span><br><span class="line"><span class="comment">#5.删除所有cookie,无需传递参数</span></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h4 id="调用JavaScript代码"><a href="#调用JavaScript代码" class="headerlink" title="调用JavaScript代码"></a>调用JavaScript代码</h4><p>​	虽然WebDriver提供了操作浏览器的前进和后退方法，但对于浏览器滚动条并没有提供相应的操作方法。在这种情况下，就可以借助JavaScript来控制浏览器的滚动条。WebDriver提供了execute_script()方法来执行JavaScript代码。</p>
<p>用于调整浏览器滚动条位置的JavaScript代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!-- window.scrollTo(左边距,上边距); --&gt;</span><br><span class="line">window.scrollTo(<span class="number">0</span>,<span class="number">450</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距。其代码如下：</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.访问百度</span></span><br><span class="line">driver=webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搜索</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.休眠2s目的是获得服务器的响应内容，如果不使用休眠可能报错</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.通过javascript设置浏览器窗口的滚动条位置</span></span><br><span class="line">js=<span class="string">&quot;window.scrollTo(100,450);&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<p>通过浏览器打开百度进行搜索，并且提前通过set_window_size()方法将浏览器窗口设置为固定宽高显示，目的是让窗口出现水平和垂直滚动条。然后通过execute_script()方法执行JavaScripts代码来移动滚动条的位置。<br> 滚动条上下左右滚动代码演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver=webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.set_window_size(<span class="number">400</span>,<span class="number">400</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搜索</span></span><br><span class="line"><span class="comment"># driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)</span></span><br><span class="line"><span class="comment"># driver.find_element_by_id(&quot;su&quot;).click()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.休眠2s目的是获得服务器的响应内容，如果不使用休眠可能报错</span></span><br><span class="line">sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4 滚动左右滚动条---向右</span></span><br><span class="line">js2 = <span class="string">&quot;var q=document.documentElement.scrollLeft=10000&quot;</span></span><br><span class="line">driver.execute_script(js2)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5 滚动左右滚动条---向左</span></span><br><span class="line">js3 = <span class="string">&quot;var q=document.documentElement.scrollLeft=0&quot;</span></span><br><span class="line">driver.execute_script(js3)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6 拖动到滚动条底部---向下</span></span><br><span class="line">js = <span class="string">&quot;var q=document.documentElement.scrollTop=10000&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#7 拖动到滚动条底部---向上</span></span><br><span class="line">js = <span class="string">&quot;var q=document.documentElement.scrollTop=0&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<h4 id="窗口截图"><a href="#窗口截图" class="headerlink" title="窗口截图"></a>窗口截图</h4><p>​	自动化用例是由程序去执行的，因此有时候打印的错误信息并不十分明确。如果在脚本执行出错的时候能对当前窗口截图保存，那么通过图片就可以非常直观地看出出错的原因。WebDriver提供了截图函数get_screenshot_as_file()来截取当前窗口。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get_screenshot_as_file(self, filename)</td>
<td>用于截取当前窗口，并把图片保存到本地</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver =webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>).send_keys(<span class="string">&#x27;selenium&#x27;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>).click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.截取当前窗口，并指定截图图片的保存位置</span></span><br><span class="line">driver.get_screenshot_as_file(<span class="string">&quot;D:\\baidu_img.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="关闭浏览器"><a href="#关闭浏览器" class="headerlink" title="关闭浏览器"></a>关闭浏览器</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>close()</td>
<td>关闭单个窗口</td>
</tr>
<tr>
<td>quit()</td>
<td>关闭所有窗口</td>
</tr>
</tbody></table>
<p>​	</p>
]]></content>
      <categories>
        <category>Python-learn</category>
        <category>Python 库</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>图床搭建与PicGO---typora</title>
    <url>/2023/03/07/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E4%B8%8EPicGO-typora/</url>
    <content><![CDATA[<h1 id="图床搭建与PicGO—typora"><a href="#图床搭建与PicGO—typora" class="headerlink" title="图床搭建与PicGO—typora"></a>图床搭建与PicGO—typora</h1><h2 id="图床选择与注册"><a href="#图床选择与注册" class="headerlink" title="图床选择与注册"></a>图床选择与注册</h2><p>图床选择很多，但是建议选择比较长期还有稳定的图床，当然如果可以免费自然是更好。</p>
<p>我这次选择的是<a target="_blank" rel="noopener" href="https://www.imgurl.org/vip/manage/upload">ImgURL</a></p>
<p>之前用过<a target="_blank" rel="noopener" href="https://sm.ms/">SM.MS</a></p>
<p>两者都好用，后者注册和使用更加方便，初始上传的最大图片限制是5G，但是个人用肯定够了</p>
<span id="more"></span>


<h2 id="PicGO"><a href="#PicGO" class="headerlink" title="PicGO"></a>PicGO</h2><h3 id="ImgURL"><a href="#ImgURL" class="headerlink" title="ImgURL"></a>ImgURL</h3><p>在GitHub的<a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.1">下载界面</a>选择一个比较稳定的版本进行安装，别安装尝鲜版。安装速度可能有点慢，因为是GitHub。自己想办法&#x3D;.&#x3D;</p>
<p>下好以后就绑到你所使用的图床就行，当然前提是你的图床支持PicGO。我使用的ImgURL有很详细的<a target="_blank" rel="noopener" href="https://doc.xiaoz.org/books/imgurl-pro/page/picgo">教程</a>。当然使用可以直接绑定的图床肯定更方便，比如阿里云、腾讯云、SM.MS等</p>
<p>关于插件的下载和SM.MS一样就行，然后根据官方教程绑定PicGO和ImgURL；这里直接看教程就行，很详细了。</p>
<h3 id="SM-MS"><a href="#SM-MS" class="headerlink" title="SM.MS"></a>SM.MS</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133270020">参考文档</a></p>
<p>在安装好PicGO和注册好SM.MS后，使用typora测试了下图片上传，毫无疑问上传失败。因为没有对PicGO进行配置。于是只好去网上找教程。   </p>
<p>首先是PicGO提供的SM.MS有问题，需要下一个插件，叫做<a target="_blank" rel="noopener" href="https://github.com/xlzy520/picgo-plugin-smms-user">smms-user</a>；当然最好是在PicGo.app自己软件里面的插件设置去下载最好—搜索smms-user然后点击安装就行，等待安装完成。<br><img src="https://s2.loli.net/2023/03/07/6nQAoprPjKdBWYX.png" alt="image-20230307142211939"></p>
<p>这里我遇到了第一个坑，就是一直安装不上，然后网上搜索了，关于picgo.app的解决方案真不多，然后我把日志里面的几个报错全去ChatGPT问了下，如下：然后我选择了最粗暴的，重装。遗憾的是，我重装了两次还是有问题，于是便选择使用npm，结果在管理员权限出现了问题，qwq。<br><strong>直接说最后解决方案：重装，然后以管理员权限启动</strong> </p>
<p><img src="https://s2.loli.net/2023/03/07/wVguaZMkWo6RH5N.png" alt="image-20230307163057301"></p>
<p>这次插件成功安装了，接下来要做的就是配置一下插件，在左侧图床设置里面会如下图所示，左键插件右下角设置按钮，然后把从SM.MS获取到的token填进插件的plugin以及uploader中。再把默认图片上传改为SM.MS-登录用户</p>
<p><img src="https://s2.loli.net/2023/03/07/58tXJrFHjnseAC4.png" alt="image-20230307163751194"></p>
<p><img src="https://s2.loli.net/2023/03/07/EMTDwm1gcGUZ3ed.png" alt="image-20230307181803403"></p>
<p>然后再用图片进行测试，发现上传成功，解下来再把typora里的图片上传方式改下。</p>
<h2 id="typora设置"><a href="#typora设置" class="headerlink" title="typora设置"></a>typora设置</h2><p>上传服务设定改一下，路径选择你PicGO的位置。然后点击<strong>验证图片上传选项</strong></p>
<p><img src="https://s2.loli.net/2023/03/07/EagXR9tlN8FnD3M.png" alt="image-20230307182146879"></p>
<p>第二个问题出现了，上传图片失败，我直接进PICGO的日志中把这次上传去找了下问题，结果是typora的图片传不上去了。直接用就行，文档里面图片不受影响。</p>
<p><img src="https://s2.loli.net/2023/03/07/4BEJKOvm7IiWPaS.png" alt="image-20230307182427400"></p>
<p><img src="https://s2.loli.net/2023/03/07/iTlbnIsyOCN9qmS.png" alt="image-20230307182550000"></p>
]]></content>
  </entry>
  <entry>
    <title>Python-OpenCV基础教程</title>
    <url>/2023/03/07/Python-OpenCV%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>前言：OpenCV是为了搞比赛学的，当时目的是为了做喷播机的识别系统，识别可喷区域，掌握基础就行，在学的过程中发现OpenCV入门还是很简单的，而且摄像头玩着还是挺有意思。至于学Python-OpenCV，是因为使用的设备是树莓派，这里就不得不感慨一下，21年那会树莓派4B才600左右，现在已经1200+了，难崩！</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/index.html">OpenCV官方界面</a></li>
</ul>
<span id="more"></span>

<h1 id="OPEN-CV基础"><a href="#OPEN-CV基础" class="headerlink" title="OPEN CV基础"></a>OPEN CV基础</h1><h2 id="什么是图像"><a href="#什么是图像" class="headerlink" title="什么是图像"></a>什么是图像</h2><p>图像是由像素点组成的，像素点的矩阵就组成图像大小</p>
<p>计算机是01编码制，数字图像也是用01来记录信息，一般接触的都是八位数图像，0是最黑，255是最白</p>
<p>像素点：比如说<code>[500,500,3]</code> 就是<code>分别代表h，w，像素通道</code></p>
<h3 id="H-S-V-颜色模型"><a href="#H-S-V-颜色模型" class="headerlink" title="H S V 颜色模型"></a>H S V 颜色模型</h3><p>HSV（Hue Saturation Value）颜色模型是面向用户的</p>
<p>HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。</p>
<p>这个模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）</p>
<h4 id="色调"><a href="#色调" class="headerlink" title="色调"></a>色调</h4><p>用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,紫色为300°；</p>
<h4 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h4><p>饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。</p>
<h4 id="明度"><a href="#明度" class="headerlink" title="明度"></a>明度</h4><p>明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。</p>
<img src="https://bkimg.cdn.bcebos.com/pic/8d5494eef01f3a29fb2420739925bc315d607c9b?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1/format,f_auto" alt="HSV颜色空间模型" style="zoom:150%;" />

<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><h3 id="二值图像"><a href="#二值图像" class="headerlink" title="二值图像"></a>二值图像</h3><p><img src="D:\typora\src\image-20210911131838722.png" alt="二值图像是指：每个像素点均为黑色或者白色的图像。二值图像一般用来描述字符图像，其优点是占用空间少，缺点是，当表示人物，风景的图像时，二值图像只能展示其边缘信息，图像内部的纹理特征表现不明显。这时候要使用纹理特征更为丰富的灰度图像"></p>
<h3 id="灰度图像与彩色图像"><a href="#灰度图像与彩色图像" class="headerlink" title="灰度图像与彩色图像"></a>灰度图像与彩色图像</h3><p>一幅完整的图像，是由红色、绿色、蓝色三个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%9A%E9%81%93">通道</a>组成的。红色、绿色、蓝色三个通道的缩览图都是以<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%81%B0%E5%BA%A6">灰度</a>显示的。用不同的灰度色阶来表示“ 红，绿，蓝”在图像中的比重。通道中的纯白，代表了该色光在此处为最高亮度，亮度级别是255。</p>
<p>通道是整个Photo shop显示图像的基础。色彩的变动，实际上就是间接在对通道灰度图进行调整。通道是Photo shop处理图像的核心部分，所有的色彩调整工具都是围绕在这个核心周围使用的。</p>
<p>在计算机领域中，这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑色与白色两种颜色；灰度图像在黑色与白色之间还有许多级的颜色深度。但是，在数字图像领域之外，“黑白图像”也表示“灰度图像”，例如灰度的照片通常叫做“黑白照片”。在一些关于数字图像的文章中单色图像等同于灰度图像，在另外一些文章中又等同于黑白图像。</p>
<p>我们可以通过下面几种方法，将其转换为灰度：</p>
<p>1.浮点算法：Gray&#x3D;R * 0.3+G * 0.59+B * 0.11</p>
<p>2.整数方法：Gray&#x3D;(R * 30+G * 59+B * 11)&#x2F;100</p>
<p>3.移位方法：Gray &#x3D;(R * 76+G * 151+B * 28)&gt;&gt;8;</p>
<p>4.<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%B3%E5%9D%87%E5%80%BC%E6%B3%95">平均值法</a>：Gray&#x3D;（R+G+B）&#x2F;3;</p>
<p>5.仅取绿色：Gray&#x3D;G；</p>
<p>通过上述任一种方法求得Gray后，将原来的RGB(R,G,B)中的R,G,B统一用Gray替换，形成新的颜色RGB(Gray,Gray,Gray)，用它替换原来的RGB(R,G,B)就是灰度图了。</p>
<p><img src="/typora%5Csrc%5Cimage-20210911131936378.png" alt="image-20210911131936378"></p>
<h2 id="数据读取–图像"><a href="#数据读取–图像" class="headerlink" title="数据读取–图像"></a>数据读取–图像</h2><p><code>cv2.imread</code></p>
<p><code>cv2.IMREAD_COLOR</code>:彩色图像读取   可以使用1 代替</p>
<p><code>cv2.IMREAD_GRAYSCALE</code> ：灰度图像 可以使用0代替</p>
<p><code>cv2.IMREAD_UNCHANGED 包括alpha（透明度）通道的加载图像模式·</code>  可以使用-1代替</p>
<p><code>cv2.waitKey()</code>是让程序暂停的意思，参数是等待时间（毫秒ms）的时间一到，会继续执行接下来的程序，<strong>传入0的话表示一直等待等待期间也可以获取用户的按键输入</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img=cv2.imread(<span class="string">&quot;NV.jpg&quot;</span>,<span class="number">0</span>)<span class="comment">#加载灰度图像</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;image&quot;</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>) </span><br><span class="line"><span class="string">&quot;如果路径有错误，会返回None值，但并不会报错&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以先用<code>cv2.namedWindow()</code>创建一个画面，之后再显示</p>
<p>参数 1 仍然是图片的，参数 2 默认是<code>cv2.WINDOW_AUTOSIZE</code>，表示图片大小图片，也可以设置为<code>cv2.WINDOW_NORMAL</code>，表示图片大小可调整。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先定义窗口，后显示图片</span></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;lena2&#x27;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;lena2&#x27;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h2 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h2><p><code>cv2.imshow(windows_name, image)</code>    用的是B G R通道</p>
<p><code>imshow</code>函数作用是在窗口中显示图像，窗口自动适合于图像大小，我们也可以通过<code>imutils</code>模块调整显示图像的窗口的大小</p>
<p>windows_name： 窗口名称(字符串)<br>image： 图像对象，类型是<code>numpy</code>中的<code>ndarray</code>类型</p>
<p>在这之后需要调用 <code>cv2.waitKey()它的唯一参数是它应该等待用户输入多长时间（以毫秒给图像绘制留下时间，否则窗口会出现无响应的情况，并且图像无法显示出来</code></p>
<p>也就是说<code>cv2,imshow</code>后面必须跟<code>waitKey()</code>否则无法显示</p>
<p>这里可以通过<code>imutils</code>模块改变图像显示大小，下面示例展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>,img) </span><br><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>,imutils.resize(img,<span class="number">800</span>)) <span class="comment">#利用imutils模块调整图片尺寸</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了 <code>opencv</code> 外也可以调用 <code>matplotlib</code>对图像进行展示 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#matplotlib.pyplot  展示</span></span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>])  <span class="comment"># cv2是BGR  而plt是RGB需要换一下通道</span></span><br><span class="line">plt.show()  <span class="comment">#彩色图展示</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\PYTHON\OpenCV\image-20210912141915286.png" alt="image-20210912141915286"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#灰度图展示</span></span><br><span class="line">plt.imshow(img,cmap=plt.cm.gray)</span><br><span class="line">plt.show</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20210912140643353.png"></p>
<h2 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h2><p><code>imwrite 函数保存图像</code></p>
<p><code>cb2.imwrite(image_filename,image)</code></p>
<p>函数参数一： 保存的图像名称(字符串)<br>函数参数二： 图像对象，类型是<code>numpy</code>中的<code>ndarray</code>类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&#x27;img.jpg&#x27;</span>, img)   <span class="comment">#将图像保存成jpg文件</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;img2.png&#x27;</span>, img) <span class="comment">#将图像保存成png文件</span></span><br></pre></td></tr></table></figure>

<h2 id="图像读取显示保存练习"><a href="#图像读取显示保存练习" class="headerlink" title="图像读取显示保存练习"></a>图像读取显示保存练习</h2><ol>
<li><p>打开<code>lena.jpg</code>并显示，如果按下q，就保存图片为<code>&#39;lena_save.bmp&#39;</code>，否则就结束程序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;lena&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># ord()用来获取某个字符的编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):   <span class="comment">#键输入q就会保存</span></span><br><span class="line">    <span class="comment">#cv2.imwrite(&#x27;lena_save.bmp&#x27;, img)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;已保存&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Matplotlib</code> 是 Python 中常用的一个绘图库，</p>
</li>
</ol>
<h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d3/d63/classcv_1_1Mat.html">map对象</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56"><code>cv2.imread()</code></a></li>
<li>[<code>cv2.imshow()</code>(<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563</a>)</li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce"><code>cv2.imwrite()</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b"><code>cv.namedWindow()</code></a></li>
</ul>
<h2 id="窗口销毁函数"><a href="#窗口销毁函数" class="headerlink" title="窗口销毁函数"></a>窗口销毁函数</h2><p>当我们使用<code>imshow</code>函数展示图像时，最后需要在程序中对图像展示窗口进行销毁，否则程序将无法正常终止</p>
<p><code>cv2.destroyWindow(windows_name)</code> 销毁单个特定窗口，参数： 将要销毁的窗口的名字<br><code>cv2.destroyAllWindows() </code>销毁全部窗口，无参数</p>
<p>销毁窗口，不能图片窗口一出现我们就将窗口销毁，这样便没法观看窗口,应该采用以下方式</p>
<p><code>cv2.waitKey(time_of_milliseconds)</code></p>
<p>1.让窗口停留一段时间就销毁</p>
<p>2.接收指令，如接收指定的键盘敲击后结束窗口</p>
<p><code>参数：time_of_milliseconds</code>  大于0，此时的参数表示时间，单位是毫秒，表示等待一定毫秒后自动销毁窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表示等待10秒后，将销毁所有图像</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">10000</span>):</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="comment">#表示等待10秒，将销毁窗口名称为&#x27;image&#x27;的图像窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">10000</span>):</span><br><span class="line">    cv2.destroyWindow(<span class="string">&#x27;image&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>参数小于等于0时： 此时窗口将等待一个键盘指令，接收到指令后就会进行窗口销毁，这个指令是可以自动定义的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#当指定waitKey(0) == 27时当敲击键盘 Esc 时便销毁所有窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="comment">#当接收到键盘敲击A时，便销毁名称为&#x27;origin image&#x27;的图像窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(-<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>):</span><br><span class="line">    cv2.destroyWindow(<span class="string">&#x27;origin image&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="颜色空间装换"><a href="#颜色空间装换" class="headerlink" title="颜色空间装换"></a>颜色空间装换</h2><h3 id="图像色彩空间（color-space）变换函数-cv2-cvtColor"><a href="#图像色彩空间（color-space）变换函数-cv2-cvtColor" class="headerlink" title="*图像色彩空间（color space）变换函数 cv2.cvtColor"></a>*图像色彩空间（color space）变换函数 <code>cv2.cvtColor</code></h3><p><code>cv2.cvtColor(input_image,flag)</code> </p>
<p>参数一： input_image表示将要变换色彩的图像,<code>ndarray</code>对象</p>
<p> 参数二： 表示图像色彩空间变换的类型,常用有两种</p>
<p><code> cv2.COLOR_BGR2GRAY:表示将图像从BGR空间转化成灰度图，最常用</code> </p>
<p><code>cv2.COLOR_BGR2HSV:表示将图像从RGB空间转换到HSV空间</code></p>
<p>如果需要查看flag所有的类型，可以通过以下程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv2) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="built_in">print</span>(flags)</span><br><span class="line"><span class="comment">#共有274种</span></span><br></pre></td></tr></table></figure>

<h2 id="为何总是对灰度图进行处理？"><a href="#为何总是对灰度图进行处理？" class="headerlink" title="为何总是对灰度图进行处理？"></a>为何总是对灰度图进行处理？</h2><p><strong>图像的颜色主要是由于图像受到外界光照影响随之产生的不同颜色信息，同一个背景物的图像在不同光源照射下产生的不同颜色效果的图像，因此在我们做图像特征提取和识别过程时，我们要的是图像的梯度信息，也就是图像的本质内容，而颜色信息会对我们对梯度信息提取造成一定的干扰，因此我们会在做图像特征提取和识别前将图像转化为灰度图，这样同时也降低了处理的数据量并且增强了处理效果。</strong></p>
<h2 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一个长宽分别为w、h的 R G B彩色图像来说，它的每个像素值是由(B、G、R)的一个tuple组成，<code>opencv-python</code>中每个像素三个值的顺序是B、G、R，而对于灰度图像来说，每个像素对应的便只是一个整数，如果要把像素缩放到0、1，则灰度图像就是二值图像，0便是黑色，1便是白色。我们通过下面的例子来理解一下</p>
<p>处理的图像如下<img src="D:\typora\src\NV.jpg" alt="NV"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">rgb_img = cv2.imread(<span class="string">&#x27;E:/pycharm/opencv/new/NV.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rgb_img.shape)  <span class="comment"># (676, 1202, 3)  # h有676个像素点，w有1202个像素点，3就是三通道，也就是说看到的是彩图</span></span><br><span class="line"><span class="built_in">print</span>(rgb_img[<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># [16 11 12]</span></span><br><span class="line"><span class="built_in">print</span>(rgb_img[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]) <span class="comment"># 16</span></span><br><span class="line"></span><br><span class="line">gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)  <span class="comment">#灰度</span></span><br><span class="line"><span class="built_in">print</span>(gray_img.shape) <span class="comment">#(676, 1202)</span></span><br><span class="line"><span class="built_in">print</span>(gray_img[<span class="number">0</span>, <span class="number">0</span>])<span class="comment">#12</span></span><br></pre></td></tr></table></figure>

<p>从以上程序运行结果可以得知，彩色图像的高度height&#x3D;676，宽度&#x3D;1202 ，通道数为3     像素(0,0)的值为（16 11 12）   即 R&#x3D;16 G&#x3D;11  B&#x3D;12 </p>
<p>但是对于灰度图像来说就是单通道的</p>
<p>因此(0, 0, 0)便是代表一个黑色像素，(255, 255, 255)便是代表一个白色像素。这么想，B&#x3D;0, G&#x3D;0,  R&#x3D;0相当于关闭了颜色通道也就相当于无光照进入，所以图像整个是黑的，而(255, 255, 255)即B&#x3D;255, G&#x3D;255, R&#x3D;255，  相当于打开了B、G、R所有通道光线全部进入，因此便是白色。上图的灰度就是12即[12 12 12]</p>
<h3 id="创建一个简单的图"><a href="#创建一个简单的图" class="headerlink" title="创建一个简单的图"></a>创建一个简单的图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">white_img = np.ones((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">white_img = <span class="number">255</span>*white_img</span><br><span class="line">cv2.imshow(<span class="string">&#x27;white_img&#x27;</span>, white_img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210912192702186.png" alt="image-20210912192702186" style="zoom:33%;" />

<p><strong>公共参数：</strong></p>
<p><strong><code>img</code>：表示需要进行绘制的图像对象ndarray</strong><br><strong><code>color</code>：表示绘制几何图形的颜色，采用<code>BGR</code>即上述说的(B、G、R)</strong><br><strong><code>thickness</code>表示绘制几何图形中线的粗细，默认为1，对于圆、椭圆等封闭图像取-1时是填充图形内部</strong><br><strong><code>lineType </code>表示绘制几何图形线的类型，默认8-connected线是光滑的，当取<code>cv2.LINE_AA</code>时线呈现锯齿状</strong></p>
<h4 id="cv2-line-直线绘制函数"><a href="#cv2-line-直线绘制函数" class="headerlink" title="cv2.line 直线绘制函数"></a><code>cv2.line</code> 直线绘制函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.line(image, starting, ending, color, thickness, lineType)</span><br><span class="line"><span class="comment">#starting,ending 分别表示线的起点像素坐标，终点像素坐标</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-rectangle-矩形"><a href="#cv2-rectangle-矩形" class="headerlink" title="cv2.rectangle   矩形"></a><code>cv2.rectangle</code>   矩形</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.rectangle(image, top-left, bottom-right, color, thickness, lineType)</span><br><span class="line"><span class="comment">#top-left , bottom-right 分别表示长方形左上角像素坐标、右下角像素坐标</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-circle-圆"><a href="#cv2-circle-圆" class="headerlink" title="cv2.circle  圆"></a><code>cv2.circle</code>  圆</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.circle(image, center, radius, color, thickness, lineType)</span><br><span class="line"><span class="comment"># center 表示圆的圆心像素坐标</span></span><br><span class="line"><span class="comment"># radius 圆的半径长度</span></span><br><span class="line"><span class="comment">#当thickness=-1时，绘制的圆是实心圆，当thickness&gt;=0时绘制的是空心圆</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-ellipse-椭圆"><a href="#cv2-ellipse-椭圆" class="headerlink" title="cv2.ellipse   椭圆"></a><code>cv2.ellipse </code>  椭圆</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.circle(image, center, (major-axis-length, minor-axis-length), angle, startAngle, endAngle, color, thickness, lineType)</span><br><span class="line"><span class="comment">#当参数thickness = -1 时绘制的是实心椭圆，当thickness &gt;= 0 时绘制的是空心椭圆</span></span><br><span class="line"><span class="comment"># center： 表示椭圆中心像素坐标</span></span><br><span class="line"><span class="comment"># major-axis-length： 表示椭圆的长轴长度</span></span><br><span class="line"><span class="comment"># minor-axis-length： 表示椭圆的短轴长度</span></span><br><span class="line"><span class="comment"># angle： 表示椭圆在逆时针方向旋转的角度</span></span><br><span class="line"><span class="comment"># startAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的起始角度</span></span><br><span class="line"><span class="comment"># endAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的终止时角度</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-polylines-多边形"><a href="#cv2-polylines-多边形" class="headerlink" title="cv2.polylines 多边形"></a><code>cv2.polylines</code> 多边形</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.polylines(image, [point-<span class="built_in">set</span>], flag, color, thickness, lineType)</span><br><span class="line"><span class="comment"># [point-set]： 表示多边形点的集合，如果多边形有m个点，则便是一个m12的数组，表示共m个点</span></span><br><span class="line"><span class="comment"># flag： 当flag = True 时，则多边形是封闭的，当flag = False 时，则多边形只是从第一个到最后一个点连线组成的图像，没有封闭</span></span><br></pre></td></tr></table></figure>

<p>cv2.putText</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = np.ones((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">img = <span class="number">255</span>*img</span><br><span class="line">img = cv2.line(img, (<span class="number">100</span>,<span class="number">100</span>), (<span class="number">400</span>,<span class="number">400</span>),(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</span><br><span class="line">img = cv2.rectangle(img,(<span class="number">200</span>, <span class="number">20</span>),(<span class="number">400</span>,<span class="number">120</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">img = cv2.circle(img,(<span class="number">100</span>,<span class="number">400</span>), <span class="number">50</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">img = cv2.circle(img,(<span class="number">250</span>,<span class="number">400</span>), <span class="number">50</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">0</span>)</span><br><span class="line">img = cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">180</span>,(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">pts = np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line">img = cv2.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210912194703373.png" alt="image-20210912194703373" style="zoom:50%;" />

<h2 id="对图像的简单像素操作"><a href="#对图像的简单像素操作" class="headerlink" title="对图像的简单像素操作"></a>对图像的简单像素操作</h2><p>对于一个图像，每个像素点都有其对应的坐标<code>img[height,width,颜色通道]</code>而对于彩色图像每个像素点都是由[g,b,r]组成的</p>
<ul>
<li><code>img[y,x]</code>获取&#x2F;设置像素点值，<code>img.shape</code>：图片的形状（行数(height)、列数(width)、通道数），：<code>img.dtype</code>图像的数据类型。</li>
<li><code>img[y1:y2,x1:x2]</code>进行ROI截取，<code>cv2.split()/cv2.merge()</code>通道分割&#x2F;合并。更推荐的获取单通道方式：<code>b = img[:, :, 0]</code></li>
</ul>
<h4 id="获取和修改像素点值"><a href="#获取和修改像素点值" class="headerlink" title="获取和修改像素点值"></a>获取和修改像素点值</h4><p>操作以后，计算机内存中img的像素点是改变了 但是因为并没有保存，因此原图是没有更改的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 1.获取像素的值 b g r</span></span><br><span class="line">px = img[<span class="number">100</span>, <span class="number">90</span>]</span><br><span class="line"><span class="built_in">print</span>(px)  <span class="comment"># [103 98 197]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只获取蓝色blue通道的值</span></span><br><span class="line">px_blue = img[<span class="number">100</span>, <span class="number">90</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(px_blue)  <span class="comment"># 103</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改像素的值</span></span><br><span class="line">img[<span class="number">100</span>, <span class="number">90</span>] = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]</span><br><span class="line"><span class="built_in">print</span>(img[<span class="number">100</span>, <span class="number">90</span>])  <span class="comment"># [255 255 255]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.图片形状</span></span><br><span class="line"><span class="built_in">print</span>(img.shape)  <span class="comment"># (263, 247, 3)</span></span><br><span class="line"><span class="comment"># 形状中包括行数、列数和通道数</span></span><br><span class="line">height, width, channels = img.shape</span><br><span class="line"><span class="comment"># img是灰度图的话：height, width = img.shape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总像素数 h*W*通道数</span></span><br><span class="line"><span class="built_in">print</span>(img.size)  <span class="comment"># 263*247*3=194883</span></span><br><span class="line"><span class="comment"># 数据类型</span></span><br><span class="line"><span class="built_in">print</span>(img.dtype)  <span class="comment"># uint8   0-256</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.ROI截取   截取部分图像数据</span></span><br><span class="line">face = img[<span class="number">100</span>:<span class="number">200</span>, <span class="number">115</span>:<span class="number">188</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;face&#x27;</span>, face)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.通道分割与合并</span></span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">img = cv2.merge((b, g, r))</span><br><span class="line"><span class="comment"># 更推荐的获取某一通道方式</span></span><br><span class="line">b = img[:, :, <span class="number">0</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;b&#x27;</span>, b)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="对图像取反"><a href="#对图像取反" class="headerlink" title="对图像取反"></a>对图像取反</h4><p><code>reverse_img = 255 - gray_img  </code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;[[12 14 14 ... 18 21 19]</span></span><br><span class="line"><span class="string"> [11 14 13 ... 23 20 17]</span></span><br><span class="line"><span class="string"> [13 13 13 ... 21 23 20]</span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string"> [20 22 22 ... 31 30 28]</span></span><br><span class="line"><span class="string"> [19 19 22 ... 28 29 29]</span></span><br><span class="line"><span class="string"> [21 19 16 ... 33 30 30]]&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#变成</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[243 241 241 ... 237 234 236]</span></span><br><span class="line"><span class="string"> [244 241 242 ... 232 235 238]</span></span><br><span class="line"><span class="string"> [242 242 242 ... 234 232 235]</span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string"> [235 233 233 ... 224 225 227]</span></span><br><span class="line"><span class="string"> [236 236 233 ... 227 226 226]</span></span><br><span class="line"><span class="string"> [234 236 239 ... 222 225 225]]&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210920180815747.png" alt="image-20210920180815747" style="zoom:50%;" />

<h4 id="对图像像素线性变换"><a href="#对图像像素线性变换" class="headerlink" title="对图像像素线性变换"></a>对图像像素线性变换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gray_img.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(gray_img.shape[<span class="number">1</span>]):</span><br><span class="line">        random_img[i, j] = gray_img[i, j]*<span class="number">1.2</span> <span class="comment">#灰度图所有像素都成了1.2  这里的[i,j]就代表一个一个的像素点</span></span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210920180922849.png" alt="image-20210920180922849" style="zoom:50%;" />

<h4 id="截取部分图像数据-ROI"><a href="#截取部分图像数据-ROI" class="headerlink" title="截取部分图像数据 ROI"></a>截取部分图像数据 ROI</h4><p>学了特征后，就可以自动截取</p>
<p>先了解下这个图像的坐标左上角是原点，x轴与常规相同，y轴朝下  </p>
<p>下例中cat就是对NV这个图片进行切片，h切<code>0:200</code>,w也切<code>0:200</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rgb_img = cv2.imread(<span class="string">&#x27;E:/pycharm/opencv/new/NV.jpg&#x27;</span>)</span><br><span class="line">cat=rgb_img[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">200</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>,rgb_img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20210920184022634.png" alt="截取到的"></p>
<h4 id="颜色通道的分割与合并"><a href="#颜色通道的分割与合并" class="headerlink" title="颜色通道的分割与合并"></a>颜色通道的分割与合并</h4><p>彩色图的<code>BGR</code>三个通道是可以分开单独访问的，可以也。将单独的三个通道合并分类中翻译一副图像分别使用<code>cv2.split()</code>状语从句：<code>cv2.merge()</code></p>
<p>这个效率比较低</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">img = cv2.merge((b, g, r))</span><br></pre></td></tr></table></figure>

<p>用<code>num</code>索引的方法比较简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = img[:, :, <span class="number">0</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;blue&#x27;</span>, b)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="掩膜mask"><a href="#掩膜mask" class="headerlink" title="掩膜mask"></a>掩膜mask</h2><p>物理的角度<br>在半导体制造中，许多芯片工艺步骤采用光刻技术，用于这些步骤的图形“底片”称为掩膜（也称作“掩模”），其作用是：在硅片上选定的区域中对一个不透明的图形模板遮盖，继而下面的腐蚀或扩散将只影响选定的区域以外的区域。<br>图像掩膜与其类似，用选定的图像、图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。</p>
<p> 数字图像处理中,图像掩模主要用于：</p>
<p>①提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。</p>
<p>②屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。</p>
<p>③结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。</p>
<p>④特殊形状图像的制作。用选定的图像、图形或物体,对待处理的图像(全部或局部)进行遮挡,来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e1eee55fde4d735986d0108c6004db3a.png" alt="这里写图片描述"></p>
<h2 id="图像基本运算"><a href="#图像基本运算" class="headerlink" title="图像基本运算"></a>图像基本运算</h2><p>bitwise_and、bitwise_or、bitwise_xor、bitwise_not这四个按位操作函数。</p>
<p>bitwise_and是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&amp;1&#x3D;1，1&amp;0&#x3D;0，0&amp;1&#x3D;0，0&amp;0&#x3D;0<br>bitwise_or是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1&#x3D;1，1|0&#x3D;0，0|1&#x3D;0，0|0&#x3D;0<br>bitwise_xor是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1 ^ 1&#x3D;0,1 ^ 0&#x3D;1,0 ^ 1&#x3D;1,0^0&#x3D;0<br>bitwise_not是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，~ 1 &#x3D;0，~0&#x3D;1</p>
<h2 id="颜色分离"><a href="#颜色分离" class="headerlink" title="颜色分离"></a>颜色分离</h2><p>对于一张彩色图像，若有需要对某种颜色进行分离出来，在 OpenCV 中需要使用到 cv2.inRange 和 cv2.bitwise_and 两个函数。</p>
<p>首先介绍一下两个函数：</p>
<p>1、cv2.inRange</p>
<p>cv2.inRange(src, lowerb, upperb)<br>用以确认元素值是否介于某个区域<br>inRange 函数需要设定三个参数，其中 src 指源图像；lowerb 指图像中低于 lowerb 的值，其所对应的图像值将为 0；upperb指图像中高于 upperb 的值，图像值变为 0 。换言之，源图像中仅有图像值介于 lowerb 和 upperb 之间的值才不为 0 ，且值将变成 255<br>2、cv2.bitwise_and</p>
<p>cv2.bitwise_and(src1, scr2, mask&#x3D;)<br>用于对两个数组（图像也是数组）对位元素进行运算，即计算机中的“和”运算。以二进制为例，1&amp;1输出 1 ，1&amp;0、0&amp;1、0&amp;0则均输出 0 。<br>bitwise_and 函数需要设定三个参数，其中 src1 指第一个数组（源图像），src2 指第二个数组（源图像），mask&#x3D; 用于指定具体的掩模（常以 0 和 1 元素为主，用以输出具体的元素），应设为 uint8 格式，即单通道的 8-bit 的数组。另外，mask 参数为可选参数，可省略。<br>言归正传，以某张船的照片为例，分离出图像的蓝色。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块，输出原图</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">ship_rgb = cv2.imread(<span class="string">&#x27;ship.jpg&#x27;</span>)[:,:,::-<span class="number">1</span>]</span><br><span class="line">plt.imshow(ship_rgb)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210302103907984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0OTU2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像转为HSV格式进而得到mask，HSV分别代表色相(Hue)、饱和度(Saturation)、明度(Value)</span></span><br><span class="line">ship_hsv = cv2.cvtColor(ship_rgb, cv2.COLOR_RGB2HSV)</span><br><span class="line"><span class="comment"># 设定参数lowerb、upperb</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">lowerb = np.array([<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>])</span><br><span class="line">upperb = np.array([<span class="number">140</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line"><span class="comment"># 获取mask</span></span><br><span class="line">mask = cv2.inRange(ship_hsv, lowerb, upperb)</span><br><span class="line"><span class="comment"># 利用mask进行颜色分离</span></span><br><span class="line">ship_masked = cv2.bitwise_and(ship_bgr,ship_bgr,mask=mask)</span><br><span class="line"><span class="comment"># 转回RGB格式</span></span><br><span class="line">ship_blue = cv2.cvtColor(ship_masked,cv2.COLOR_BGR2RGB)</span><br></pre></td></tr></table></figure>



<h2 id="拍摄与本地视频的读取与处理："><a href="#拍摄与本地视频的读取与处理：" class="headerlink" title="拍摄与本地视频的读取与处理："></a>拍摄与本地视频的读取与处理：</h2><p><code>cv2.ViedoCapture()</code>可以捕获摄像头，用数字来控制不同的设备，例如0,1</p>
<p>如果是视频文件直接指定路径就行</p>
<p><code>cap = cv2.VideoCapture()</code>创建视频捕捉对象<strong>cap</strong><br>其中参数可以可以写本地路径或者打开设备摄像头。<br><code>ret, frame = cap.read()；</code><br>1）ret,frame是获read()方法的两个返回值，其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就False；<br>2）frame就是每一帧的图像，是个三维矩阵（按帧读取）。<br>这里需要注意的是由于<code>read</code>是一帧一帧读取，要么读取一张操作一张，要么将所有的帧全部存到list中统一处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">vc=cv2.VideoCapture(<span class="string">&#x27;C:/Users/XYT/Desktop/机械创新设计大赛/Modern Forest Planting Machine   Amazing life  #1 00_00_00-00_01_36.mp4&#x27;</span>)   <span class="comment">#视频文件指定路径  记得改斜杠</span></span><br><span class="line"><span class="keyword">if</span> vc.isOpened(): </span><br><span class="line">    <span class="built_in">open</span>,frame=vc.read()  <span class="comment"># read() 返回两个值，其中open是布尔类型，就是如果你读取到了视频中的这一帧，那么就返回True 反之。frame接收到的是这一帧图像</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">open</span>=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">open</span>:  <span class="comment">#利用循环一帧一帧的播放视频，每次获取一帧</span></span><br><span class="line">    ret,frame=vc.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) <span class="comment">#将这一帧图像转换成灰度图</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;gray_img&#x27;</span>,gray)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">10</span>)&amp;<span class="number">0xFF</span>==<span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">vc.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="获取摄像头属性（视频捕捉属性）cap-get-propId"><a href="#获取摄像头属性（视频捕捉属性）cap-get-propId" class="headerlink" title="获取摄像头属性（视频捕捉属性）cap.get(propId)"></a>获取摄像头属性（视频捕捉属性）<code>cap.get(propId)</code></h4><p>通过<code>cap.get(propId)</code>采集摄像头的一些属性，比如设备属性的属性，可以参考从0~18的属性</p>
<p>也可以使用<code>cap.set(propId,value)</code>来修改属性值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取捕获的分辨率</span></span><br><span class="line"><span class="comment"># propId可以直接写数字，也可以用OpenCV的符号表示</span></span><br><span class="line">width, height = capture.get(<span class="number">3</span>), capture.get(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(width, height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以原分辨率的一倍来捕获</span></span><br><span class="line">capture.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, width * <span class="number">2</span>)</span><br><span class="line">capture.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, height * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;import cv2</span></span><br><span class="line"><span class="string">cap=cv2.VideoCapture(0)</span></span><br><span class="line"><span class="string">print(cap.get(3),cap.get(4))  # 640 489   分别代表h， 与 w</span></span><br><span class="line"><span class="string">cap.set(3,cap.get(3)*2)</span></span><br><span class="line"><span class="string">cap.set(4,cap.get(4)*2)</span></span><br><span class="line"><span class="string">if cap.isOpened():</span></span><br><span class="line"><span class="string">    ret,frame=cap.read()</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&#x27;摄像头未正常开启&#x27;)</span></span><br><span class="line"><span class="string">while ret :</span></span><br><span class="line"><span class="string">    ret,frame=cap.read()</span></span><br><span class="line"><span class="string">    if frame is None:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">    if ret == True:</span></span><br><span class="line"><span class="string">        cv2.imshow(&#x27;cap_mp4&#x27;,frame)</span></span><br><span class="line"><span class="string">        if cv2.waitKey(25) == ord(&#x27;s&#x27;):</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">cap.release()</span></span><br><span class="line"><span class="string">cv2.destroyAllWindows()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<pre><code>&#39;[VideoCaptureProperties](https://docs.opencv.org/4.0.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d)&#39; 
</code></pre>
<table>
<thead>
<tr>
<th align="left"><code>CAP_PROP_POS_MSEC Python：cv.CAP_PROP_POS_MSEC</code></th>
<th>0</th>
<th>以毫秒为单位的视频文件的当前位置。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CAP_PROP_POS_FRAMES Python：cv.CAP_PROP_POS_FRAMES</code></td>
<td>1</td>
<td>下一个要解码&#x2F;捕获的帧的基于 0 的索引。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_POS_AVI_RATIO Python：cv.CAP_PROP_POS_AVI_RATIO</code></td>
<td>2</td>
<td>视频文件的相对位置：0&#x3D;影片开头，1&#x3D;影片结尾。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_WIDTH Python：cv.CAP_PROP_FRAME_WIDTH</code></td>
<td>3</td>
<td>视频流中帧的宽度。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_HEIGHT Python：cv.CAP_PROP_FRAME_HEIGHT</code></td>
<td>4</td>
<td>视频流中帧的高度。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FPS Python：cv.CAP_PROP_FPS</code></td>
<td>5</td>
<td>帧率。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FOURCC Python：cv.CAP_PROP_FOURCC</code></td>
<td>6</td>
<td>编解码器的 4 字符代码。见<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html#afec93f94dc6c0b3e28f4dd153bc5a7f0">VideoWriter::fourcc</a>。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_COUNT Python：cv.CAP_PROP_FRAME_COUNT</code></td>
<td>7</td>
<td>视频文件中的帧数。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FORMAT Python：cv.CAP_PROP_FORMAT</code></td>
<td>8</td>
<td><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html#a9ac7f4b1cdfe624663478568486e6712">VideoCapture::retrieve()</a>返回的 Mat 对象的格式。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_MODE Python：cv.CAP_PROP_MODE</code></td>
<td>9</td>
<td>指示当前捕获模式的后端特定值。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_BRIGHTNESS Python：cv.CAP_PROP_BRIGHTNESS</code></td>
<td>10</td>
<td>图像的亮度（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_CONTRAST Python：cv.CAP_PROP_CONTRAST</code></td>
<td>11</td>
<td>图像对比度（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_SATURATION Python：cv.CAP_PROP_SATURATION</code></td>
<td>12</td>
<td>图像的饱和度（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_HUE Python：cv.CAP_PROP_HUE</code></td>
<td>13</td>
<td>图像的色调（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_GAIN Python：cv.CAP_PROP_GAIN</code></td>
<td>14</td>
<td>图像增益（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_EXPOSURE Python：cv.CAP_PROP_EXPOSURE</code></td>
<td>15</td>
<td>曝光（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_CONVERT_RGB Python：cv.CAP_PROP_CONVERT_RGB</code></td>
<td>16</td>
<td>指示图像是否应转换为 RGB 的布尔标志。</td>
</tr>
</tbody></table>
<p>注：部分摄像头设置经验等参数时会被禁用，因为它们有固定的大小支持，一般可以在摄像头的资料页中找到。</p>
<h4 id="录制并保存视频-VideoWriter"><a href="#录制并保存视频-VideoWriter" class="headerlink" title="录制并保存视频 VideoWriter"></a>录制并保存视频 <code>VideoWriter</code></h4><p>之前我们用的是<code>cv2.imwrite()</code>保存图片，要保存视频，我们需要创建一个<code>VideoWriter</code>对象，需要给它保存四个参数：</p>
<ul>
<li>输出的文件名，如’output.avi’</li>
<li>编码方式四<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin">CC</a>码</li>
<li>帧率<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/FPS/3227416">FPS</a></li>
<li>要保存大小 (h,w)</li>
</ul>
<p><code>FourCC</code>是指定视频编码方式的四字节码，所有的编码可参考<a target="_blank" rel="noopener" href="http://www.fourcc.org/codecs.php">Video Codecs</a>。如<code>MJPG</code>编码可以这样写：</p>
<p><code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code></p>
<p>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编码方式并创建VideoWriter对象</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;MJPG&#x27;</span>)</span><br><span class="line">outfile = cv2.VideoWriter(<span class="string">&#x27;output.avi&#x27;</span>, fourcc, <span class="number">55</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(capture.isOpened()):</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        outfile.write(frame)  <span class="comment"># 写入文件</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="练习：实现一个可以选择播放播放的属性"><a href="#练习：实现一个可以选择播放播放的属性" class="headerlink" title="练习：实现一个可以选择播放播放的属性"></a>练习：实现一个可以选择播放播放的属性</h4><p><code>cv2.createTrackbar(&#39;R&#39;,&#39;image&#39;,0,255,call_back)</code></p>
<p>创建一个轨迹栏并将其附加到指定的窗口</p>
<p>参数</p>
<p>滑动条名称</p>
<p>所在窗口名称</p>
<p>当前的值</p>
<p>最大值</p>
<p>回调函数名称，回调函数默认有一个表示当前值的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">track_back</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    ### 回调函数，x表示滑块的位置</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 更改视频的帧位置 cv.CAP_PROP_POS_FRAME是下一个要捕获的帧的基于0的索引</span></span><br><span class="line">    capture.<span class="built_in">set</span>(cv2.CAP_PROP_POS_FRAMES, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;window&#x27;</span>)</span><br><span class="line"></span><br><span class="line">capture = cv2.VideoCapture(<span class="string">&#x27;./demo_video.mp4&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取视频总共多少帧</span></span><br><span class="line">frames = capture.get(cv2.CAP_PROP_FRAME_COUNT)</span><br><span class="line"><span class="comment"># 创建滑动条</span></span><br><span class="line">cv2.createTrackbar(<span class="string">&#x27;process&#x27;</span>, <span class="string">&#x27;window&#x27;</span>, <span class="number">1</span>, <span class="built_in">int</span>(frames), track_back)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(capture.isOpened()):</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;window&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h2><h3 id="固定图像阈值处理-threshold"><a href="#固定图像阈值处理-threshold" class="headerlink" title="固定图像阈值处理 threshold"></a>固定图像阈值处理 threshold</h3><p><code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code></p>
<p>scr: 输入需要处理的原图，只能输入单通道图像，一般是灰度图</p>
<p>dst:输出图</p>
<p>thresh:设置的阈值</p>
<p><code>maxval</code>:对于<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code>阈值方法用的最大阈值，一般为255</p>
<p>type:阈值的方式，主要有5种，详情可见：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576">ThresholdTypes</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#五种不同的阈值方法</span></span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  <span class="comment">#大于阈值127的部分区最大值255也就是白色，小于127部分取0 也就是黑色</span></span><br><span class="line">ret, th2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)<span class="comment">#与THRESH_BINARY 结果相反</span></span><br><span class="line">ret, th3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC) <span class="comment">#所有大于127的就取127在这里进行截断， 而小于的部分不进行改变</span></span><br><span class="line">ret, th4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO) <span class="comment">#大于127的部分保持不变，而其他部分都变为黑色</span></span><br><span class="line">ret, th5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)  <span class="comment">#反转</span></span><br></pre></td></tr></table></figure>

<h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><h2 id="卷积基础–图形边框"><a href="#卷积基础–图形边框" class="headerlink" title="卷积基础–图形边框"></a>卷积基础–图形边框</h2><h3 id="二维卷积："><a href="#二维卷积：" class="headerlink" title="二维卷积："></a>二维卷积：</h3><p><img src="http://cos.codec.wang/cv2_understand_convolution.jpg" alt="img"></p>
<p>卷积就是循环对<strong>图像跟一个核逐个元素相乘再求和得到另外一副图像的操作</strong>，比如结果图中第一个元素5是由原图中3×3的区域与3×3的核逐个元素相乘再相加：</p>
<p>算完之后，整个框再往右移一步继续计算，横向计算完后，再往下移一步继续计算……网上有一副很经典的动态图，方便我们理解卷积：</p>
<p><img src="http://cos.codec.wang/cv2_understand_cnn.gif" alt="img"></p>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫填充padding</strong>。</p>
<blockquote>
<p>事实上，原图为n×n，卷积核为f×f，最终结果图大小为**(n-f+1) × (n-f+1)。**</p>
</blockquote>
<p><img src="http://cos.codec.wang/cv2_understand_padding.jpg" alt="img"></p>
<p>那么扩展的这一层应该填充什么值呢？<code>OpenCV</code>中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现，一起来看看。</p>
<h4 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h4><p><code>cv2.copyMakeBorder()</code>用来给图片添加边框，它有下面几个参数：</p>
<ul>
<li>src：要处理的原图</li>
<li>top, bottom, left, right：上下左右要扩展的像素数( 相应方向上的边框宽度 )</li>
<li>**<code>borderType</code>**：边框类型，这个就是需要关注的填充方式，详情请参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5"> BorderTypes </a>   下图中第二个镜面反射是默认的边框类型</li>
<li><img src="D:\typora\src\image-20211015211738420.png" alt="image-20211015211738420"></li>
</ul>
<p>其中默认方式和固定值方式最常用，我们详细说明一下：</p>
<h4 id="固定值填充"><a href="#固定值填充" class="headerlink" title="固定值填充"></a>固定值填充</h4><p>顾名思义，<code>cv2.BORDER_CONSTANT</code>这种方式就是边框都填充成一个固定的值，比如下面的程序都填充0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;6_by_6.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定值边框，统一都填充0也称为zero padding</span></span><br><span class="line">cons = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_CONSTANT, value=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(cons)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_zero_padding_output.jpg" alt="img"></p>
<h3 id="默认边框类型"><a href="#默认边框类型" class="headerlink" title="默认边框类型"></a>默认边框类型</h3><p>默认边框<code>cv2.BORDER_DEFAULT</code>其实是取镜像对称的像素填充，比较拗口，一步步解释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_DEFAULT)</span><br><span class="line"><span class="built_in">print</span>(default)</span><br></pre></td></tr></table></figure>

<p>首先进行上下填充，填充成与原图像边界对称的值，如下图：</p>
<p><img src="http://cos.codec.wang/cv2_up_down_padding_first.jpg" alt="img"></p>
<p>同理再进行左右两边的填充，最后把四个顶点补充上就好了：</p>
<p><img src="http://cos.codec.wang/cv2_right_left_padding_second2.jpg" alt="img"></p>
<blockquote>
<p>经验之谈：一般情况下默认方式更加合理，因为边界的像素值更加接近。具体应视场合而定。</p>
</blockquote>
<h3 id="OpenCV进行卷积"><a href="#OpenCV进行卷积" class="headerlink" title="OpenCV进行卷积"></a><code>OpenCV</code>进行卷积</h3><p><code>OpenCV</code>中用<code>cv2.filter2D()</code>实现卷积操作，比如我们的核是下面这样（3×3区域像素的和除以10）：</p>
<p><img src="D:\typora\src\image-20211015212412694.png" alt="image-20211015212412694"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.float32) / <span class="number">10</span></span><br><span class="line"><span class="comment"># 卷积操作，-1表示通道数与原图相同</span></span><br><span class="line">dst = cv2.filter2D(img, -<span class="number">1</span>, kernel)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_convolution_kernel_3_3.jpg" alt="img"></p>
<p>可以看到这个核对图像进行了模糊处理，这是卷积的众多功能之一。</p>
<h2 id="图像平滑操作"><a href="#图像平滑操作" class="headerlink" title="图像平滑操作"></a>图像平滑操作</h2><h3 id="滤波与模糊"><a href="#滤波与模糊" class="headerlink" title="滤波与模糊"></a>滤波与模糊</h3><p>关于滤波和模糊:</p>
<ul>
<li>它们都属于卷积，不同滤波方法之间只是卷积核不同（对线性滤波而言）</li>
<li>低通滤波器是模糊，高通滤波器是锐化</li>
</ul>
<p><strong>低通滤波器</strong>就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。<strong>高通滤波器</strong>则反之，用来增强图像边缘，进行锐化处理。</p>
<blockquote>
<p>常见噪声有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958?fr=aladdin">椒盐噪声</a>(脉冲噪声)和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。</p>
</blockquote>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p>
<p><img src="D:\typora\src\image-20211016133058089.png" alt="image-20211016133058089"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">blur = cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 均值模糊</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有的滤波函数都有一个可选参数borderType，这个参数就是<em><strong>卷积基础–图形边框</strong></em>中所说的边框填充方式。</p>
</blockquote>
<h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p>
<p><img src="D:\typora\src\image-20211016133349723.png" alt="image-20211016133349723"></p>
<p>用<code>cv2.boxFilter()</code>函数实现，当可选参数normalize为True的时候，方框滤波就是均值滤波，上式中的a就等于1&#x2F;9；normalize为False的时候，a&#x3D;1，相当于求区域内的像素和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span></span><br><span class="line">blur = cv2.boxFilter(img, -<span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>), normalize=<span class="literal">True</span>) <span class="comment">#卷积操作 -1表示通道数与原图相同</span></span><br></pre></td></tr></table></figure>

<h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小，还记得标准正态分布的曲线吗？</p>
<p><img src="http://cos.codec.wang/cv2_gaussian_kernel_function_theory.jpg" alt="img"></p>
<p>显然这种处理元素间权值的方式更加合理一些。图像是2维的，所以我们需要使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gaussian_filter">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核（具体原理和卷积核生成方式请参考文末的<a target="_blank" rel="noopener" href="http://codec.wang/#/">番外小篇</a>）：</p>
<p><img src="D:\typora\src\image-20211016133709083.png" alt="image-20211016133709083"></p>
<p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;gaussian_noise.bmp&#x27;</span>)</span><br><span class="line"><span class="comment"># 均值滤波vs高斯滤波</span></span><br><span class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></span><br><span class="line">gaussian = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">1</span>)  <span class="comment"># 高斯滤波</span></span><br></pre></td></tr></table></figure>

<p>参数3 σx值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p>
<p><img src="http://cos.codec.wang/cv2_gaussian_vs_average.jpg" alt="img"></p>
<h4 id="高斯滤波卷积核-OpenCV中7-7以下的卷积核是算好了的。"><a href="#高斯滤波卷积核-OpenCV中7-7以下的卷积核是算好了的。" class="headerlink" title="高斯滤波卷积核   OpenCV中7*7以下的卷积核是算好了的。"></a>高斯滤波卷积核   OpenCV中7*7以下的卷积核是算好了的。</h4><p><img src="D:\typora\src\image-20211016134947978.png" alt="image-20211016134947978"></p>
<p>我们可以用<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv2.getGaussianKernel(ksize,sigma)</code></a>来生成一维卷积核：</p>
<ul>
<li>sigma&lt;&#x3D;0时，<code>sigma=0.3*((ksize-1)*0.5 - 1) + 0.8</code></li>
<li>sigma&gt;0时，sigma&#x3D;sigma</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(cv2.getGaussianKernel(<span class="number">3</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 结果：[[0.25][0.5][0.25]]</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20211016135226745.png" alt="image-20211016135226745"></p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>中值又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，<strong>适用于去除椒盐噪声和斑点噪声</strong>。中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p>
<p>比如下面这张斑点噪声图，用中值滤波显然更好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;salt_noise.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 均值滤波vs中值滤波</span></span><br><span class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></span><br><span class="line">median = cv2.medianBlur(img, <span class="number">5</span>)  <span class="comment"># 中值滤波</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_median_vs_average.jpg" alt="img"></p>
<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2">双边滤波</a>。用<code>cv2.bilateralFilter()</code>函数实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 双边滤波vs高斯滤波</span></span><br><span class="line">gau = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)  <span class="comment"># 高斯滤波</span></span><br><span class="line">blur = cv2.bilateralFilter(img, <span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>)  <span class="comment"># 双边滤波</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_bilateral_vs_gaussian.jpg" alt="img"></p>
<p><strong>双边滤波明显保留了更多边缘信息，但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code>。</li>
<li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code>。</li>
<li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code>。</li>
<li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。</li>
<li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37">cv2.blur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3">cv2.boxFilter()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1">cv2.GaussianBlur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa">cv2.getGaussianKernel()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9">cv2.medianBlur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed">cv2.bilateralFilter()</a></li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html">图像平滑处理</a></li>
</ul>
<h2 id="图像梯度（理论基础）："><a href="#图像梯度（理论基础）：" class="headerlink" title="图像梯度（理论基础）："></a>图像梯度（理论基础）：</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2334bee37de5">https://www.jianshu.com/p/2334bee37de5</a></p>
<p>低通滤波器是模糊，高通滤波器是锐化</p>
<h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YZ4y1s7Ra?from=search&amp;seid=18409194473369625551&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1YZ4y1s7Ra?from=search&amp;seid=18409194473369625551&amp;spm_id_from=333.337.0.0</a></p>
<p>水平方向的边界  也就是左右的；  就是假如这里是边界，那么P5的左右两边他P4和P6的值会相差很大，然后P5的值算出来就会很明显，如果P4和P6很接近那么计算的P5就会很接近0  没那么明显  然后就可以根据这个计算出图像的边界。</p>
<img src="D:\typora\src\image-20211016140326016.png" alt="image-20211016140326016" style="zoom:50%;" />

<p>同理。垂直方向就是吧卷积核改一下</p>
<img src="D:\typora\src\image-20211016140853557.png" alt="image-20211016140853557" style="zoom:50%;" />

<p>垂直方向和水平方向的梯度都计算出来了  那么图像的梯度就可以计算</p>
<img src="D:\typora\src\image-20211016140939825.png" alt="image-20211016140939825" style="zoom:50%;" />

<img src="D:\typora\src\image-20211016141022498.png" alt="image-20211016141022498" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#代码表示</span></span><br><span class="line">sobelx = cv2.Sobel(img, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算x方向</span></span><br><span class="line">sobely = cv2.Sobel(img, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算y方向</span></span><br></pre></td></tr></table></figure>



<h3 id="Laplacian（拉普拉斯）算子"><a href="#Laplacian（拉普拉斯）算子" class="headerlink" title="Laplacian（拉普拉斯）算子"></a><img src="http://cos.codec.wang/cv2_horizen_vertical_edge_detection.jpg" alt="垂直和水平边界下降">Laplacian（拉普拉斯）算子</h3><p>拉普拉斯算子类似于<strong>二阶</strong>Sobel导数。</p>
<p>在OpenCV中通过调用sobel算子来计算拉普拉斯算子，使用公式：</p>
<p><img src="D:\typora\src\image-20211016142426256.png" alt="image-20211016142426256"></p>
<p>使用卷积核：</p>
<p><img src="D:\typora\src\image-20211016142440656.png" alt="image-20211016142440656"></p>
<p>就算出来就是上下左右全部减一次中间，然后再相加</p>
<img src="D:\typora\src\image-20211017095425784.png" alt="image-20211017095425784"  />

<p>然后判断的依据和sobel算子类似，值小那就是梯度值小，非边界，值大就是梯度大，是边界</p>
<p>OpenCV中直接使用<code>cv2.Laplacian()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(img, -<span class="number">1</span>)  <span class="comment"># 使用Laplacian算子</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_laplacian.jpg" alt="img"></p>
<p>也可如此理解，更加深入一点。</p>
<p><img src="D:\typora\src\image-20211016142242956.png" alt="image-20211016142242956"></p>
<h2 id="边缘检测："><a href="#边缘检测：" class="headerlink" title="边缘检测："></a>边缘检测：</h2><p>cv2.Canny()</p>
<p>Canny边缘检测方法被誉为边缘检测的最优方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(img, <span class="number">30</span>, <span class="number">70</span>)  <span class="comment"># canny边缘检测</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;canny&#x27;</span>, np.hstack((img, edges)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>之前采用低通滤波模糊图片，也就是去噪点，而想要得到图像边缘就需要用到高通滤波，锐化图像</p>
<h3 id="Canny边界检测"><a href="#Canny边界检测" class="headerlink" title="Canny边界检测"></a>Canny边界检测</h3><ol>
<li><p>使用5×5高斯排除噪音：</p>
<p>边缘操作本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理</p>
</li>
<li><p>计算图像梯度方向</p>
</li>
</ol>
<p>   使用sobel算子计算两个方向上的GX和GY，然后算出梯度方向：</p>
<p>   <img src="D:\typora\src\image-20211017100727722.png" alt="image-20211017100727722"></p>
<ol start="3">
<li>取局部极大值：</li>
</ol>
<p>   梯度已经有了轮廓，但为了进一步筛选，可以从（0°&#x2F;45°&#x2F;90°&#x2F;135°）这四个角度方向上取局部极大值</p>
<p>   比如A点在45°方向上大于B&#x2F;C点，那就保留A然后将B&#x2F;C设置为0.</p>
<p>   <img src="http://cos.codec.wang/cv2_understand_canny_direction.jpg" alt="img"></p>
<ol start="4">
<li>滞后阈值：Canny推荐的高低阈值比在2:1到3:1之间。</li>
</ol>
<p>   经过前面三步，就只剩下0和可能的边缘梯度值了，为了最终确定下来，需要设定高低阈值：</p>
<pre><code>   像素点的值大于最高阈值,那肯定是边缘
   
   像素值小于最低阈值那肯定不是边缘
   
   像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘
</code></pre>
<p>   AC是边缘   B不是。</p>
<p>   <img src="http://cos.codec.wang/cv2_understand_canny_max_min_val.jpg" alt="img"></p>
<h3 id="先阈值分割后检测"><a href="#先阈值分割后检测" class="headerlink" title="先阈值分割后检测"></a>先阈值分割后检测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)  <span class="comment">#自适应阈值分割 python中如果某个值不用，可以用下划线代替</span></span><br><span class="line">edges = cv2.Canny(thresh, <span class="number">30</span>, <span class="number">70</span>)  <span class="comment">#边缘检测，上阈值70 ，下阈值30</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;canny&#x27;</span>, np.hstack((img, thresh, edges)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_canny_edge_detection_threshold.jpg"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#滑动条调节阈值，理解高地阈值效果：</span><br><span class="line">import cv2</span><br><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">def track<span class="constructor">_back(<span class="params">x</span>)</span>:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">ori_img=cv2.imread(&#x27;<span class="module-access"><span class="module"><span class="identifier">NV</span>.</span></span>jpg&#x27;,<span class="number">0</span>)</span><br><span class="line">cv2.named<span class="constructor">Window(&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">cv2.create<span class="constructor">Trackbar(&#x27;<span class="params">upper</span>&#x27;,&#x27;<span class="params">window</span>&#x27;,100,255,<span class="params">track_back</span>)</span></span><br><span class="line">cv2.create<span class="constructor">Trackbar(&#x27;<span class="params">low</span>&#x27;,&#x27;<span class="params">window</span>&#x27;,200,255,<span class="params">track_back</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(True):</span><br><span class="line">    upper_= cv2.get<span class="constructor">TrackbarPos(&#x27;<span class="params">upper</span>&#x27;,&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">    low_=cv2.get<span class="constructor">TrackbarPos(&#x27;<span class="params">low</span>&#x27;,&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">    edges=cv2.<span class="constructor">Canny(<span class="params">ori_img</span>,<span class="params">low_</span>,<span class="params">upper_</span>)</span></span><br><span class="line">    cv2.imshow(&#x27;window&#x27;,edges)</span><br><span class="line">    <span class="keyword">if</span> cv2.wait<span class="constructor">Key(30)</span>==ord(<span class="character">&#x27;q&#x27;</span>):  #键入 q 关闭窗口   记得一定不要设置为<span class="number">0</span>  无限等待  不然循环无法进行下去</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h2 id="腐蚀与膨胀"><a href="#腐蚀与膨胀" class="headerlink" title="腐蚀与膨胀"></a>腐蚀与膨胀</h2><p>形态学操作  腐蚀  膨胀  开运算和闭运算</p>
<p>cv2.erode()  cv2.dilate()  cv2.morpho;ogyEx()</p>
<h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p><code>cv2.erode(src, kernel, iteration)</code></p>
<p>参数说明：</p>
<p>src表示图片 </p>
<p>kernel指腐蚀操作的内核，默认是一个简单的3X3矩阵，我们也可以利用<code>getStructuringElement（）</code>函数指明它的形状</p>
<p>iterations指的是腐蚀次数，省略是默认为1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;j.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8) <span class="comment">#指定核大小</span></span><br><span class="line">erosion = cv2.erode(img, kernel)  <span class="comment"># 腐蚀</span></span><br></pre></td></tr></table></figure>

<p>这个核也叫结构元素，因为形态学操作其实也是应用卷积来实现的结构元素可以是矩形&#x2F;椭圆&#x2F;十字形，可以用。<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 矩形结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 椭圆结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 十字形结构</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_morphological_struct_element.jpg" alt="img"></p>
<h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p><code>dilate()</code>可以对输入图像用特定结构元素进行膨胀操作，该结构元素确定膨胀操作过程中的邻域的形状，各点像素值将被替换为对应邻域上的最大值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dilation = cv2.dilate(img, kernel)  <span class="comment"># 膨胀</span></span><br></pre></td></tr></table></figure>

<h3 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h3><p><code>cv2.morphologyEx()</code></p>
<p>先腐蚀后膨胀开运算 </p>
<p>作用：分开物体，分解区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 定义结构元素  矩形结构</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;j_noise_out.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></span><br></pre></td></tr></table></figure>

<h3 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h3><p>先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除&#x2F;“闭合”物体里面的小黑洞，所以叫闭运算）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;j_noise_in.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul>
<li>形态学梯度：膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;school.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_morphological_gradient.jpg" alt="img"></p>
<ul>
<li>顶帽：原图减去开运算后的图：<code>src - opening</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<ul>
<li>黑帽：闭运算后的图减去原图：<code>closing - src</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>

<h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p><img src="https://img-blog.csdnimg.cn/20200622220127452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5czQzMDM4MV8x,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>轮廓是连续的，边缘并不全都连续</strong>（下图）。其实<strong>边缘主要是作为图像的特征使用</strong>，比如可以用边缘特征可以区分脸和手，而<strong>轮廓主要用来分析物体的形态</strong>，比如物体的周长和面积等，可以说边缘包括轮廓。</p>
<p><img src="http://cos.codec.wang/cv2_understand_contours.jpg" alt="边缘和轮廓的区别"></p>
<p><strong>寻找轮廓一般用于二值化图像，所以通常会使用阈值分割或者Canny边缘检测得到二值图</strong></p>
<p>寻找轮廓是针对白色物体的，一定要保证物体是白色，背景是黑色，不然很多人在新专辑轮廓是会找到图片最外面的一个框</p>
<h3 id="第一步：寻找轮廓"><a href="#第一步：寻找轮廓" class="headerlink" title="第一步：寻找轮廓"></a>第一步：寻找轮廓</h3><p>使用<code>cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]])</code></p>
<p>返回两个值：contours;hierarchy</p>
<p>参数：</p>
<p>image 表示寻找轮廓的图像</p>
<p>mode表示轮廓的检索模式，有四种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.RETR_EXTERNAL   <span class="comment">#表示只检测外轮廓</span></span><br><span class="line">cv2.RETR_LIST   <span class="comment">#检测的轮廓不建立等级关系</span></span><br><span class="line">cv2.RETR_CCOMP <span class="comment">#建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。</span></span><br><span class="line">cv2.RETR_TREE   <span class="comment">#建立一个等级树结构的轮廓</span></span><br></pre></td></tr></table></figure>
<p>method是轮廓的近似方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.CHAIN_APPROX_NONE<span class="comment">#存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即max（abs（x1-x2），abs（y2-y1））==1</span></span><br><span class="line">cv2.CHAIN_APPROX_SIMPLE<span class="comment">#压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息</span></span><br><span class="line">cv2.CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain <span class="comment">#近似算法</span></span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line">img = cv2.imread(<span class="string">&#x27;D:\\test\\contour.jpg&#x27;</span>)</span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"> </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  <span class="comment">#寻找轮廓</span></span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>原图：<img src="https://img-blog.csdn.net/20131030153346984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VubnkyMDM4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:33%;" />检测图<img src="https://img-blog.csdn.net/20131030153441656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VubnkyMDM4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:33%;" /></p>
<p><strong>findcontours函数会“原地”修改输入的图像</strong>  也就是说原图被改变了</p>
<p><strong>contour返回值</strong><br>    cv2.findContours()函数首先返回一个list，list中每个元素都是图像中的一个轮廓，用numpy中的ndarray表示。这个概念非常重要。在下面drawContours中会看见。通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(contours))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(contours[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours))</span><br><span class="line"><span class="comment">#可以验证上述信息。会看到本例中有两条轮廓，一个是五角星的，一个是矩形的。每个轮廓是一个ndarray，每个ndarray是轮廓上的点的集合。</span></span><br><span class="line">由于我们知道返回的轮廓有两个，因此可通过</span><br><span class="line">cv2.drawContours(img,contours,<span class="number">0</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line">和</span><br><span class="line">cv2.drawContours(img,contours,<span class="number">1</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">分别绘制两个轮廓，关于该参数可参见下面一节的内容。同时通过</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours[<span class="number">1</span>]))</span><br><span class="line">输出两个轮廓中存储的点的个数，可以看到，第一个轮廓中只有<span class="number">4</span>个元素，这是因为轮廓中并不是存储轮廓上所有的点，而是只存储可以用直线描述轮廓的点的个数，比如一个“正立”的矩形，只需<span class="number">4</span>个顶点就能描述轮廓了。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>hierarchy返回值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">此外，该函数还可返回一个可选的hiararchy结果，这是一个ndarray，其中的元素个数和轮廓个数相同，每个轮廓contours[i]对应<span class="number">4</span>个hierarchy元素hierarchy[i][<span class="number">0</span>] ~hierarchy[i][<span class="number">3</span>]，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，则该值为负数。</span><br><span class="line">通过</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(hierarchy))</span><br><span class="line"><span class="built_in">print</span> (hierarchy.ndim)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span> (hierarchy[<span class="number">0</span>].ndim)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span> (hierarchy.shape) <span class="comment"># (1, 2, 4)</span></span><br></pre></td></tr></table></figure>

<h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><img src="D:\typora\src\image-20211018233258899.png" alt="image-20211018233258899" style="zoom:150%;" />

<p><code>cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset ]]]]])</code></p>
<p>第一个参数是指明在哪幅图像上绘制轮廓；<br>第二个参数是轮廓本身，在Python中是一个list。<br>第三个参数指定绘制轮廓list中的哪条轮廓，如果是-1，则绘制其中的所有轮廓。</p>
<p>后面的参数很简单。其中thickness表明轮廓线的宽度，如果是-1（cv2.FILLED），则为填充模式。绘制参数将在以后独立详细介绍。</p>
<h2 id="轮廓层级"><a href="#轮廓层级" class="headerlink" title="轮廓层级"></a>轮廓层级</h2><p>很多情况下，图像中的形状之间是有关联的</p>
<p><img src="http://cos.codec.wang/cv2_understand_hierarchy.jpg" alt="img"></p>
<p>图中总共有8条轮廓，2和2a分别表示外层和里层的轮廓，3和3a也是一样。从图中看得出来：</p>
<ul>
<li>轮廓0&#x2F;1&#x2F;2是最外层的轮廓，我们可以说它们处于同一轮廓等级：0级</li>
<li>轮廓2a是轮廓2的子轮廓，反过来说2是2a的父轮廓，轮廓2a算一个等级：1级</li>
<li><strong>同样3是2a的子轮廓，轮廓3处于一个等级：2级</strong></li>
<li>类似的，3a是3的子轮廓</li>
</ul>
<p>这里面OpenCV关注的就是两个概念：<strong>同一轮廓等级</strong>和<strong>轮廓间的子属关系</strong>。</p>
<h3 id="OpenCV中轮廓等级的表示"><a href="#OpenCV中轮廓等级的表示" class="headerlink" title="OpenCV中轮廓等级的表示"></a>OpenCV中轮廓等级的表示</h3><p>如果我们打印出<code>cv2.findContours()</code>函数的返回值hierarchy，会发现它是一个包含4个值的数组：**[Next, Previous, First Child, Parent]**</p>
<ul>
<li><em>Next：与当前轮廓处于同一层级的下一条轮廓</em></li>
</ul>
<p>举例来说，前面图中跟0处于同一层级的下一条轮廓是1，所以Next&#x3D;1；同理，对轮廓1来说，Next&#x3D;2；<em>那么没有与它同一层级的轮廓的下一条轮廓了时，此时Next&#x3D;-1。</em></p>
<ul>
<li><em>Previous：与当前轮廓处于同一层级的上一条轮廓</em></li>
</ul>
<p>跟前面一样，对于轮廓1来说，Previous&#x3D;0；对于轮廓2，Previous&#x3D;1；对于轮廓1，没有上一条轮廓了，所以Previous&#x3D;-1。</p>
<ul>
<li><em>First Child：当前轮廓的第一条子轮廓</em></li>
</ul>
<p>比如对于轮廓2，第一条子轮廓就是轮廓2a，所以First Child&#x3D;2a；对轮廓3a，First Child&#x3D;4。</p>
<ul>
<li><em>Parent：当前轮廓的父轮廓</em></li>
</ul>
<p>比如2a的父轮廓是2，Parent&#x3D;2；轮廓2没有父轮廓，所以Parent&#x3D;-1。</p>
<p>下面我们通过代码验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.读入图片</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;hierarchy.jpg&#x27;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, thresh = cv2.threshold(img_gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.寻找轮廓</span></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.绘制轮廓</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(contours),hierarchy)  <span class="comment"># 8条</span></span><br><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)  <span class="comment">#画出所有的轮廓  红色线条</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经验之谈：OpenCV中找到的轮廓序号跟前面讲的不同噢，如下图：</p>
</blockquote>
<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_TREE.jpg" alt="img"></p>
<p>现在既然我们了解了层级的概念，那么类似cv2.RETR_TREE的轮廓寻找方式又是啥意思呢？</p>
<h3 id="轮廓寻找方式"><a href="#轮廓寻找方式" class="headerlink" title="轮廓寻找方式"></a>轮廓寻找方式</h3><p>OpenCV中有四种轮廓寻找方式<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71">RetrievalModes</a>，下面分别来看下：</p>
<h3 id="1-RETR-LIST"><a href="#1-RETR-LIST" class="headerlink" title="1. RETR_LIST"></a>1. RETR_LIST</h3><p>这是最简单的一种寻找方式，它不建立轮廓间的子属关系，也就是所有轮廓都属于同一层级。这样，hierarchy中的后两个值[First Child, Parent]都为-1。比如同样的图，我们使用cv2.RETR_LIST来寻找轮廓：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, _, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(hierarchy)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">3</span>  <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">2</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">5</span>  <span class="number">3</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">4</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">7</span>  <span class="number">5</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">6</span> -<span class="number">1</span> -<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>

<p>因为没有从属关系，所以轮廓0的下一条是1，1的下一条是2……</p>
<blockquote>
<p>经验之谈：<strong>如果你不需要轮廓层级信息的话，cv2.RETR_LIST更推荐使用，因为性能更好。</strong></p>
</blockquote>
<h3 id="2-RETR-TREE"><a href="#2-RETR-TREE" class="headerlink" title="2. RETR_TREE"></a>2. RETR_TREE</h3><p>cv2.RETR_TREE就是之前我们一直在使用的方式，它会完整建立轮廓的层级从属关系，前面已经详细说明过了。</p>
<h3 id="3-RETR-EXTERNAL"><a href="#3-RETR-EXTERNAL" class="headerlink" title="3. RETR_EXTERNAL"></a>3. RETR_EXTERNAL</h3><p>这种方式只寻找最高层级的轮廓，也就是它只会找到前面我们所说的3条0级轮廓：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(contours), hierarchy, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_EXTERNAL.jpg" alt="img"></p>
<h3 id="4-RETR-CCOMP"><a href="#4-RETR-CCOMP" class="headerlink" title="4. RETR_CCOMP"></a>4. RETR_CCOMP</h3><p>相比之下cv2.RETR_CCOMP比较难理解，但其实也很简单：它把所有的轮廓只分为2个层级，不是外层的就是里层的。结合代码和图片，我们来理解下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(hierarchy)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">1</span>  <span class="number">3</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">2</span>  <span class="number">5</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>  <span class="number">4</span>]</span><br><span class="line">  [ <span class="number">7</span>  <span class="number">4</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">6</span> -<span class="number">1</span> -<span class="number">1</span>]]]Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_CCOMP.jpg" alt="img"></p>
<blockquote>
<p>注意：使用这个参数找到的轮廓序号与之前不同。</p>
</blockquote>
<p>图中括号里面1代表外层轮廓，2代表里层轮廓。比如说对于轮廓2，Next就是4，Previous是1，它有里层的轮廓3，所以First Child&#x3D;3，但因为只有两个层级，它本身就是外层轮廓，所以Parent&#x3D;-1。大家可以针对其他的轮廓自己验证一下。</p>
<h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><img src="http://cos.codec.wang/cv2_min_rect_rect_bounding.jpg" alt="img" style="zoom:50%;" />

<p>在计算轮廓特征前，先寻找轮廓</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以数字3的轮廓为例</span></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="http://cos.codec.wang/cv2_31_handwriting_sample.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshLEold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以数字3的轮廓为例</span></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>为了便于绘制，我们创建出两幅彩色图，并把轮廓画在第一幅图上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</span><br><span class="line">img_color2 = np.copy(img_color1)</span><br><span class="line">cv2.drawContours(img_color1, [cnt], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)  <span class="comment"># 4386.5</span></span><br></pre></td></tr></table></figure>

<p>注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。</p>
<blockquote>
<p>如果统计二值图中像素点个数，应尽量避免循环，**可以使用<code>cv2.countNonZero()</code>**，更加高效。</p>
</blockquote>
<h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">perimeter = cv2.arcLength(cnt, <span class="literal">True</span>)  <span class="comment"># 585.7</span></span><br></pre></td></tr></table></figure>

<p>参数2表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是True。</p>
<h3 id="图像矩"><a href="#图像矩" class="headerlink" title="图像矩"></a>图像矩</h3><p>矩可以理解为图像的各类几何特征，详情请参考：[<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Image_moment">Image Moments</a>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = cv2.moments(cnt)</span><br></pre></td></tr></table></figure>

<p>M中包含了很多轮廓的特征信息，比如M[‘m00’]表示轮廓面积，与前面<code>cv2.contourArea()</code>计算结果是一样的。质心也可以用它来算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cx, cy = M[<span class="string">&#x27;m10&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>], M[<span class="string">&#x27;m01&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>]  <span class="comment"># (205, 281)</span></span><br></pre></td></tr></table></figure>

<h3 id="外接矩形"><a href="#外接矩形" class="headerlink" title="外接矩形"></a>外接矩形</h3><p>形状的外接矩形有两种，如下图，绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转：</p>
<p><img src="http://cos.codec.wang/cv2_min_rect_rect_bounding.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)  <span class="comment"># 外接矩形</span></span><br><span class="line">cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)Copy to clipboardErrorCopied</span><br><span class="line">rect = cv2.minAreaRect(cnt)  <span class="comment"># 最小外接矩形</span></span><br><span class="line">box = np.int0(cv2.boxPoints(rect))  <span class="comment"># 矩形的四个角点取整</span></span><br><span class="line">cv2.drawContours(img_color1, [box], <span class="number">0</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>其中np.int0(x)是把x取整的操作，比如377.93就会变成377，也可以用x.astype(np.int)。</p>
<h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>外接圆跟外接矩形一样，找到一个能包围物体的最小圆：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(x, y), radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">(x, y, radius) = np.int0((x, y, radius))  <span class="comment"># 圆心和半径取整</span></span><br><span class="line">cv2.circle(img_color2, (x, y), radius, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_min_enclosing_circle.jpg" alt="img"></p>
<h3 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h3><p>我们可以用得到的轮廓拟合出一个椭圆：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ellipse = cv2.fitEllipse(cnt)</span><br><span class="line">cv2.ellipse(img_color2, ellipse, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_fitting_ellipse.jpg" alt="img"></p>
<h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回<strong>值越小，越相似</strong>。先读入下面这张图片：</p>
<p><img src="http://cos.codec.wang/cv2_match_shape_shapes.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;shapes.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)  <span class="comment"># 用于绘制的彩色图</span></span><br></pre></td></tr></table></figure>

<p>图中有3条轮廓，我们用A&#x2F;B&#x2F;C表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cnt_a, cnt_b, cnt_c = contours[<span class="number">0</span>], contours[<span class="number">1</span>], contours[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_b, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.0</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 2.17e-05</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_a, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.418</span></span><br></pre></td></tr></table></figure>

<p>可以看到BC相似程度比AB高很多，并且图形的旋转或缩放并没有影响。其中，参数3是匹配方法，详情可参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f">ShapeMatchModes</a>，参数4是OpenCV的预留参数，暂时没有实现，可以不用理会。</p>
<p>形状匹配是通过图像的Hu矩来实现的(<code>cv2.HuMoments()</code>)，大家如果感兴趣，可以参考：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Image_moment#Rotation_invariant_moments">Hu-Moments</a></p>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p><img src="http://cos.codec.wang/cv2_understand_histogram.jpg" alt="img"></p>
<ul>
<li>计算并绘制直方图</li>
<li>（自适应）直方图均衡化</li>
<li>OpenCV函数：<code>cv2.calcHist()</code>, <code>cv2.equalizeHist()</code></li>
</ul>
<h3 id="啥叫直方图"><a href="#啥叫直方图" class="headerlink" title="啥叫直方图"></a>啥叫直方图</h3><p>简单来说，直方图就是图像中每个像素值的个数统计，比如说一副灰度图中像素值为0的有多少个，1的有多少个……:</p>
<p><img src="http://cos.codec.wang/cv2_understand_histogram.jpg" alt="img"></p>
<p>在计算直方图之前，有几个术语先来了解一下：</p>
<ul>
<li>dims: 要计算的通道数，对于灰度图dims&#x3D;1，普通彩色图dims&#x3D;3</li>
<li>range: 要计算的像素值范围，一般为[0,256)</li>
<li>bins: 子区段数目，如果我们统计0<code>~</code>255每个像素值，bins&#x3D;256；如果划分区间，比如0<code>~</code>15, 16<code>~</code>31…240<code>~</code>255这样16个区间，bins&#x3D;16</li>
</ul>
<h3 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h3><p>OpenCV和Numpy中都提供了计算直方图的函数，我们对比下它们的性能。</p>
<h4 id="OpenCV中直方图计算"><a href="#OpenCV中直方图计算" class="headerlink" title="OpenCV中直方图计算"></a>OpenCV中直方图计算</h4><p>使用<code>cv2.calcHist(images, channels, mask, histSize, ranges)</code>计算，其中：</p>
<ul>
<li>参数1：要计算的原图，以方括号的传入，如：[img]</li>
<li>参数2：类似前面提到的dims，<strong>灰度图写[0]就行，彩色图B&#x2F;G&#x2F;R分别传入[0]&#x2F;[1]&#x2F;[2]</strong></li>
<li>参数3（mask）：要计算的区域，计算整幅图的话，写None</li>
<li>参数4：前面提到的bins</li>
<li>参数5：前面提到的range</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;hist.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.025288 s</span></span><br></pre></td></tr></table></figure>

<h3 id="计算部分图像直方图"><a href="#计算部分图像直方图" class="headerlink" title="计算部分图像直方图"></a>计算部分图像直方图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=cv2.imread(<span class="string">&#x27;hist.jpg&#x27;</span>,<span class="number">0</span>)  <span class="comment"># (1024,683)</span></span><br><span class="line">mask=np.zeros(img.shape,dtype=np.uint8)</span><br><span class="line">mask[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">200</span>]=<span class="number">255</span></span><br><span class="line">hist=cv2.calcHist([img],[<span class="number">0</span>],mask,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20211026210142552.png" alt="image-20211026210142552" style="zoom:50%;" /><img src="D:\typora\src\image-20211026210157181.png" alt="image-20211026210157181" style="zoom:50%;" /></p>
<h4 id="Numpy中直方图计算"><a href="#Numpy中直方图计算" class="headerlink" title="Numpy中直方图计算"></a>Numpy中直方图计算</h4><p>也可用Numpy的函数计算，其中<a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html">ravel()</a>函数将二维矩阵展平变成一维数组，之前有提到过：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hist, bins = np.histogram(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.020628 s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经验之谈：Numpy中还有一种更高效的方式：（还记得怎么评估性能吗：代码性能优化]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hist = np.bincount(img.ravel(), minlength=<span class="number">256</span>)  <span class="comment"># 性能：0.003163 s</span></span><br></pre></td></tr></table></figure>

<p>计算出直方图之后，怎么把它画出来呢？</p>
<h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><p>其实Matplotlib自带了一个计算并绘制直方图的功能，不需要用到上面的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>当然，也可以用前面计算出来的结果绘制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_calc_draw_histogram.jpg" alt="img"></p>
<p>从直方图上可以看到图片的大部分区域集中在150偏白的附近，这其实并不是很好的效果，下面我们来看看如何改善它。</p>
<blockquote>
<p>使用OpenCV的画线功能也可以画直方图，不过太麻烦了</p>
</blockquote>
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。其实从观感上就可以发现，前面那幅图对比度不高，偏灰白。对均衡化算法感兴趣的同学可参考：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96">维基百科：直方图均衡化</a></p>
<p><img src="http://cos.codec.wang/cv2_understand_histogram_equalization.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br></pre></td></tr></table></figure>

<p>OpenCV中用<code>cv2.equalizeHist()</code>实现均衡化。我们把两张图片并排显示，对比一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;equalization&#x27;</span>, np.hstack((img, equ)))  <span class="comment"># 并排显示</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_before_after_equalization.jpg" alt="img"></p>
<p><img src="http://cos.codec.wang/cv2_before_after_equalization_histogram.jpg" alt="均衡化前后的直方图对比"></p>
<p>可以看到均衡化后图片的亮度和对比度效果明显好于原图。</p>
<h3 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h3><p>不难看出来，直方图均衡化是应用于整幅图片的，会有什么问题呢？看下图：</p>
<p><img src="http://cos.codec.wang/cv2_understand_adaptive_histogram.jpg" alt="img"></p>
<p>很明显，因为全局调整亮度和对比度的原因，脸部太亮，大部分细节都丢失了。</p>
<p>自适应均衡化就是用来解决这一问题的：它在每一个小区域内（默认8×8）进行直方图均衡化。当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制，所以这个算法全称叫：<strong>对比度受限的自适应直方图均衡化</strong>CLAHE(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization">Contrast Limited Adaptive Histogram Equalization</a>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自适应均衡化，参数可选</span></span><br><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">cl1 = clahe.apply(img)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_adaptive_histogram.jpg" alt="img"></p>
<h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><p>[模板匹配]: <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D">https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D</a>	“模板匹配”</p>
<p>用来在大图中找小图，也就是说在一副图像中寻找另外一张模板图像的位置</p>
<img src="http://cos.codec.wang/cv2_understand_template_matching.jpg" alt="img" style="zoom:50%;" />

<p>用<code>cv2.matchTemplate()</code>实现模板匹配。首先我们来读入图片和模板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;face.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]  <span class="comment"># rows-&gt;h, cols-&gt;</span></span><br></pre></td></tr></table></figure>

<p>匹配函数返回的是一副灰度图，最白的地方表示最大的匹配。使用<code>cv2.minMaxLoc()</code>函数可以得到最大匹配值的坐标，以这个点为左上角角点，模板的宽和高画矩形就是匹配的位置了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span></span><br><span class="line">res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF)</span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line"></span><br><span class="line">left_top = max_loc  <span class="comment"># 左上角</span></span><br><span class="line">right_bottom = (left_top[<span class="number">0</span>] + w, left_top[<span class="number">1</span>] + h)  <span class="comment"># 右下角</span></span><br><span class="line">cv2.rectangle(img, left_top, right_bottom, <span class="number">255</span>, <span class="number">2</span>)  <span class="comment"># 画出矩形位置</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_ccoeff_matching_template.jpg" alt="img"></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>这部分可看可不看，不太理解也没关系，还记得前面的方法吗？不懂得就划掉(✿◕‿◕✿)</p>
</blockquote>
<p>模板匹配的原理其实很简单，就是不断地在原图中移动模板图像去比较，有6种不同的比较方法，详情可参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d">TemplateMatchModes</a></p>
<ul>
<li>平方差匹配CV_TM_SQDIFF：用两者的平方差来匹配，最好的匹配值为0</li>
<li>归一化平方差匹配CV_TM_SQDIFF_NORMED</li>
<li>相关匹配CV_TM_CCORR：用两者的乘积匹配，数值越大表明匹配程度越好</li>
<li>归一化相关匹配CV_TM_CCORR_NORMED</li>
<li>相关系数匹配CV_TM_CCOEFF：用两者的相关系数匹配，1表示完美的匹配，-1表示最差的匹配</li>
<li>归一化相关系数匹配CV_TM_CCOEFF_NORMED</li>
</ul>
<p>归一化的意思就是将值统一到0~1，这些方法的对比代码可到<a target="_blank" rel="noopener" href="http://codec.wang/#/">源码处</a>查看。模板匹配也是应用卷积来实现的：假设原图大小为W×H，模板图大小为w×h，那么生成图大小是(W-w+1)×(H-h+1)，生成图中的每个像素值表示原图与模板的匹配程度。</p>
<h3 id="匹配多个物体"><a href="#匹配多个物体" class="headerlink" title="匹配多个物体"></a>匹配多个物体</h3><p>前面我们是找最大匹配的点，所以只能匹配一次。我们可以设定一个匹配阈值来匹配多次：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.读入原图和模板</span></span><br><span class="line">img_rgb = cv2.imread(<span class="string">&#x27;mario.jpg&#x27;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;mario_coin.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.标准相关模板匹配</span></span><br><span class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = <span class="number">0.8</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.这边是Python/Numpy的知识，后面解释</span></span><br><span class="line">loc = np.where(res &gt;= threshold)  <span class="comment"># 匹配程度大于%80的坐标y,x</span></span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):  <span class="comment"># *号表示可选参数</span></span><br><span class="line">    right_bottom = (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h)</span><br><span class="line">    cv2.rectangle(img_rgb, pt, right_bottom, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_template_matching_multi.jpg" alt="img"></p>
<p>第3步有几个Python&#x2F;Numpy的重要知识，来大致看下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html">np.where()</a>在这里返回res中值大于0.8的所有坐标，如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(np.where(x &gt; <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果(先y坐标，再x坐标)：(array([2, 2, 2]), array([0, 1, 2]))</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_np_where_function.jpg" alt="img"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/functions.html#zip">zip()</a>函数，功能强大到难以解释，举个简单例子就知道了：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(x, y)))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br></pre></td></tr></table></figure>

<p>这样大家就能理解前面代码的用法了吧：因为loc是先y坐标再x坐标，所以用loc[::-1]翻转一下，然后再用zip函数拼接在一起。</p>
<h2 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h2><p><img src="http://cos.codec.wang/cv2_understand_hough_transform.jpg" alt="img"></p>
<p>学习使用霍夫变换识别出图像中的直线和圆。图片等可到文末引用处下载。</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>理解霍夫变换的实现</li>
<li>分别使用霍夫线变换和圆变换检测图像中的直线和圆</li>
<li>OpenCV函数：<code>cv2.HoughLines()</code>, <code>cv2.HoughLinesP()</code>, <code>cv2.HoughCircles()</code></li>
</ul>
<h3 id="理解霍夫变换"><a href="#理解霍夫变换" class="headerlink" title="理解霍夫变换"></a>理解霍夫变换</h3><p>霍夫变换常用来在图像中提取直线和圆等几何形状，我来做个简易的解释：</p>
<p><img src="http://cos.codec.wang/cv2_understand_hough_transform.jpg" alt="img"></p>
<p>学过几何的都知道，直线可以分别用直角坐标系和极坐标系来表示：</p>
<p><img src="http://cos.codec.wang/cv2_line_expression_in_coordinate.jpg" alt="img"></p>
<p>那么经过某个点(x0,y0)的所有直线都可以用这个式子来表示：</p>
<p>r_\theta&#x3D;x_0\cdot\cos \theta+y_0\cdot\sin \thetarθ&#x3D;x0⋅cosθ+y0⋅sinθ</p>
<p>也就是说每一个(r,θ)都表示一条经过(x0,y0)直线，那么同一条直线上的点必然会有同样的(r,θ)。如果将某个点所有的(r,θ)绘制成下面的曲线，那么同一条直线上的点的(r,θ)曲线会相交于一点：</p>
<p><img src="http://cos.codec.wang/cv2_curve_of_r_theta.jpg" alt="img"></p>
<p>OpenCV中首先计算(r,θ) 累加数，累加数超过一定值后就认为在同一直线上。</p>
<h3 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h3><p>OpenCV中用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的(r,θ)数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.加载图片，转为二值图</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;shapes.jpg&#x27;</span>)</span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.霍夫直线变换</span></span><br><span class="line">lines = cv2.HoughLines(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure>

<p>函数中：</p>
<ul>
<li>参数1：要检测的二值图（一般是阈值分割或边缘检测后的图）</li>
<li>参数2：距离r的精度，值越大，考虑越多的线</li>
<li>参数3：角度θ的精度，值越小，考虑越多的线</li>
<li>参数4：累加数阈值，值越小，考虑越多的线</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.将检测的线画出来（注意是极坐标噢）</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    rho, theta = line[<span class="number">0</span>]</span><br><span class="line">    a = np.cos(theta)</span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a * rho</span><br><span class="line">    y0 = b * rho</span><br><span class="line">    x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (-b))</span><br><span class="line">    y1 = <span class="built_in">int</span>(y0 + <span class="number">1000</span> * (a))</span><br><span class="line">    x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (-b))</span><br><span class="line">    y2 = <span class="built_in">int</span>(y0 - <span class="number">1000</span> * (a))</span><br><span class="line"></span><br><span class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hough_line_function.jpg" alt="img"></p>
<h3 id="统计概率霍夫直线变换"><a href="#统计概率霍夫直线变换" class="headerlink" title="统计概率霍夫直线变换"></a>统计概率霍夫直线变换</h3><p>前面的方法又称为标准霍夫变换，它会计算图像中的每一个点，计算量比较大，另外它得到的是整一条线（r和θ），并不知道原图中直线的端点。所以提出了统计概率霍夫直线变换(Probabilistic Hough Transform)，是一种改进的霍夫变换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line"><span class="comment"># 3.统计概率霍夫线变换</span></span><br><span class="line">lines = cv2.HoughLinesP(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>,</span><br><span class="line">                        minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>前面几个参数跟之前的一样，有两个可选参数：</p>
<ul>
<li><code>minLineLength</code>：最短长度阈值，比这个长度短的线会被排除</li>
<li><code>maxLineGap</code>：同一直线两点之间的最大距离</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.将检测的线画出来</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1, y1, x2, y2 = line[<span class="number">0</span>]</span><br><span class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure>

<p><code>cv2.LINE_AA</code>在之前绘图功能中讲解过，表示抗锯齿线型。</p>
<p><img src="http://cos.codec.wang/cv2_hough_lines_p_function.jpg" alt="img"></p>
<h3 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h3><p>霍夫圆变换跟直线变换类似，只不过线是用(r,θ)表示，圆是用(x_center,y_center,r)来表示，从二维变成了三维，数据量变大了很多；所以一般使用霍夫梯度法减少计算量，对该算法感兴趣的同学可参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circle_Hough_Transform">Circle Hough Transform</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line"><span class="comment"># 2.霍夫圆变换</span></span><br><span class="line">circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">20</span>, param2=<span class="number">30</span>)</span><br><span class="line">circles = np.int0(np.around(circles))</span><br></pre></td></tr></table></figure>



<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h1>]]></content>
      <categories>
        <category>Python-learn - Python 库</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>视觉识别</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
