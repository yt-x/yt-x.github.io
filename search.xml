<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023:蓦然回首</title>
    <url>/2024/01/01/2023-%E8%93%A6%E7%84%B6%E5%9B%9E%E9%A6%96/</url>
    <content><![CDATA[<h1 id="2023：蓦然回首"><a href="#2023：蓦然回首" class="headerlink" title="2023：蓦然回首"></a>2023：蓦然回首</h1><p>今年有很多想说的，但其实没有太多表达的欲望，表达欲最近真的很低，取而代之的内耗则是愈加强烈。</p>
<p>自己一直在和自己争吵。</p>
<p>思来想去，回首仔细捋捋还是有话可说，也算挺好。</p>
<p>此时，正在听 Merry Christmas Mr.Lawrence 与 如愿。</p>
<span id="more"></span>

<h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><p>若让我再次选择，自然还是想留在那个此时银杏树叶漫布的校园。但现实便是离开考场我便知道要步入社会，年初做的准备自然也是就业的准备。</p>
<p>机械学子是不愁工作机会的，哪怕就业形势确实严峻，但本科毕业找工作并没有那么的举步维艰，但是寻找一份称心如意的工作则是由选择与运气共同决定的。</p>
<p>毕业季并没有什么不一样，忙着玩耍，忙着在最后匆匆赶毕业设计，忙着学自己喜欢的看自己想看的，似乎匆匆就到了拍毕业照的时刻。终究要一步一步，目送四年朝夕相处的兄弟远去，距离远的尚不知下次何时可见，是否物是人非？四年班长，若无感情自然是无稽之谈，那段时间回想起来仍然有些怅然若失。</p>
<p>好在大部分人应该有再见之日，山水有相逢，离别后便是再见，所幸所幸。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>“层楼终究误少年，自由早晚乱余生”</p>
<p>择业而就，这个择真的很关键，简单来说，图啥 — 钱？热爱？自由？方便？</p>
<p>当初择业图的便是钱多且假期长。我太避重就轻，将未来，将生活，理想化。</p>
<p>钱多嘛？尚可尚可，发展前景确实不错—倘若坚持干下去，孜孜不倦，薪资看上去可以比互联网行业部分中厂了。</p>
<p>自由否？表面自由，假期确实长，但是东拼西凑，加之零零碎碎交织下来自然感受不一样。但比之996自然好上太多了，客观事实如此。</p>
<p>热爱否？自然是否，此前我对其一无所知，热爱的却又未鼓起勇气追寻。</p>
<p>我不喜欢现在的工作，但这份工作也许很不错，同事很好，领导很好，氛围很好。</p>
<p>但我似乎错估了我对于自己能接受的所付出代价的承受能力，我以为我可以接受倒班—毕竟大学熬夜似乎不成问题，我以为我可以接受休息时间孜孜不倦的学习—毕竟我是终生学习观的拥簇。</p>
<p>但事实便是，我不能，倒班两周我便精神萎靡，心态沉闷，至于身体抵抗力之类的问题，已前往医院接受检查，目前只是小肾结石。物理上来说似乎尚可？更不要说学习，从当初渴望世界风光的青年，到如今足不出户的青年，细细想来真是头疼。</p>
<p>萎靡不振便是我如今的写照。</p>
<p>希望2024可以有所改善，自己的选择，或是环境变化？谁知道呢</p>
<h2 id="思考与药物"><a href="#思考与药物" class="headerlink" title="思考与药物"></a>思考与药物</h2><p>最近比较喜欢东看看西看看，倒也不是完整的看完一本书，确实很难静下心。但是对于一些书摘或是博客，阅读兴趣大增，往往是边读边想，偶然往自己的阅读清单塞一塞。</p>
<p>上次就医后医生便给我开了两盒助眠药物 — 右佐匹克隆片。效果非常好，吃了往往十分钟便开始眼皮打架，很快便可以沉沉睡去。</p>
<p>差不多就到这了，现在是2024&#x2F;1&#x2F;1 1:21分，我期待我的2024可以变得更好，不求健康、财富、自由、脱单兼得。</p>
<p>只求，健康苟活，也希望身边人健健康康，一路同行。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Selenium库</title>
    <url>/2023/03/06/Python-Selenium%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Python-Selenium库"><a href="#Python-Selenium库" class="headerlink" title="Python Selenium库"></a>Python Selenium库</h1><h2 id="Selenium基础"><a href="#Selenium基础" class="headerlink" title="Selenium基础"></a>Selenium基础</h2><p>​	Selenium是一个用于测试网站的自动化测试工具，支持各种浏览器包括Chrome、Firefox、Safari等主流界面浏览器，同时也支持phantomJS无界面浏览器。</p>
<h3 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h3><p>​	<code>pip install Selenium</code></p>
<h3 id="安装浏览器驱动"><a href="#安装浏览器驱动" class="headerlink" title="安装浏览器驱动"></a>安装浏览器驱动</h3><p>​	谷歌浏览器下载链接 <a target="_blank" rel="noopener" href="https://chromedriver.storage.googleapis.com/index.html?path=2.35/">https://chromedriver.storage.googleapis.com/index.html?path=2.35/</a></p>
<p>​	火狐浏览器下载链接 <a target="_blank" rel="noopener" href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>​	设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： F:\GeckoDriver , 将下载的浏览器驱动文件（例如：chromedriver、geckodriver）丢到该目录下。</p>
<p><strong>我的电脑–&gt;属性–&gt;系统设置–&gt;高级–&gt;环境变量–&gt;系统变量–&gt;Path，将“F:\GeckoDriver”目录添加到Path的值中。比如：Path字段;F:\GeckoDriver</strong></p>
<span id="more"></span>


<h2 id="Selenium-快速入门"><a href="#Selenium-快速入门" class="headerlink" title="Selenium 快速入门"></a>Selenium 快速入门</h2><h3 id="Selenium提供了8种定位方式"><a href="#Selenium提供了8种定位方式" class="headerlink" title="Selenium提供了8种定位方式"></a>Selenium提供了8种定位方式</h3><ol>
<li>id</li>
<li>name</li>
<li>class name</li>
<li>tag name</li>
<li>link text</li>
<li>partial link text</li>
<li>xpath</li>
<li>css selector</li>
</ol>
<h3 id="定位元素的8种方式"><a href="#定位元素的8种方式" class="headerlink" title="定位元素的8种方式"></a>定位元素的8种方式</h3><table>
<thead>
<tr>
<th>定位一个元素</th>
<th>定位多个元素</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td>find_element_by_id</td>
<td>find_elements_by_id</td>
<td align="center">通过元素id定位</td>
</tr>
<tr>
<td>find_element_by_name</td>
<td>find_elements_by_name</td>
<td align="center">通过元素name定位</td>
</tr>
<tr>
<td>find_element_by_xpath</td>
<td>find_elements_by_xpath</td>
<td align="center">通过xpath表达式定位</td>
</tr>
<tr>
<td>find_element_by_link_text</td>
<td>find_elements_by_link_tex</td>
<td align="center">通过完整超链接定位</td>
</tr>
<tr>
<td>find_element_by_partial_link_text</td>
<td>find_elements_by_partial_link_text</td>
<td align="center">通过部分链接定位</td>
</tr>
<tr>
<td>find_element_by_tag_name</td>
<td>find_elements_by_tag_name</td>
<td align="center">通过标签定位</td>
</tr>
<tr>
<td>find_element_by_class_name</td>
<td>find_elements_by_class_name</td>
<td align="center">通过类名进行定位</td>
</tr>
<tr>
<td>find_elements_by_css_selector</td>
<td>find_elements_by_css_selector</td>
<td align="center">通过css选择器进行定位</td>
</tr>
</tbody></table>
<h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><h4 id="web页面："><a href="#web页面：" class="headerlink" title="web页面："></a>web页面：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">link</span>=<span class="string">&quot;#0000cc&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;result_logo&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">onmousedown</span>=<span class="string">&quot;return c(&#123;&#x27;fm&#x27;:&#x27;tab&#x27;,&#x27;tab&#x27;:&#x27;logo&#x27;&#125;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/s&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;soutu-btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;kw&quot;</span> <span class="attr">class</span>=<span class="string">&quot;s_ipt&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;255&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先需要先导入模块然后进行一些操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">dr=webdriver.Chrome()</span><br><span class="line">dr.get(<span class="string">&#x27;url&#x27;</span>)  <span class="comment">#这里的url就是对应页面的url</span></span><br></pre></td></tr></table></figure>



<h5 id="通过id定位"><a href="#通过id定位" class="headerlink" title="通过id定位:"></a>通过id定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_id(<span class="string">&quot;kw&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过name定位"><a href="#通过name定位" class="headerlink" title="通过name定位:"></a>通过name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_name(<span class="string">&quot;wd&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过class-name定位"><a href="#通过class-name定位" class="headerlink" title="通过class name定位:"></a>通过class name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_class_name(<span class="string">&quot;s_ipt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过tag-name定位"><a href="#通过tag-name定位" class="headerlink" title="通过tag name定位:"></a>通过tag name定位:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_tag_name(<span class="string">&quot;input&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过xpath定位-常用写法"><a href="#通过xpath定位-常用写法" class="headerlink" title="通过xpath定位,常用写法"></a>通过xpath定位,<em>常用写法</em></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;kw&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//*[@name=&#x27;wd&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;/html/body/form/span/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//span[@class=&#x27;soutu-btn&#x27;]/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//form[@id=&#x27;form&#x27;]/span/input&quot;</span>)</span><br><span class="line">dr.find_element_by_xpath(<span class="string">&quot;//input[@id=&#x27;kw&#x27; and @name=&#x27;wd&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="通过css定位-常用写法"><a href="#通过css定位-常用写法" class="headerlink" title="通过css定位_常用写法_"></a>通过css定位_常用写法_</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;#kw&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;[name=wd]&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;.s_ipt&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;html &gt; body &gt; form &gt; span &gt; input&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;span.soutu-btn&gt; input#kw&quot;</span>)</span><br><span class="line">dr.find_element_by_css_selector(<span class="string">&quot;form#form &gt; span &gt; input&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>假如页面上有一组文本链接</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;mnav&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://news.baidu.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tj_trnews&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;mnav&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.hao123.com&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tj_trhao123&quot;</span>&gt;</span>hao123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="通过link-text定位"><a href="#通过link-text定位" class="headerlink" title="通过link text定位"></a>通过link text定位</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_link_text(<span class="string">&quot;新闻&quot;</span>)</span><br><span class="line">dr.find_element_by_link_text(<span class="string">&quot;hao123&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过partial link text定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;新&quot;</span>)</span><br><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;hao&quot;</span>)</span><br><span class="line">dr.find_element_by_partial_link_text(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Selenium库下webdriver模块常用方法"><a href="#Selenium库下webdriver模块常用方法" class="headerlink" title="Selenium库下webdriver模块常用方法"></a>Selenium库下webdriver模块常用方法</h3><h4 id="控制浏览器操作的一些方法"><a href="#控制浏览器操作的一些方法" class="headerlink" title="控制浏览器操作的一些方法"></a>控制浏览器操作的一些方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>set_window_size()</td>
<td>设置浏览器的大小</td>
</tr>
<tr>
<td>back()</td>
<td>控制浏览器后退</td>
</tr>
<tr>
<td>forward()</td>
<td>控制浏览器前进</td>
</tr>
<tr>
<td>refresh()</td>
<td>刷新当前页面</td>
</tr>
<tr>
<td>clear()</td>
<td>清除文本</td>
</tr>
<tr>
<td>send_keys (value)</td>
<td>模拟按键输入</td>
</tr>
<tr>
<td>click()</td>
<td>单击元素</td>
</tr>
<tr>
<td>submit()</td>
<td>用于提交表单</td>
</tr>
<tr>
<td>get_attribute(name)</td>
<td>获取元素属性值</td>
</tr>
<tr>
<td>is_displayed()</td>
<td>设置该元素是否用户可见</td>
</tr>
<tr>
<td>size</td>
<td>返回元素的尺寸</td>
</tr>
<tr>
<td>text</td>
<td>获取元素的文本</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment">#1.创建Chrome浏览器对象，这会在电脑上在打开一个浏览器窗口</span></span><br><span class="line">browser = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)               <span class="comment">#这个就是电脑上存放驱动的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过浏览器向服务器发送URL请求</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.刷新浏览器</span></span><br><span class="line">browser.refresh()</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.设置浏览器的大小</span></span><br><span class="line">browser.set_window_size(<span class="number">1400</span>,<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在浏览器上进行操作</span></span><br><span class="line">element=browser.find_element_by_link_text(<span class="string">&quot;新闻&quot;</span>)</span><br><span class="line">element.click()      <span class="comment">#模拟鼠标左键单击</span></span><br><span class="line"></span><br><span class="line">element=browser.find_element_by_link_text(<span class="string">&quot;“下团组”时间&quot;</span>)</span><br><span class="line">element.click()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>​	在 WebDriver 中， 将这些关于鼠标操作的方法封装在 ActionChains 类提供</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ActionChains(driver)</td>
<td>构造ActionChains对象</td>
</tr>
<tr>
<td>context_click()</td>
<td>右击</td>
</tr>
<tr>
<td>move_to_element(above)</td>
<td>执行鼠标悬停操作</td>
</tr>
<tr>
<td>double_click()</td>
<td>双击</td>
</tr>
<tr>
<td>drag_and_drop()</td>
<td>拖动</td>
</tr>
<tr>
<td>move_to_element(above)</td>
<td>执行鼠标悬停操作</td>
</tr>
<tr>
<td>context_click()</td>
<td>用于模拟鼠标右键操作， 在调用时需要指定元素定位</td>
</tr>
<tr>
<td>perform()</td>
<td>执行所有 ActionChains 中存储的行为，可以理解成是对整个操作的提交动作</td>
</tr>
</tbody></table>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMzA4MTIwODU5MzEx?x-oss-process=image/format,png" alt="实例演示在百度首页用selenium进行设置操作"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment">#1.引入 ActionChains 类</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建Chrome浏览器对象，这会在电脑上在打开一个浏览器窗口</span></span><br><span class="line">driver = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.定位到要悬停的元素</span></span><br><span class="line">element= driver.find_element_by_link_text(<span class="string">&quot;设置&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.对定位到的元素执行鼠标悬停操作</span></span><br><span class="line">ActionChains(driver).move_to_element(element).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到要进行操作的选项</span></span><br><span class="line">elem1=driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>)</span><br><span class="line">elem1.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过元素选择器找到id=sh_2,并点击设置</span></span><br><span class="line">elem2=driver.find_element_by_id(<span class="string">&quot;sh_1&quot;</span>)</span><br><span class="line">elem2.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存设置</span></span><br><span class="line">elem3=driver.find_element_by_class_name(<span class="string">&quot;prefpanelgo&quot;</span>)</span><br><span class="line">elem3.click()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>​	Selenium中的Key模块为我们提供了模拟键盘按键的方法，那就是send_keys()方法。它不仅可以模拟键盘输入，也可以模拟键盘的操作。</p>
<p>模拟键盘操作</p>
<table>
<thead>
<tr>
<th>模拟键盘按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.BACK_SPACE)</td>
<td>删除键（BackSpace）</td>
</tr>
<tr>
<td>send_keys(Keys.SPACE)</td>
<td>空格键(Space)</td>
</tr>
<tr>
<td>send_keys(Keys.TAB)</td>
<td>制表键(Tab)</td>
</tr>
<tr>
<td>send_keys(Keys.ESCAPE)</td>
<td>回退键（Esc）</td>
</tr>
<tr>
<td>send_keys(Keys.ENTER)</td>
<td>回车键（Enter）</td>
</tr>
</tbody></table>
<p>模拟键盘组合键</p>
<table>
<thead>
<tr>
<th>模拟键盘按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.CONTROL,‘a’)</td>
<td>全选（Ctrl+A）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘c’)</td>
<td>复制（Ctrl+C）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘x’)</td>
<td>剪切（Ctrl+X）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘v’)</td>
<td>粘贴（Ctrl+V）</td>
</tr>
<tr>
<td>send_keys(Keys.F1…Fn)</td>
<td>键盘 F1…Fn</td>
</tr>
</tbody></table>
<h4 id="获取断言信息"><a href="#获取断言信息" class="headerlink" title="获取断言信息"></a>获取断言信息</h4><p>​	不管是在做功能测试还是自动化测试，最后一步需要拿实际结果与预期进行比较。这个比较的称之为断言。通过我们获取title 、URL和text等信息进行断言。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>用于获得当前页面的标题</td>
</tr>
<tr>
<td>current_url</td>
<td>用户获得当前页面的URL</td>
</tr>
<tr>
<td>text</td>
<td>获取搜索条目的文本信息</td>
</tr>
</tbody></table>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before search================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面title</span></span><br><span class="line">title = driver.title</span><br><span class="line"><span class="built_in">print</span>(title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面URL</span></span><br><span class="line">now_url = driver.current_url</span><br><span class="line"><span class="built_in">print</span>(now_url)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After search================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次打印当前页面title</span></span><br><span class="line">title = driver.title</span><br><span class="line"><span class="built_in">print</span>(title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面URL</span></span><br><span class="line">now_url = driver.current_url</span><br><span class="line"><span class="built_in">print</span>(now_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取结果数目  text</span></span><br><span class="line">user = driver.find_element_by_class_name(<span class="string">&#x27;nums&#x27;</span>).text</span><br><span class="line"><span class="built_in">print</span>(user)</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭所有窗口</span></span><br><span class="line">driver.quit()</span><br><span class="line"><span class="comment">#结果如下</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;Before search================</span></span><br><span class="line"><span class="string">百度一下，你就知道</span></span><br><span class="line"><span class="string">https://www.baidu.com/</span></span><br><span class="line"><span class="string">After search================</span></span><br><span class="line"><span class="string">selenium_百度搜索</span></span><br><span class="line"><span class="string">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=selenium&amp;rsv_pq=a1d51b980000e36e&amp;rsv_t=a715IZaMpLd1w92I4LNUi7gKuOdlAz5McsHe%2FSLQeBZD44OUIPnjY%2B7pODM&amp;rqlang=cn&amp;rsv_enter=0&amp;rsv_sug3=8&amp;inputT=758&amp;rsv_sug4=759</span></span><br><span class="line"><span class="string">搜索工具</span></span><br><span class="line"><span class="string">百度为您找到相关结果约7,170,000个</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="设置元素等待"><a href="#设置元素等待" class="headerlink" title="设置元素等待"></a>设置元素等待</h4><h4 id="定位一组元素-注意：是一组元素"><a href="#定位一组元素-注意：是一组元素" class="headerlink" title="定位一组元素(注意：是一组元素)"></a>定位一组元素(注意：是一组元素)</h4><p>​	定位一组元素的方法与定位单个元素的方法类似，唯一的区别是在单词element后面多了一个s表示复数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver =webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.定位一组元素</span></span><br><span class="line">elements = driver.find_elements_by_xpath(<span class="string">&#x27;//div/h3/a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(elements))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.循环遍历出每一条搜索结果的标题</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> elements:</span><br><span class="line">    <span class="built_in">print</span>(t.text)</span><br><span class="line">    element=driver.find_element_by_link_text(t.text)</span><br><span class="line">    element.click()</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="多表单切换"><a href="#多表单切换" class="headerlink" title="多表单切换"></a>多表单切换</h4><p>​	在Web应用中经常会遇到frame&#x2F;iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame&#x2F;iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame&#x2F;iframe表单的内嵌页面中。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>switch_to.frame()</td>
<td>将当前定位的主体切换为frame&#x2F;iframe表单的内嵌页面中</td>
</tr>
<tr>
<td>switch_to.default_content()</td>
<td>跳回最外层的页面</td>
</tr>
</tbody></table>
<p>126邮箱登录框的结构大概是这样子的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;x-URS-iframe&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">           ...</span><br><span class="line">           <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>想要操作登录框必须要先切换到iframe表单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;http://www.126.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.switch_to.frame(<span class="string">&#x27;x-URS-iframe&#x27;</span>)</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;email&quot;</span>).clear()</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;email&quot;</span>).send_keys(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;password&quot;</span>).clear()</span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;password&quot;</span>).send_keys(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;dologin&quot;</span>).click()</span><br><span class="line">driver.switch_to.default_content()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="comment">#先通过xpth定位到iframe</span></span><br><span class="line">xf = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;x-URS-iframe&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#再将定位对象传给switch_to.frame()方法</span></span><br><span class="line">driver.switch_to.frame(xf)</span><br><span class="line">……</span><br><span class="line">driver.switch_to.parent_frame()</span><br></pre></td></tr></table></figure>

<h4 id="多窗口切换："><a href="#多窗口切换：" class="headerlink" title="多窗口切换："></a>多窗口切换：</h4><p>​	在页面操作过程中有时候点击某个链接会弹出新的窗口，这时就需要主机切换到新打开的窗口上进行操作。WebDriver提供了switch_to.window()方法，可以实现在不同的窗口之间切换。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>current_window_handle</td>
<td align="center">获得当前窗口句柄</td>
</tr>
<tr>
<td>window_handles</td>
<td align="center">返回所有窗口的句柄到当前会话</td>
</tr>
<tr>
<td>switch_to.window()</td>
<td align="center">用于切换到相应的窗口，与上一节的switch_to.frame()类似，前者用于不同窗口的切换，后者用于不同表单之间的切换。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.获得百度搜索窗口句柄</span></span><br><span class="line">sreach_windows = driver.current_window_handle</span><br><span class="line"></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&#x27;登录&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;立即注册&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.获得当前所有打开的窗口的句柄</span></span><br><span class="line">all_handles = driver.window_handles</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.进入注册窗口</span></span><br><span class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> all_handles:</span><br><span class="line">    <span class="keyword">if</span> handle != sreach_windows:</span><br><span class="line">        driver.switch_to.window(handle)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;跳转到注册窗口&#x27;</span>)</span><br><span class="line">        driver.find_element_by_name(<span class="string">&quot;account&quot;</span>).send_keys(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">        driver.find_element_by_name(<span class="string">&#x27;password&#x27;</span>).send_keys(<span class="string">&#x27;123456789&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="警告框处理"><a href="#警告框处理" class="headerlink" title="警告框处理"></a>警告框处理</h4><p>​	在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用  switch_to.alert 方法定位到 alert&#x2F;confirm&#x2F;prompt，然后使用text&#x2F;accept&#x2F;dismiss&#x2F;  send_keys等方法进行操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>返回 alert&#x2F;confirm&#x2F;prompt 中的文字信息</td>
</tr>
<tr>
<td>accept()</td>
<td>接受现有警告框</td>
</tr>
<tr>
<td>dismiss()</td>
<td>解散现有警告框</td>
</tr>
<tr>
<td>send_keys(keysToSend)</td>
<td>发送文本至警告框。keysToSend：将文本发送至警告框。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标悬停至“设置”链接</span></span><br><span class="line">link = driver.find_element_by_link_text(<span class="string">&#x27;设置&#x27;</span>)</span><br><span class="line">ActionChains(driver).move_to_element(link).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开搜索设置并点击</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#在此处设置等待2s否则可能报错</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 保存设置</span></span><br><span class="line">driver.find_element_by_class_name(<span class="string">&quot;prefpanelgo&quot;</span>).click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受警告框</span></span><br><span class="line">driver.switch_to.alert.accept()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="下拉框选择操作"><a href="#下拉框选择操作" class="headerlink" title="下拉框选择操作"></a>下拉框选择操作</h4><p>​	导入类</p>
<p><code>from selenium.webdriver.support.select import Select</code></p>
<p>Select类的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>select_by_value(“选择值”)</td>
<td>select标签的value属性的值</td>
</tr>
<tr>
<td>select_by_index(“索引值”)</td>
<td>下拉框的索引</td>
</tr>
<tr>
<td>select_by_visible_testx(“文本值”)</td>
<td>下拉框的文本值</td>
</tr>
</tbody></table>
<p>百度搜索设置的下拉框</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.鼠标悬停至“设置”链接</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&#x27;设置&#x27;</span>).click()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#2.打开搜索设置</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">&quot;搜索设置&quot;</span>).click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.搜索结果显示条数</span></span><br><span class="line">sel = driver.find_element_by_xpath(<span class="string">&quot;//select[@id=&#x27;nr&#x27;]&quot;</span>)</span><br><span class="line">Select(sel).select_by_value(<span class="string">&#x27;50&#x27;</span>)  <span class="comment"># 显示50条</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>​	对于通过input标签实现的上传功能，可以将其看作是一个输入框，即通过send_keys()指定本地文件路径的方式实现文件上传。</p>
<p>通过send_keys()方法来实现文件上传:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">file_path = <span class="string">&#x27;file:///&#x27;</span> + os.path.abspath(<span class="string">&#x27;upfile.html&#x27;</span>)</span><br><span class="line">driver.get(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位上传按钮，添加本地文件</span></span><br><span class="line">driver.find_element_by_name(<span class="string">&quot;file&quot;</span>).send_keys(<span class="string">&#x27;D:\\upload_file.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h4><p>​	有时候我们需要验证浏览器中cookie是否正确，因为基于真实cookie的测试是无法通过白盒和集成测试进行的。WebDriver提供了操作Cookie的相关方法，可以读取、添加和删除cookie信息。</p>
<p>WebDriver操作cookie的方法:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get_cookies()</td>
<td>获得所有cookie信息</td>
</tr>
<tr>
<td>get_cookie(name)</td>
<td>返回字典的key为“name”的cookie信息</td>
</tr>
<tr>
<td>add_cookie(cookie_dict)</td>
<td>添加cookie。“cookie_dict”指字典对象，必须有name 和value 值</td>
</tr>
<tr>
<td>delete_cookie(name,optionsString)</td>
<td>删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”</td>
</tr>
<tr>
<td>delete_all_cookies()</td>
<td>删除所有cookie信息</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Chrome(<span class="string">&quot;F:\Chrome\ChromeDriver\chromedriver&quot;</span>)</span><br><span class="line">browser.get(<span class="string">&quot;http://www.youdao.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.打印cookie信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印所有的cookie信息为：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加cookie信息</span></span><br><span class="line"><span class="built_in">dict</span>=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&quot;name&quot;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;Kaina&#x27;</span>&#125;</span><br><span class="line">browser.add_cookie(<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;添加cookie信息为：&#x27;</span>)</span><br><span class="line"><span class="comment">#3.遍历打印cookie信息</span></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#4.删除一个cookie</span></span><br><span class="line">browser.delete_cookie(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除一个cookie&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除所有cookie后：&#x27;</span>)</span><br><span class="line"><span class="comment">#5.删除所有cookie,无需传递参数</span></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> browser.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s----%s\n&#x27;</span> %(cookie[<span class="string">&#x27;name&#x27;</span>],cookie[<span class="string">&#x27;value&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h4 id="调用JavaScript代码"><a href="#调用JavaScript代码" class="headerlink" title="调用JavaScript代码"></a>调用JavaScript代码</h4><p>​	虽然WebDriver提供了操作浏览器的前进和后退方法，但对于浏览器滚动条并没有提供相应的操作方法。在这种情况下，就可以借助JavaScript来控制浏览器的滚动条。WebDriver提供了execute_script()方法来执行JavaScript代码。</p>
<p>用于调整浏览器滚动条位置的JavaScript代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!-- window.scrollTo(左边距,上边距); --&gt;</span><br><span class="line">window.scrollTo(<span class="number">0</span>,<span class="number">450</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距。其代码如下：</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.访问百度</span></span><br><span class="line">driver=webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搜索</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.休眠2s目的是获得服务器的响应内容，如果不使用休眠可能报错</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.通过javascript设置浏览器窗口的滚动条位置</span></span><br><span class="line">js=<span class="string">&quot;window.scrollTo(100,450);&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<p>通过浏览器打开百度进行搜索，并且提前通过set_window_size()方法将浏览器窗口设置为固定宽高显示，目的是让窗口出现水平和垂直滚动条。然后通过execute_script()方法执行JavaScripts代码来移动滚动条的位置。<br> 滚动条上下左右滚动代码演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver=webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.set_window_size(<span class="number">400</span>,<span class="number">400</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搜索</span></span><br><span class="line"><span class="comment"># driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)</span></span><br><span class="line"><span class="comment"># driver.find_element_by_id(&quot;su&quot;).click()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.休眠2s目的是获得服务器的响应内容，如果不使用休眠可能报错</span></span><br><span class="line">sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4 滚动左右滚动条---向右</span></span><br><span class="line">js2 = <span class="string">&quot;var q=document.documentElement.scrollLeft=10000&quot;</span></span><br><span class="line">driver.execute_script(js2)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5 滚动左右滚动条---向左</span></span><br><span class="line">js3 = <span class="string">&quot;var q=document.documentElement.scrollLeft=0&quot;</span></span><br><span class="line">driver.execute_script(js3)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6 拖动到滚动条底部---向下</span></span><br><span class="line">js = <span class="string">&quot;var q=document.documentElement.scrollTop=10000&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#7 拖动到滚动条底部---向上</span></span><br><span class="line">js = <span class="string">&quot;var q=document.documentElement.scrollTop=0&quot;</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line">sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<h4 id="窗口截图"><a href="#窗口截图" class="headerlink" title="窗口截图"></a>窗口截图</h4><p>​	自动化用例是由程序去执行的，因此有时候打印的错误信息并不十分明确。如果在脚本执行出错的时候能对当前窗口截图保存，那么通过图片就可以非常直观地看出出错的原因。WebDriver提供了截图函数get_screenshot_as_file()来截取当前窗口。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get_screenshot_as_file(self, filename)</td>
<td>用于截取当前窗口，并把图片保存到本地</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver =webdriver.Firefox(executable_path =<span class="string">&quot;F:\GeckoDriver\geckodriver&quot;</span>)</span><br><span class="line">driver.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>).send_keys(<span class="string">&#x27;selenium&#x27;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>).click()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.截取当前窗口，并指定截图图片的保存位置</span></span><br><span class="line">driver.get_screenshot_as_file(<span class="string">&quot;D:\\baidu_img.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="关闭浏览器"><a href="#关闭浏览器" class="headerlink" title="关闭浏览器"></a>关闭浏览器</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>close()</td>
<td>关闭单个窗口</td>
</tr>
<tr>
<td>quit()</td>
<td>关闭所有窗口</td>
</tr>
</tbody></table>
<p>​	</p>
]]></content>
      <categories>
        <category>Python-learn</category>
        <category>Python 库</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>python程序中经常出现是干嘛的?</title>
    <url>/2023/08/09/python%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-md/</url>
    <content><![CDATA[<p>简单来说，这句话的作用就是判断你执行的是不是当前文件？如果是，则执行if块里面的，如果不是就不会执行。</p>
<p>是不是有些拗口，什么叫我执行的是不是当前文件？这就得从python的模块概念说起。</p>
<span id="more"></span>

<p>首先得先明白python是一个解释型语言，它与C不一样并不是先全部编译并链接好再进行执行的，而是从你运行的那个模块的最顶行开始，逐行解释执行。所以，最顶层（没有被缩进）的代码都会被执行，而<strong>我们<code>import module</code>的操作就是把<code>module</code>这个模块导入到当前模块里面，并且把它执行一遍。</strong>可以通过例子理解下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;Welcome to my module&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line"></span><br><span class="line">test1.greet(<span class="string">&quot;Alice&quot;</span>)  <span class="comment"># 调用模块中的函数</span></span><br><span class="line"><span class="built_in">print</span>(test1.message)  <span class="comment"># 访问模块中的变量</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Welcome to my module</span></span><br><span class="line"><span class="string">Hello, Alice!</span></span><br><span class="line"><span class="string">Welcome to my module</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从输出结果判断我们可以看出，确实是导入module再执行module，然后继续往下执行。</p>
<p>[^tips]: 如此一来，我们也能理解在很多python项目中使用方法为什么一般都是from XXX import XXX，如果直接import，开销也就太大了。</p>
<p>每次import都会把导入的模块执行一遍，但又不是所有的模块都只有函数，如果里面有输出或者其他操作，这些又不是我需要的，怎么处理呢。<strong>简而言之，如何避免某些代码在模块被导入后被执行？</strong> — 这恰恰是<code> if __name__ == &#39;__main__&#39;</code>的作用。</p>
<p><code>__name__ </code>是python的一个内置属性，其用于标识当前模块的名称。当一个模块被直接执行时，其名称被设置为 <code>&quot;__main__&quot;</code>。而当一个模块被导入到其他模块中时，其名称则被设置为模块的实际名称。这里可以举例理解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这里是模块：&#x27;</span>, __name__)</span><br><span class="line"><span class="comment"># 这里是模块： __main__</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这里是模块：&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># main_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这里是模块：&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这里是模块： test1</span></span><br><span class="line"><span class="string">这里是模块： __main__</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>了解了<code>__name__</code>是什么，那么<code>if __name__ == &#39;__main__&#39;</code>的作用就显而易见了。就是判断当前执行的模块是不是我，如果不是，我后面的程序就不执行，如果是就执行。</p>
]]></content>
      <categories>
        <category>Python-learn</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下给命令起个别名</title>
    <url>/2023/08/09/windows%E4%B8%8B%E7%BB%99%E5%91%BD%E4%BB%A4%E8%B5%B7%E4%B8%AA%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<p>最近用bilix下载b站视频，如果想要登录我每次都得带上一个cookie，不然下载的画质最高是780P的，不够清晰。但每次带cookie又太麻烦了，所以就搜索了下有没有可以保持登陆的。<br><img src="https://s2.loli.net/2023/08/09/uYWUqtEak6CHriD.png" alt="image-20230809192453706"><br>作者在GitHub中只给出了MAC与Linux的解决方法，并没有Windows的，所以我就搜索了下有没有类似的解决方法，还真找到了。</p>
<span id="more"></span>

<h1 id="新建bat文件"><a href="#新建bat文件" class="headerlink" title="新建bat文件"></a>新建bat文件</h1><p>先建立个txt文件，在里面写好你要起别名的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">doskey ls=dir /b $*  </span><br><span class="line">doskey bilixc=bilix --cookie &quot;your cookie&quot; $*</span><br></pre></td></tr></table></figure>

<p><code>这里ls是用来做测试的</code></p>
<ul>
<li><p>等于号左边是其右边的别名</p>
</li>
<li><p><code>doskey</code>就相当于Linux中的<code>alias</code></p>
</li>
<li><p><code>$*</code>表示这个命令还可能有其他参数</p>
</li>
<li><p>把文件存到C盘里</p>
</li>
</ul>
<h1 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h1><h2 id="找到cmd注册表项的位置"><a href="#找到cmd注册表项的位置" class="headerlink" title="找到cmd注册表项的位置"></a>找到cmd注册表项的位置</h2><p>打开cmd，运行<code>cmd /?</code>命令，然后找到这一项，或许你的有所不同，但肯定是大同小异。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\EnableExtensions</span><br><span class="line"></span><br><span class="line">    和/或</span><br><span class="line"></span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Command Processor\EnableExtensions</span><br></pre></td></tr></table></figure>

<p>随后win+r，调出运行，输入<code>regedit</code>，然后根据上面路径找到对应目录<br><img src="https://s2.loli.net/2023/08/09/nUvJ35EoudbqpeS.png" alt="image-20230809192630207"></p>
<h2 id="修改注册表-1"><a href="#修改注册表-1" class="headerlink" title="修改注册表"></a>修改注册表</h2><p>我这里是没有AutoRun这一项的，因此右键——新建——字符串值，输入“AutoRun”，然后选中——右键——修改，把路径输入进去</p>
<p><img src="https://s2.loli.net/2023/08/09/dsobgRmverqu1kA.png" alt="image-20230809192640324"></p>
<p>然后确认，退出就行</p>
<h1 id="检测测试是否成功"><a href="#检测测试是否成功" class="headerlink" title="检测测试是否成功"></a>检测测试是否成功</h1><p>打开cmd，输入ls看看，ok成功了</p>
<p><img src="https://s2.loli.net/2023/08/09/F6ROBDce92w3JW5.png" alt="image-20230809192715839"></p>
<p>再看看bilix下载情况</p>
<p><img src="https://s2.loli.net/2023/08/09/g3mt7aeSuzcNBYf.png" alt="image-20230809192731178"></p>
<p>ok没问题，画质是登录以后的，nice try！</p>
<p><img src="https://s2.loli.net/2023/08/09/c17eKFGRnPrU8sW.png" alt="image-20230809192741226"></p>
<p>reference</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fstang/archive/2013/04/06/3002006.html">在cmd中为命令设置别名以及启动cmd时自动执行bat</a></li>
</ul>
]]></content>
      <tags>
        <tag>-工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-OpenCV基础教程</title>
    <url>/2023/03/07/Python-OpenCV%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>前言：OpenCV是为了搞比赛学的，当时目的是为了做喷播机的识别系统，识别可喷区域，掌握基础就行，在学的过程中发现OpenCV入门还是很简单的，而且摄像头玩着还是挺有意思。至于学Python-OpenCV，是因为使用的设备是树莓派，这里就不得不感慨一下，21年那会树莓派4B才600左右，现在已经1200+了，难崩！</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/index.html">OpenCV官方界面</a></li>
</ul>
<span id="more"></span>

<h1 id="OPEN-CV基础"><a href="#OPEN-CV基础" class="headerlink" title="OPEN CV基础"></a>OPEN CV基础</h1><h2 id="什么是图像"><a href="#什么是图像" class="headerlink" title="什么是图像"></a>什么是图像</h2><p>图像是由像素点组成的，像素点的矩阵就组成图像大小</p>
<p>计算机是01编码制，数字图像也是用01来记录信息，一般接触的都是八位数图像，0是最黑，255是最白</p>
<p>像素点：比如说<code>[500,500,3]</code> 就是<code>分别代表h，w，像素通道</code></p>
<h3 id="H-S-V-颜色模型"><a href="#H-S-V-颜色模型" class="headerlink" title="H S V 颜色模型"></a>H S V 颜色模型</h3><p>HSV（Hue Saturation Value）颜色模型是面向用户的</p>
<p>HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。</p>
<p>这个模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）</p>
<h4 id="色调"><a href="#色调" class="headerlink" title="色调"></a>色调</h4><p>用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,紫色为300°；</p>
<h4 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h4><p>饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。</p>
<h4 id="明度"><a href="#明度" class="headerlink" title="明度"></a>明度</h4><p>明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。</p>
<img src="https://bkimg.cdn.bcebos.com/pic/8d5494eef01f3a29fb2420739925bc315d607c9b?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1/format,f_auto" alt="HSV颜色空间模型" style="zoom:150%;" />

<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><h3 id="二值图像"><a href="#二值图像" class="headerlink" title="二值图像"></a>二值图像</h3><p><img src="D:\typora\src\image-20210911131838722.png" alt="二值图像是指：每个像素点均为黑色或者白色的图像。二值图像一般用来描述字符图像，其优点是占用空间少，缺点是，当表示人物，风景的图像时，二值图像只能展示其边缘信息，图像内部的纹理特征表现不明显。这时候要使用纹理特征更为丰富的灰度图像"></p>
<h3 id="灰度图像与彩色图像"><a href="#灰度图像与彩色图像" class="headerlink" title="灰度图像与彩色图像"></a>灰度图像与彩色图像</h3><p>一幅完整的图像，是由红色、绿色、蓝色三个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%9A%E9%81%93">通道</a>组成的。红色、绿色、蓝色三个通道的缩览图都是以<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%81%B0%E5%BA%A6">灰度</a>显示的。用不同的灰度色阶来表示“ 红，绿，蓝”在图像中的比重。通道中的纯白，代表了该色光在此处为最高亮度，亮度级别是255。</p>
<p>通道是整个Photo shop显示图像的基础。色彩的变动，实际上就是间接在对通道灰度图进行调整。通道是Photo shop处理图像的核心部分，所有的色彩调整工具都是围绕在这个核心周围使用的。</p>
<p>在计算机领域中，这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑色与白色两种颜色；灰度图像在黑色与白色之间还有许多级的颜色深度。但是，在数字图像领域之外，“黑白图像”也表示“灰度图像”，例如灰度的照片通常叫做“黑白照片”。在一些关于数字图像的文章中单色图像等同于灰度图像，在另外一些文章中又等同于黑白图像。</p>
<p>我们可以通过下面几种方法，将其转换为灰度：</p>
<p>1.浮点算法：Gray&#x3D;R * 0.3+G * 0.59+B * 0.11</p>
<p>2.整数方法：Gray&#x3D;(R * 30+G * 59+B * 11)&#x2F;100</p>
<p>3.移位方法：Gray &#x3D;(R * 76+G * 151+B * 28)&gt;&gt;8;</p>
<p>4.<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%B3%E5%9D%87%E5%80%BC%E6%B3%95">平均值法</a>：Gray&#x3D;（R+G+B）&#x2F;3;</p>
<p>5.仅取绿色：Gray&#x3D;G；</p>
<p>通过上述任一种方法求得Gray后，将原来的RGB(R,G,B)中的R,G,B统一用Gray替换，形成新的颜色RGB(Gray,Gray,Gray)，用它替换原来的RGB(R,G,B)就是灰度图了。</p>
<p><img src="/typora%5Csrc%5Cimage-20210911131936378.png" alt="image-20210911131936378"></p>
<h2 id="数据读取–图像"><a href="#数据读取–图像" class="headerlink" title="数据读取–图像"></a>数据读取–图像</h2><p><code>cv2.imread</code></p>
<p><code>cv2.IMREAD_COLOR</code>:彩色图像读取   可以使用1 代替</p>
<p><code>cv2.IMREAD_GRAYSCALE</code> ：灰度图像 可以使用0代替</p>
<p><code>cv2.IMREAD_UNCHANGED 包括alpha（透明度）通道的加载图像模式·</code>  可以使用-1代替</p>
<p><code>cv2.waitKey()</code>是让程序暂停的意思，参数是等待时间（毫秒ms）的时间一到，会继续执行接下来的程序，<strong>传入0的话表示一直等待等待期间也可以获取用户的按键输入</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img=cv2.imread(<span class="string">&quot;NV.jpg&quot;</span>,<span class="number">0</span>)<span class="comment">#加载灰度图像</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;image&quot;</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>) </span><br><span class="line"><span class="string">&quot;如果路径有错误，会返回None值，但并不会报错&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以先用<code>cv2.namedWindow()</code>创建一个画面，之后再显示</p>
<p>参数 1 仍然是图片的，参数 2 默认是<code>cv2.WINDOW_AUTOSIZE</code>，表示图片大小图片，也可以设置为<code>cv2.WINDOW_NORMAL</code>，表示图片大小可调整。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先定义窗口，后显示图片</span></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;lena2&#x27;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;lena2&#x27;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h2 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h2><p><code>cv2.imshow(windows_name, image)</code>    用的是B G R通道</p>
<p><code>imshow</code>函数作用是在窗口中显示图像，窗口自动适合于图像大小，我们也可以通过<code>imutils</code>模块调整显示图像的窗口的大小</p>
<p>windows_name： 窗口名称(字符串)<br>image： 图像对象，类型是<code>numpy</code>中的<code>ndarray</code>类型</p>
<p>在这之后需要调用 <code>cv2.waitKey()它的唯一参数是它应该等待用户输入多长时间（以毫秒给图像绘制留下时间，否则窗口会出现无响应的情况，并且图像无法显示出来</code></p>
<p>也就是说<code>cv2,imshow</code>后面必须跟<code>waitKey()</code>否则无法显示</p>
<p>这里可以通过<code>imutils</code>模块改变图像显示大小，下面示例展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>,img) </span><br><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>,imutils.resize(img,<span class="number">800</span>)) <span class="comment">#利用imutils模块调整图片尺寸</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了 <code>opencv</code> 外也可以调用 <code>matplotlib</code>对图像进行展示 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#matplotlib.pyplot  展示</span></span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>])  <span class="comment"># cv2是BGR  而plt是RGB需要换一下通道</span></span><br><span class="line">plt.show()  <span class="comment">#彩色图展示</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\PYTHON\OpenCV\image-20210912141915286.png" alt="image-20210912141915286"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#灰度图展示</span></span><br><span class="line">plt.imshow(img,cmap=plt.cm.gray)</span><br><span class="line">plt.show</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20210912140643353.png"></p>
<h2 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h2><p><code>imwrite 函数保存图像</code></p>
<p><code>cb2.imwrite(image_filename,image)</code></p>
<p>函数参数一： 保存的图像名称(字符串)<br>函数参数二： 图像对象，类型是<code>numpy</code>中的<code>ndarray</code>类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&#x27;img.jpg&#x27;</span>, img)   <span class="comment">#将图像保存成jpg文件</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;img2.png&#x27;</span>, img) <span class="comment">#将图像保存成png文件</span></span><br></pre></td></tr></table></figure>

<h2 id="图像读取显示保存练习"><a href="#图像读取显示保存练习" class="headerlink" title="图像读取显示保存练习"></a>图像读取显示保存练习</h2><ol>
<li><p>打开<code>lena.jpg</code>并显示，如果按下q，就保存图片为<code>&#39;lena_save.bmp&#39;</code>，否则就结束程序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;lena&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># ord()用来获取某个字符的编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):   <span class="comment">#键输入q就会保存</span></span><br><span class="line">    <span class="comment">#cv2.imwrite(&#x27;lena_save.bmp&#x27;, img)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;已保存&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Matplotlib</code> 是 Python 中常用的一个绘图库，</p>
</li>
</ol>
<h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d3/d63/classcv_1_1Mat.html">map对象</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56"><code>cv2.imread()</code></a></li>
<li>[<code>cv2.imshow()</code>(<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563</a>)</li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce"><code>cv2.imwrite()</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b"><code>cv.namedWindow()</code></a></li>
</ul>
<h2 id="窗口销毁函数"><a href="#窗口销毁函数" class="headerlink" title="窗口销毁函数"></a>窗口销毁函数</h2><p>当我们使用<code>imshow</code>函数展示图像时，最后需要在程序中对图像展示窗口进行销毁，否则程序将无法正常终止</p>
<p><code>cv2.destroyWindow(windows_name)</code> 销毁单个特定窗口，参数： 将要销毁的窗口的名字<br><code>cv2.destroyAllWindows() </code>销毁全部窗口，无参数</p>
<p>销毁窗口，不能图片窗口一出现我们就将窗口销毁，这样便没法观看窗口,应该采用以下方式</p>
<p><code>cv2.waitKey(time_of_milliseconds)</code></p>
<p>1.让窗口停留一段时间就销毁</p>
<p>2.接收指令，如接收指定的键盘敲击后结束窗口</p>
<p><code>参数：time_of_milliseconds</code>  大于0，此时的参数表示时间，单位是毫秒，表示等待一定毫秒后自动销毁窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表示等待10秒后，将销毁所有图像</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">10000</span>):</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="comment">#表示等待10秒，将销毁窗口名称为&#x27;image&#x27;的图像窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">10000</span>):</span><br><span class="line">    cv2.destroyWindow(<span class="string">&#x27;image&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>参数小于等于0时： 此时窗口将等待一个键盘指令，接收到指令后就会进行窗口销毁，这个指令是可以自动定义的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#当指定waitKey(0) == 27时当敲击键盘 Esc 时便销毁所有窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="comment">#当接收到键盘敲击A时，便销毁名称为&#x27;origin image&#x27;的图像窗口</span></span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(-<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>):</span><br><span class="line">    cv2.destroyWindow(<span class="string">&#x27;origin image&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="颜色空间装换"><a href="#颜色空间装换" class="headerlink" title="颜色空间装换"></a>颜色空间装换</h2><h3 id="图像色彩空间（color-space）变换函数-cv2-cvtColor"><a href="#图像色彩空间（color-space）变换函数-cv2-cvtColor" class="headerlink" title="*图像色彩空间（color space）变换函数 cv2.cvtColor"></a>*图像色彩空间（color space）变换函数 <code>cv2.cvtColor</code></h3><p><code>cv2.cvtColor(input_image,flag)</code> </p>
<p>参数一： input_image表示将要变换色彩的图像,<code>ndarray</code>对象</p>
<p> 参数二： 表示图像色彩空间变换的类型,常用有两种</p>
<p><code> cv2.COLOR_BGR2GRAY:表示将图像从BGR空间转化成灰度图，最常用</code> </p>
<p><code>cv2.COLOR_BGR2HSV:表示将图像从RGB空间转换到HSV空间</code></p>
<p>如果需要查看flag所有的类型，可以通过以下程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv2) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="built_in">print</span>(flags)</span><br><span class="line"><span class="comment">#共有274种</span></span><br></pre></td></tr></table></figure>

<h2 id="为何总是对灰度图进行处理？"><a href="#为何总是对灰度图进行处理？" class="headerlink" title="为何总是对灰度图进行处理？"></a>为何总是对灰度图进行处理？</h2><p><strong>图像的颜色主要是由于图像受到外界光照影响随之产生的不同颜色信息，同一个背景物的图像在不同光源照射下产生的不同颜色效果的图像，因此在我们做图像特征提取和识别过程时，我们要的是图像的梯度信息，也就是图像的本质内容，而颜色信息会对我们对梯度信息提取造成一定的干扰，因此我们会在做图像特征提取和识别前将图像转化为灰度图，这样同时也降低了处理的数据量并且增强了处理效果。</strong></p>
<h2 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一个长宽分别为w、h的 R G B彩色图像来说，它的每个像素值是由(B、G、R)的一个tuple组成，<code>opencv-python</code>中每个像素三个值的顺序是B、G、R，而对于灰度图像来说，每个像素对应的便只是一个整数，如果要把像素缩放到0、1，则灰度图像就是二值图像，0便是黑色，1便是白色。我们通过下面的例子来理解一下</p>
<p>处理的图像如下<img src="D:\typora\src\NV.jpg" alt="NV"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">rgb_img = cv2.imread(<span class="string">&#x27;E:/pycharm/opencv/new/NV.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rgb_img.shape)  <span class="comment"># (676, 1202, 3)  # h有676个像素点，w有1202个像素点，3就是三通道，也就是说看到的是彩图</span></span><br><span class="line"><span class="built_in">print</span>(rgb_img[<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># [16 11 12]</span></span><br><span class="line"><span class="built_in">print</span>(rgb_img[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]) <span class="comment"># 16</span></span><br><span class="line"></span><br><span class="line">gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)  <span class="comment">#灰度</span></span><br><span class="line"><span class="built_in">print</span>(gray_img.shape) <span class="comment">#(676, 1202)</span></span><br><span class="line"><span class="built_in">print</span>(gray_img[<span class="number">0</span>, <span class="number">0</span>])<span class="comment">#12</span></span><br></pre></td></tr></table></figure>

<p>从以上程序运行结果可以得知，彩色图像的高度height&#x3D;676，宽度&#x3D;1202 ，通道数为3     像素(0,0)的值为（16 11 12）   即 R&#x3D;16 G&#x3D;11  B&#x3D;12 </p>
<p>但是对于灰度图像来说就是单通道的</p>
<p>因此(0, 0, 0)便是代表一个黑色像素，(255, 255, 255)便是代表一个白色像素。这么想，B&#x3D;0, G&#x3D;0,  R&#x3D;0相当于关闭了颜色通道也就相当于无光照进入，所以图像整个是黑的，而(255, 255, 255)即B&#x3D;255, G&#x3D;255, R&#x3D;255，  相当于打开了B、G、R所有通道光线全部进入，因此便是白色。上图的灰度就是12即[12 12 12]</p>
<h3 id="创建一个简单的图"><a href="#创建一个简单的图" class="headerlink" title="创建一个简单的图"></a>创建一个简单的图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">white_img = np.ones((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">white_img = <span class="number">255</span>*white_img</span><br><span class="line">cv2.imshow(<span class="string">&#x27;white_img&#x27;</span>, white_img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210912192702186.png" alt="image-20210912192702186" style="zoom:33%;" />

<p><strong>公共参数：</strong></p>
<p><strong><code>img</code>：表示需要进行绘制的图像对象ndarray</strong><br><strong><code>color</code>：表示绘制几何图形的颜色，采用<code>BGR</code>即上述说的(B、G、R)</strong><br><strong><code>thickness</code>表示绘制几何图形中线的粗细，默认为1，对于圆、椭圆等封闭图像取-1时是填充图形内部</strong><br><strong><code>lineType </code>表示绘制几何图形线的类型，默认8-connected线是光滑的，当取<code>cv2.LINE_AA</code>时线呈现锯齿状</strong></p>
<h4 id="cv2-line-直线绘制函数"><a href="#cv2-line-直线绘制函数" class="headerlink" title="cv2.line 直线绘制函数"></a><code>cv2.line</code> 直线绘制函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.line(image, starting, ending, color, thickness, lineType)</span><br><span class="line"><span class="comment">#starting,ending 分别表示线的起点像素坐标，终点像素坐标</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-rectangle-矩形"><a href="#cv2-rectangle-矩形" class="headerlink" title="cv2.rectangle   矩形"></a><code>cv2.rectangle</code>   矩形</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.rectangle(image, top-left, bottom-right, color, thickness, lineType)</span><br><span class="line"><span class="comment">#top-left , bottom-right 分别表示长方形左上角像素坐标、右下角像素坐标</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-circle-圆"><a href="#cv2-circle-圆" class="headerlink" title="cv2.circle  圆"></a><code>cv2.circle</code>  圆</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.circle(image, center, radius, color, thickness, lineType)</span><br><span class="line"><span class="comment"># center 表示圆的圆心像素坐标</span></span><br><span class="line"><span class="comment"># radius 圆的半径长度</span></span><br><span class="line"><span class="comment">#当thickness=-1时，绘制的圆是实心圆，当thickness&gt;=0时绘制的是空心圆</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-ellipse-椭圆"><a href="#cv2-ellipse-椭圆" class="headerlink" title="cv2.ellipse   椭圆"></a><code>cv2.ellipse </code>  椭圆</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.circle(image, center, (major-axis-length, minor-axis-length), angle, startAngle, endAngle, color, thickness, lineType)</span><br><span class="line"><span class="comment">#当参数thickness = -1 时绘制的是实心椭圆，当thickness &gt;= 0 时绘制的是空心椭圆</span></span><br><span class="line"><span class="comment"># center： 表示椭圆中心像素坐标</span></span><br><span class="line"><span class="comment"># major-axis-length： 表示椭圆的长轴长度</span></span><br><span class="line"><span class="comment"># minor-axis-length： 表示椭圆的短轴长度</span></span><br><span class="line"><span class="comment"># angle： 表示椭圆在逆时针方向旋转的角度</span></span><br><span class="line"><span class="comment"># startAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的起始角度</span></span><br><span class="line"><span class="comment"># endAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的终止时角度</span></span><br></pre></td></tr></table></figure>



<h4 id="cv2-polylines-多边形"><a href="#cv2-polylines-多边形" class="headerlink" title="cv2.polylines 多边形"></a><code>cv2.polylines</code> 多边形</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.polylines(image, [point-<span class="built_in">set</span>], flag, color, thickness, lineType)</span><br><span class="line"><span class="comment"># [point-set]： 表示多边形点的集合，如果多边形有m个点，则便是一个m12的数组，表示共m个点</span></span><br><span class="line"><span class="comment"># flag： 当flag = True 时，则多边形是封闭的，当flag = False 时，则多边形只是从第一个到最后一个点连线组成的图像，没有封闭</span></span><br></pre></td></tr></table></figure>

<p>cv2.putText</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = np.ones((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">img = <span class="number">255</span>*img</span><br><span class="line">img = cv2.line(img, (<span class="number">100</span>,<span class="number">100</span>), (<span class="number">400</span>,<span class="number">400</span>),(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</span><br><span class="line">img = cv2.rectangle(img,(<span class="number">200</span>, <span class="number">20</span>),(<span class="number">400</span>,<span class="number">120</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">img = cv2.circle(img,(<span class="number">100</span>,<span class="number">400</span>), <span class="number">50</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">img = cv2.circle(img,(<span class="number">250</span>,<span class="number">400</span>), <span class="number">50</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">0</span>)</span><br><span class="line">img = cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">180</span>,(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">pts = np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line">img = cv2.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210912194703373.png" alt="image-20210912194703373" style="zoom:50%;" />

<h2 id="对图像的简单像素操作"><a href="#对图像的简单像素操作" class="headerlink" title="对图像的简单像素操作"></a>对图像的简单像素操作</h2><p>对于一个图像，每个像素点都有其对应的坐标<code>img[height,width,颜色通道]</code>而对于彩色图像每个像素点都是由[g,b,r]组成的</p>
<ul>
<li><code>img[y,x]</code>获取&#x2F;设置像素点值，<code>img.shape</code>：图片的形状（行数(height)、列数(width)、通道数），：<code>img.dtype</code>图像的数据类型。</li>
<li><code>img[y1:y2,x1:x2]</code>进行ROI截取，<code>cv2.split()/cv2.merge()</code>通道分割&#x2F;合并。更推荐的获取单通道方式：<code>b = img[:, :, 0]</code></li>
</ul>
<h4 id="获取和修改像素点值"><a href="#获取和修改像素点值" class="headerlink" title="获取和修改像素点值"></a>获取和修改像素点值</h4><p>操作以后，计算机内存中img的像素点是改变了 但是因为并没有保存，因此原图是没有更改的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 1.获取像素的值 b g r</span></span><br><span class="line">px = img[<span class="number">100</span>, <span class="number">90</span>]</span><br><span class="line"><span class="built_in">print</span>(px)  <span class="comment"># [103 98 197]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只获取蓝色blue通道的值</span></span><br><span class="line">px_blue = img[<span class="number">100</span>, <span class="number">90</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(px_blue)  <span class="comment"># 103</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改像素的值</span></span><br><span class="line">img[<span class="number">100</span>, <span class="number">90</span>] = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]</span><br><span class="line"><span class="built_in">print</span>(img[<span class="number">100</span>, <span class="number">90</span>])  <span class="comment"># [255 255 255]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.图片形状</span></span><br><span class="line"><span class="built_in">print</span>(img.shape)  <span class="comment"># (263, 247, 3)</span></span><br><span class="line"><span class="comment"># 形状中包括行数、列数和通道数</span></span><br><span class="line">height, width, channels = img.shape</span><br><span class="line"><span class="comment"># img是灰度图的话：height, width = img.shape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总像素数 h*W*通道数</span></span><br><span class="line"><span class="built_in">print</span>(img.size)  <span class="comment"># 263*247*3=194883</span></span><br><span class="line"><span class="comment"># 数据类型</span></span><br><span class="line"><span class="built_in">print</span>(img.dtype)  <span class="comment"># uint8   0-256</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.ROI截取   截取部分图像数据</span></span><br><span class="line">face = img[<span class="number">100</span>:<span class="number">200</span>, <span class="number">115</span>:<span class="number">188</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;face&#x27;</span>, face)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.通道分割与合并</span></span><br><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">img = cv2.merge((b, g, r))</span><br><span class="line"><span class="comment"># 更推荐的获取某一通道方式</span></span><br><span class="line">b = img[:, :, <span class="number">0</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;b&#x27;</span>, b)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="对图像取反"><a href="#对图像取反" class="headerlink" title="对图像取反"></a>对图像取反</h4><p><code>reverse_img = 255 - gray_img  </code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;[[12 14 14 ... 18 21 19]</span></span><br><span class="line"><span class="string"> [11 14 13 ... 23 20 17]</span></span><br><span class="line"><span class="string"> [13 13 13 ... 21 23 20]</span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string"> [20 22 22 ... 31 30 28]</span></span><br><span class="line"><span class="string"> [19 19 22 ... 28 29 29]</span></span><br><span class="line"><span class="string"> [21 19 16 ... 33 30 30]]&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#变成</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[243 241 241 ... 237 234 236]</span></span><br><span class="line"><span class="string"> [244 241 242 ... 232 235 238]</span></span><br><span class="line"><span class="string"> [242 242 242 ... 234 232 235]</span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string"> [235 233 233 ... 224 225 227]</span></span><br><span class="line"><span class="string"> [236 236 233 ... 227 226 226]</span></span><br><span class="line"><span class="string"> [234 236 239 ... 222 225 225]]&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210920180815747.png" alt="image-20210920180815747" style="zoom:50%;" />

<h4 id="对图像像素线性变换"><a href="#对图像像素线性变换" class="headerlink" title="对图像像素线性变换"></a>对图像像素线性变换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gray_img.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(gray_img.shape[<span class="number">1</span>]):</span><br><span class="line">        random_img[i, j] = gray_img[i, j]*<span class="number">1.2</span> <span class="comment">#灰度图所有像素都成了1.2  这里的[i,j]就代表一个一个的像素点</span></span><br></pre></td></tr></table></figure>

<img src="D:\typora\src\image-20210920180922849.png" alt="image-20210920180922849" style="zoom:50%;" />

<h4 id="截取部分图像数据-ROI"><a href="#截取部分图像数据-ROI" class="headerlink" title="截取部分图像数据 ROI"></a>截取部分图像数据 ROI</h4><p>学了特征后，就可以自动截取</p>
<p>先了解下这个图像的坐标左上角是原点，x轴与常规相同，y轴朝下  </p>
<p>下例中cat就是对NV这个图片进行切片，h切<code>0:200</code>,w也切<code>0:200</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rgb_img = cv2.imread(<span class="string">&#x27;E:/pycharm/opencv/new/NV.jpg&#x27;</span>)</span><br><span class="line">cat=rgb_img[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">200</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>,rgb_img)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">0</span>) == <span class="number">27</span>:</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20210920184022634.png" alt="截取到的"></p>
<h4 id="颜色通道的分割与合并"><a href="#颜色通道的分割与合并" class="headerlink" title="颜色通道的分割与合并"></a>颜色通道的分割与合并</h4><p>彩色图的<code>BGR</code>三个通道是可以分开单独访问的，可以也。将单独的三个通道合并分类中翻译一副图像分别使用<code>cv2.split()</code>状语从句：<code>cv2.merge()</code></p>
<p>这个效率比较低</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">img = cv2.merge((b, g, r))</span><br></pre></td></tr></table></figure>

<p>用<code>num</code>索引的方法比较简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = img[:, :, <span class="number">0</span>]</span><br><span class="line">cv2.imshow(<span class="string">&#x27;blue&#x27;</span>, b)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="掩膜mask"><a href="#掩膜mask" class="headerlink" title="掩膜mask"></a>掩膜mask</h2><p>物理的角度<br>在半导体制造中，许多芯片工艺步骤采用光刻技术，用于这些步骤的图形“底片”称为掩膜（也称作“掩模”），其作用是：在硅片上选定的区域中对一个不透明的图形模板遮盖，继而下面的腐蚀或扩散将只影响选定的区域以外的区域。<br>图像掩膜与其类似，用选定的图像、图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。</p>
<p> 数字图像处理中,图像掩模主要用于：</p>
<p>①提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。</p>
<p>②屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。</p>
<p>③结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。</p>
<p>④特殊形状图像的制作。用选定的图像、图形或物体,对待处理的图像(全部或局部)进行遮挡,来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e1eee55fde4d735986d0108c6004db3a.png" alt="这里写图片描述"></p>
<h2 id="图像基本运算"><a href="#图像基本运算" class="headerlink" title="图像基本运算"></a>图像基本运算</h2><p>bitwise_and、bitwise_or、bitwise_xor、bitwise_not这四个按位操作函数。</p>
<p>bitwise_and是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&amp;1&#x3D;1，1&amp;0&#x3D;0，0&amp;1&#x3D;0，0&amp;0&#x3D;0<br>bitwise_or是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1&#x3D;1，1|0&#x3D;0，0|1&#x3D;0，0|0&#x3D;0<br>bitwise_xor是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1 ^ 1&#x3D;0,1 ^ 0&#x3D;1,0 ^ 1&#x3D;1,0^0&#x3D;0<br>bitwise_not是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，~ 1 &#x3D;0，~0&#x3D;1</p>
<h2 id="颜色分离"><a href="#颜色分离" class="headerlink" title="颜色分离"></a>颜色分离</h2><p>对于一张彩色图像，若有需要对某种颜色进行分离出来，在 OpenCV 中需要使用到 cv2.inRange 和 cv2.bitwise_and 两个函数。</p>
<p>首先介绍一下两个函数：</p>
<p>1、cv2.inRange</p>
<p>cv2.inRange(src, lowerb, upperb)<br>用以确认元素值是否介于某个区域<br>inRange 函数需要设定三个参数，其中 src 指源图像；lowerb 指图像中低于 lowerb 的值，其所对应的图像值将为 0；upperb指图像中高于 upperb 的值，图像值变为 0 。换言之，源图像中仅有图像值介于 lowerb 和 upperb 之间的值才不为 0 ，且值将变成 255<br>2、cv2.bitwise_and</p>
<p>cv2.bitwise_and(src1, scr2, mask&#x3D;)<br>用于对两个数组（图像也是数组）对位元素进行运算，即计算机中的“和”运算。以二进制为例，1&amp;1输出 1 ，1&amp;0、0&amp;1、0&amp;0则均输出 0 。<br>bitwise_and 函数需要设定三个参数，其中 src1 指第一个数组（源图像），src2 指第二个数组（源图像），mask&#x3D; 用于指定具体的掩模（常以 0 和 1 元素为主，用以输出具体的元素），应设为 uint8 格式，即单通道的 8-bit 的数组。另外，mask 参数为可选参数，可省略。<br>言归正传，以某张船的照片为例，分离出图像的蓝色。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块，输出原图</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">ship_rgb = cv2.imread(<span class="string">&#x27;ship.jpg&#x27;</span>)[:,:,::-<span class="number">1</span>]</span><br><span class="line">plt.imshow(ship_rgb)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210302103907984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0OTU2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像转为HSV格式进而得到mask，HSV分别代表色相(Hue)、饱和度(Saturation)、明度(Value)</span></span><br><span class="line">ship_hsv = cv2.cvtColor(ship_rgb, cv2.COLOR_RGB2HSV)</span><br><span class="line"><span class="comment"># 设定参数lowerb、upperb</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">lowerb = np.array([<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>])</span><br><span class="line">upperb = np.array([<span class="number">140</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line"><span class="comment"># 获取mask</span></span><br><span class="line">mask = cv2.inRange(ship_hsv, lowerb, upperb)</span><br><span class="line"><span class="comment"># 利用mask进行颜色分离</span></span><br><span class="line">ship_masked = cv2.bitwise_and(ship_bgr,ship_bgr,mask=mask)</span><br><span class="line"><span class="comment"># 转回RGB格式</span></span><br><span class="line">ship_blue = cv2.cvtColor(ship_masked,cv2.COLOR_BGR2RGB)</span><br></pre></td></tr></table></figure>



<h2 id="拍摄与本地视频的读取与处理："><a href="#拍摄与本地视频的读取与处理：" class="headerlink" title="拍摄与本地视频的读取与处理："></a>拍摄与本地视频的读取与处理：</h2><p><code>cv2.ViedoCapture()</code>可以捕获摄像头，用数字来控制不同的设备，例如0,1</p>
<p>如果是视频文件直接指定路径就行</p>
<p><code>cap = cv2.VideoCapture()</code>创建视频捕捉对象<strong>cap</strong><br>其中参数可以可以写本地路径或者打开设备摄像头。<br><code>ret, frame = cap.read()；</code><br>1）ret,frame是获read()方法的两个返回值，其中ret是布尔值，如果读取帧是正确的则返回True，如果文件读取到结尾，它的返回值就False；<br>2）frame就是每一帧的图像，是个三维矩阵（按帧读取）。<br>这里需要注意的是由于<code>read</code>是一帧一帧读取，要么读取一张操作一张，要么将所有的帧全部存到list中统一处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">vc=cv2.VideoCapture(<span class="string">&#x27;C:/Users/XYT/Desktop/机械创新设计大赛/Modern Forest Planting Machine   Amazing life  #1 00_00_00-00_01_36.mp4&#x27;</span>)   <span class="comment">#视频文件指定路径  记得改斜杠</span></span><br><span class="line"><span class="keyword">if</span> vc.isOpened(): </span><br><span class="line">    <span class="built_in">open</span>,frame=vc.read()  <span class="comment"># read() 返回两个值，其中open是布尔类型，就是如果你读取到了视频中的这一帧，那么就返回True 反之。frame接收到的是这一帧图像</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">open</span>=<span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">open</span>:  <span class="comment">#利用循环一帧一帧的播放视频，每次获取一帧</span></span><br><span class="line">    ret,frame=vc.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) <span class="comment">#将这一帧图像转换成灰度图</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;gray_img&#x27;</span>,gray)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">10</span>)&amp;<span class="number">0xFF</span>==<span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">vc.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="获取摄像头属性（视频捕捉属性）cap-get-propId"><a href="#获取摄像头属性（视频捕捉属性）cap-get-propId" class="headerlink" title="获取摄像头属性（视频捕捉属性）cap.get(propId)"></a>获取摄像头属性（视频捕捉属性）<code>cap.get(propId)</code></h4><p>通过<code>cap.get(propId)</code>采集摄像头的一些属性，比如设备属性的属性，可以参考从0~18的属性</p>
<p>也可以使用<code>cap.set(propId,value)</code>来修改属性值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取捕获的分辨率</span></span><br><span class="line"><span class="comment"># propId可以直接写数字，也可以用OpenCV的符号表示</span></span><br><span class="line">width, height = capture.get(<span class="number">3</span>), capture.get(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(width, height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以原分辨率的一倍来捕获</span></span><br><span class="line">capture.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, width * <span class="number">2</span>)</span><br><span class="line">capture.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, height * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;import cv2</span></span><br><span class="line"><span class="string">cap=cv2.VideoCapture(0)</span></span><br><span class="line"><span class="string">print(cap.get(3),cap.get(4))  # 640 489   分别代表h， 与 w</span></span><br><span class="line"><span class="string">cap.set(3,cap.get(3)*2)</span></span><br><span class="line"><span class="string">cap.set(4,cap.get(4)*2)</span></span><br><span class="line"><span class="string">if cap.isOpened():</span></span><br><span class="line"><span class="string">    ret,frame=cap.read()</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&#x27;摄像头未正常开启&#x27;)</span></span><br><span class="line"><span class="string">while ret :</span></span><br><span class="line"><span class="string">    ret,frame=cap.read()</span></span><br><span class="line"><span class="string">    if frame is None:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">    if ret == True:</span></span><br><span class="line"><span class="string">        cv2.imshow(&#x27;cap_mp4&#x27;,frame)</span></span><br><span class="line"><span class="string">        if cv2.waitKey(25) == ord(&#x27;s&#x27;):</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">cap.release()</span></span><br><span class="line"><span class="string">cv2.destroyAllWindows()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<pre><code>&#39;[VideoCaptureProperties](https://docs.opencv.org/4.0.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d)&#39; 
</code></pre>
<table>
<thead>
<tr>
<th align="left"><code>CAP_PROP_POS_MSEC Python：cv.CAP_PROP_POS_MSEC</code></th>
<th>0</th>
<th>以毫秒为单位的视频文件的当前位置。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CAP_PROP_POS_FRAMES Python：cv.CAP_PROP_POS_FRAMES</code></td>
<td>1</td>
<td>下一个要解码&#x2F;捕获的帧的基于 0 的索引。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_POS_AVI_RATIO Python：cv.CAP_PROP_POS_AVI_RATIO</code></td>
<td>2</td>
<td>视频文件的相对位置：0&#x3D;影片开头，1&#x3D;影片结尾。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_WIDTH Python：cv.CAP_PROP_FRAME_WIDTH</code></td>
<td>3</td>
<td>视频流中帧的宽度。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_HEIGHT Python：cv.CAP_PROP_FRAME_HEIGHT</code></td>
<td>4</td>
<td>视频流中帧的高度。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FPS Python：cv.CAP_PROP_FPS</code></td>
<td>5</td>
<td>帧率。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FOURCC Python：cv.CAP_PROP_FOURCC</code></td>
<td>6</td>
<td>编解码器的 4 字符代码。见<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html#afec93f94dc6c0b3e28f4dd153bc5a7f0">VideoWriter::fourcc</a>。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FRAME_COUNT Python：cv.CAP_PROP_FRAME_COUNT</code></td>
<td>7</td>
<td>视频文件中的帧数。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_FORMAT Python：cv.CAP_PROP_FORMAT</code></td>
<td>8</td>
<td><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html#a9ac7f4b1cdfe624663478568486e6712">VideoCapture::retrieve()</a>返回的 Mat 对象的格式。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_MODE Python：cv.CAP_PROP_MODE</code></td>
<td>9</td>
<td>指示当前捕获模式的后端特定值。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_BRIGHTNESS Python：cv.CAP_PROP_BRIGHTNESS</code></td>
<td>10</td>
<td>图像的亮度（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_CONTRAST Python：cv.CAP_PROP_CONTRAST</code></td>
<td>11</td>
<td>图像对比度（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_SATURATION Python：cv.CAP_PROP_SATURATION</code></td>
<td>12</td>
<td>图像的饱和度（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_HUE Python：cv.CAP_PROP_HUE</code></td>
<td>13</td>
<td>图像的色调（仅适用于相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_GAIN Python：cv.CAP_PROP_GAIN</code></td>
<td>14</td>
<td>图像增益（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_EXPOSURE Python：cv.CAP_PROP_EXPOSURE</code></td>
<td>15</td>
<td>曝光（仅适用于支持的相机）。</td>
</tr>
<tr>
<td align="left"><code>CAP_PROP_CONVERT_RGB Python：cv.CAP_PROP_CONVERT_RGB</code></td>
<td>16</td>
<td>指示图像是否应转换为 RGB 的布尔标志。</td>
</tr>
</tbody></table>
<p>注：部分摄像头设置经验等参数时会被禁用，因为它们有固定的大小支持，一般可以在摄像头的资料页中找到。</p>
<h4 id="录制并保存视频-VideoWriter"><a href="#录制并保存视频-VideoWriter" class="headerlink" title="录制并保存视频 VideoWriter"></a>录制并保存视频 <code>VideoWriter</code></h4><p>之前我们用的是<code>cv2.imwrite()</code>保存图片，要保存视频，我们需要创建一个<code>VideoWriter</code>对象，需要给它保存四个参数：</p>
<ul>
<li>输出的文件名，如’output.avi’</li>
<li>编码方式四<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin">CC</a>码</li>
<li>帧率<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/FPS/3227416">FPS</a></li>
<li>要保存大小 (h,w)</li>
</ul>
<p><code>FourCC</code>是指定视频编码方式的四字节码，所有的编码可参考<a target="_blank" rel="noopener" href="http://www.fourcc.org/codecs.php">Video Codecs</a>。如<code>MJPG</code>编码可以这样写：</p>
<p><code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code></p>
<p>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编码方式并创建VideoWriter对象</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;MJPG&#x27;</span>)</span><br><span class="line">outfile = cv2.VideoWriter(<span class="string">&#x27;output.avi&#x27;</span>, fourcc, <span class="number">55</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(capture.isOpened()):</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        outfile.write(frame)  <span class="comment"># 写入文件</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="练习：实现一个可以选择播放播放的属性"><a href="#练习：实现一个可以选择播放播放的属性" class="headerlink" title="练习：实现一个可以选择播放播放的属性"></a>练习：实现一个可以选择播放播放的属性</h4><p><code>cv2.createTrackbar(&#39;R&#39;,&#39;image&#39;,0,255,call_back)</code></p>
<p>创建一个轨迹栏并将其附加到指定的窗口</p>
<p>参数</p>
<p>滑动条名称</p>
<p>所在窗口名称</p>
<p>当前的值</p>
<p>最大值</p>
<p>回调函数名称，回调函数默认有一个表示当前值的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">track_back</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    ### 回调函数，x表示滑块的位置</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 更改视频的帧位置 cv.CAP_PROP_POS_FRAME是下一个要捕获的帧的基于0的索引</span></span><br><span class="line">    capture.<span class="built_in">set</span>(cv2.CAP_PROP_POS_FRAMES, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;window&#x27;</span>)</span><br><span class="line"></span><br><span class="line">capture = cv2.VideoCapture(<span class="string">&#x27;./demo_video.mp4&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取视频总共多少帧</span></span><br><span class="line">frames = capture.get(cv2.CAP_PROP_FRAME_COUNT)</span><br><span class="line"><span class="comment"># 创建滑动条</span></span><br><span class="line">cv2.createTrackbar(<span class="string">&#x27;process&#x27;</span>, <span class="string">&#x27;window&#x27;</span>, <span class="number">1</span>, <span class="built_in">int</span>(frames), track_back)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(capture.isOpened()):</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;window&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h2><h3 id="固定图像阈值处理-threshold"><a href="#固定图像阈值处理-threshold" class="headerlink" title="固定图像阈值处理 threshold"></a>固定图像阈值处理 threshold</h3><p><code>ret,dst=cv2.threshold(src,thresh,maxval,type)</code></p>
<p>scr: 输入需要处理的原图，只能输入单通道图像，一般是灰度图</p>
<p>dst:输出图</p>
<p>thresh:设置的阈值</p>
<p><code>maxval</code>:对于<code>THRESH_BINARY</code>、<code>THRESH_BINARY_INV</code>阈值方法用的最大阈值，一般为255</p>
<p>type:阈值的方式，主要有5种，详情可见：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576">ThresholdTypes</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#五种不同的阈值方法</span></span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  <span class="comment">#大于阈值127的部分区最大值255也就是白色，小于127部分取0 也就是黑色</span></span><br><span class="line">ret, th2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)<span class="comment">#与THRESH_BINARY 结果相反</span></span><br><span class="line">ret, th3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC) <span class="comment">#所有大于127的就取127在这里进行截断， 而小于的部分不进行改变</span></span><br><span class="line">ret, th4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO) <span class="comment">#大于127的部分保持不变，而其他部分都变为黑色</span></span><br><span class="line">ret, th5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)  <span class="comment">#反转</span></span><br></pre></td></tr></table></figure>

<h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><h2 id="卷积基础–图形边框"><a href="#卷积基础–图形边框" class="headerlink" title="卷积基础–图形边框"></a>卷积基础–图形边框</h2><h3 id="二维卷积："><a href="#二维卷积：" class="headerlink" title="二维卷积："></a>二维卷积：</h3><p><img src="http://cos.codec.wang/cv2_understand_convolution.jpg" alt="img"></p>
<p>卷积就是循环对<strong>图像跟一个核逐个元素相乘再求和得到另外一副图像的操作</strong>，比如结果图中第一个元素5是由原图中3×3的区域与3×3的核逐个元素相乘再相加：</p>
<p>算完之后，整个框再往右移一步继续计算，横向计算完后，再往下移一步继续计算……网上有一副很经典的动态图，方便我们理解卷积：</p>
<p><img src="http://cos.codec.wang/cv2_understand_cnn.gif" alt="img"></p>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫填充padding</strong>。</p>
<blockquote>
<p>事实上，原图为n×n，卷积核为f×f，最终结果图大小为**(n-f+1) × (n-f+1)。**</p>
</blockquote>
<p><img src="http://cos.codec.wang/cv2_understand_padding.jpg" alt="img"></p>
<p>那么扩展的这一层应该填充什么值呢？<code>OpenCV</code>中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现，一起来看看。</p>
<h4 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h4><p><code>cv2.copyMakeBorder()</code>用来给图片添加边框，它有下面几个参数：</p>
<ul>
<li>src：要处理的原图</li>
<li>top, bottom, left, right：上下左右要扩展的像素数( 相应方向上的边框宽度 )</li>
<li>**<code>borderType</code>**：边框类型，这个就是需要关注的填充方式，详情请参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5"> BorderTypes </a>   下图中第二个镜面反射是默认的边框类型</li>
<li><img src="D:\typora\src\image-20211015211738420.png" alt="image-20211015211738420"></li>
</ul>
<p>其中默认方式和固定值方式最常用，我们详细说明一下：</p>
<h4 id="固定值填充"><a href="#固定值填充" class="headerlink" title="固定值填充"></a>固定值填充</h4><p>顾名思义，<code>cv2.BORDER_CONSTANT</code>这种方式就是边框都填充成一个固定的值，比如下面的程序都填充0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;6_by_6.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定值边框，统一都填充0也称为zero padding</span></span><br><span class="line">cons = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_CONSTANT, value=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(cons)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_zero_padding_output.jpg" alt="img"></p>
<h3 id="默认边框类型"><a href="#默认边框类型" class="headerlink" title="默认边框类型"></a>默认边框类型</h3><p>默认边框<code>cv2.BORDER_DEFAULT</code>其实是取镜像对称的像素填充，比较拗口，一步步解释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_DEFAULT)</span><br><span class="line"><span class="built_in">print</span>(default)</span><br></pre></td></tr></table></figure>

<p>首先进行上下填充，填充成与原图像边界对称的值，如下图：</p>
<p><img src="http://cos.codec.wang/cv2_up_down_padding_first.jpg" alt="img"></p>
<p>同理再进行左右两边的填充，最后把四个顶点补充上就好了：</p>
<p><img src="http://cos.codec.wang/cv2_right_left_padding_second2.jpg" alt="img"></p>
<blockquote>
<p>经验之谈：一般情况下默认方式更加合理，因为边界的像素值更加接近。具体应视场合而定。</p>
</blockquote>
<h3 id="OpenCV进行卷积"><a href="#OpenCV进行卷积" class="headerlink" title="OpenCV进行卷积"></a><code>OpenCV</code>进行卷积</h3><p><code>OpenCV</code>中用<code>cv2.filter2D()</code>实现卷积操作，比如我们的核是下面这样（3×3区域像素的和除以10）：</p>
<p><img src="D:\typora\src\image-20211015212412694.png" alt="image-20211015212412694"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.float32) / <span class="number">10</span></span><br><span class="line"><span class="comment"># 卷积操作，-1表示通道数与原图相同</span></span><br><span class="line">dst = cv2.filter2D(img, -<span class="number">1</span>, kernel)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_convolution_kernel_3_3.jpg" alt="img"></p>
<p>可以看到这个核对图像进行了模糊处理，这是卷积的众多功能之一。</p>
<h2 id="图像平滑操作"><a href="#图像平滑操作" class="headerlink" title="图像平滑操作"></a>图像平滑操作</h2><h3 id="滤波与模糊"><a href="#滤波与模糊" class="headerlink" title="滤波与模糊"></a>滤波与模糊</h3><p>关于滤波和模糊:</p>
<ul>
<li>它们都属于卷积，不同滤波方法之间只是卷积核不同（对线性滤波而言）</li>
<li>低通滤波器是模糊，高通滤波器是锐化</li>
</ul>
<p><strong>低通滤波器</strong>就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。<strong>高通滤波器</strong>则反之，用来增强图像边缘，进行锐化处理。</p>
<blockquote>
<p>常见噪声有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958?fr=aladdin">椒盐噪声</a>(脉冲噪声)和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。</p>
</blockquote>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p>
<p><img src="D:\typora\src\image-20211016133058089.png" alt="image-20211016133058089"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line">blur = cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 均值模糊</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有的滤波函数都有一个可选参数borderType，这个参数就是<em><strong>卷积基础–图形边框</strong></em>中所说的边框填充方式。</p>
</blockquote>
<h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p>
<p><img src="D:\typora\src\image-20211016133349723.png" alt="image-20211016133349723"></p>
<p>用<code>cv2.boxFilter()</code>函数实现，当可选参数normalize为True的时候，方框滤波就是均值滤波，上式中的a就等于1&#x2F;9；normalize为False的时候，a&#x3D;1，相当于求区域内的像素和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span></span><br><span class="line">blur = cv2.boxFilter(img, -<span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>), normalize=<span class="literal">True</span>) <span class="comment">#卷积操作 -1表示通道数与原图相同</span></span><br></pre></td></tr></table></figure>

<h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小，还记得标准正态分布的曲线吗？</p>
<p><img src="http://cos.codec.wang/cv2_gaussian_kernel_function_theory.jpg" alt="img"></p>
<p>显然这种处理元素间权值的方式更加合理一些。图像是2维的，所以我们需要使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gaussian_filter">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核（具体原理和卷积核生成方式请参考文末的<a target="_blank" rel="noopener" href="http://codec.wang/#/">番外小篇</a>）：</p>
<p><img src="D:\typora\src\image-20211016133709083.png" alt="image-20211016133709083"></p>
<p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;gaussian_noise.bmp&#x27;</span>)</span><br><span class="line"><span class="comment"># 均值滤波vs高斯滤波</span></span><br><span class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></span><br><span class="line">gaussian = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">1</span>)  <span class="comment"># 高斯滤波</span></span><br></pre></td></tr></table></figure>

<p>参数3 σx值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p>
<p><img src="http://cos.codec.wang/cv2_gaussian_vs_average.jpg" alt="img"></p>
<h4 id="高斯滤波卷积核-OpenCV中7-7以下的卷积核是算好了的。"><a href="#高斯滤波卷积核-OpenCV中7-7以下的卷积核是算好了的。" class="headerlink" title="高斯滤波卷积核   OpenCV中7*7以下的卷积核是算好了的。"></a>高斯滤波卷积核   OpenCV中7*7以下的卷积核是算好了的。</h4><p><img src="D:\typora\src\image-20211016134947978.png" alt="image-20211016134947978"></p>
<p>我们可以用<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv2.getGaussianKernel(ksize,sigma)</code></a>来生成一维卷积核：</p>
<ul>
<li>sigma&lt;&#x3D;0时，<code>sigma=0.3*((ksize-1)*0.5 - 1) + 0.8</code></li>
<li>sigma&gt;0时，sigma&#x3D;sigma</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(cv2.getGaussianKernel(<span class="number">3</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 结果：[[0.25][0.5][0.25]]</span></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20211016135226745.png" alt="image-20211016135226745"></p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>中值又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，<strong>适用于去除椒盐噪声和斑点噪声</strong>。中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p>
<p>比如下面这张斑点噪声图，用中值滤波显然更好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;salt_noise.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 均值滤波vs中值滤波</span></span><br><span class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></span><br><span class="line">median = cv2.medianBlur(img, <span class="number">5</span>)  <span class="comment"># 中值滤波</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_median_vs_average.jpg" alt="img"></p>
<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2">双边滤波</a>。用<code>cv2.bilateralFilter()</code>函数实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 双边滤波vs高斯滤波</span></span><br><span class="line">gau = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)  <span class="comment"># 高斯滤波</span></span><br><span class="line">blur = cv2.bilateralFilter(img, <span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>)  <span class="comment"># 双边滤波</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_bilateral_vs_gaussian.jpg" alt="img"></p>
<p><strong>双边滤波明显保留了更多边缘信息，但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code>。</li>
<li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code>。</li>
<li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code>。</li>
<li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。</li>
<li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37">cv2.blur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3">cv2.boxFilter()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1">cv2.GaussianBlur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa">cv2.getGaussianKernel()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9">cv2.medianBlur()</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed">cv2.bilateralFilter()</a></li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html">图像平滑处理</a></li>
</ul>
<h2 id="图像梯度（理论基础）："><a href="#图像梯度（理论基础）：" class="headerlink" title="图像梯度（理论基础）："></a>图像梯度（理论基础）：</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2334bee37de5">https://www.jianshu.com/p/2334bee37de5</a></p>
<p>低通滤波器是模糊，高通滤波器是锐化</p>
<h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YZ4y1s7Ra?from=search&amp;seid=18409194473369625551&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1YZ4y1s7Ra?from=search&amp;seid=18409194473369625551&amp;spm_id_from=333.337.0.0</a></p>
<p>水平方向的边界  也就是左右的；  就是假如这里是边界，那么P5的左右两边他P4和P6的值会相差很大，然后P5的值算出来就会很明显，如果P4和P6很接近那么计算的P5就会很接近0  没那么明显  然后就可以根据这个计算出图像的边界。</p>
<img src="D:\typora\src\image-20211016140326016.png" alt="image-20211016140326016" style="zoom:50%;" />

<p>同理。垂直方向就是吧卷积核改一下</p>
<img src="D:\typora\src\image-20211016140853557.png" alt="image-20211016140853557" style="zoom:50%;" />

<p>垂直方向和水平方向的梯度都计算出来了  那么图像的梯度就可以计算</p>
<img src="D:\typora\src\image-20211016140939825.png" alt="image-20211016140939825" style="zoom:50%;" />

<img src="D:\typora\src\image-20211016141022498.png" alt="image-20211016141022498" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#代码表示</span></span><br><span class="line">sobelx = cv2.Sobel(img, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算x方向</span></span><br><span class="line">sobely = cv2.Sobel(img, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算y方向</span></span><br></pre></td></tr></table></figure>



<h3 id="Laplacian（拉普拉斯）算子"><a href="#Laplacian（拉普拉斯）算子" class="headerlink" title="Laplacian（拉普拉斯）算子"></a><img src="http://cos.codec.wang/cv2_horizen_vertical_edge_detection.jpg" alt="垂直和水平边界下降">Laplacian（拉普拉斯）算子</h3><p>拉普拉斯算子类似于<strong>二阶</strong>Sobel导数。</p>
<p>在OpenCV中通过调用sobel算子来计算拉普拉斯算子，使用公式：</p>
<p><img src="D:\typora\src\image-20211016142426256.png" alt="image-20211016142426256"></p>
<p>使用卷积核：</p>
<p><img src="D:\typora\src\image-20211016142440656.png" alt="image-20211016142440656"></p>
<p>就算出来就是上下左右全部减一次中间，然后再相加</p>
<img src="D:\typora\src\image-20211017095425784.png" alt="image-20211017095425784"  />

<p>然后判断的依据和sobel算子类似，值小那就是梯度值小，非边界，值大就是梯度大，是边界</p>
<p>OpenCV中直接使用<code>cv2.Laplacian()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(img, -<span class="number">1</span>)  <span class="comment"># 使用Laplacian算子</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_laplacian.jpg" alt="img"></p>
<p>也可如此理解，更加深入一点。</p>
<p><img src="D:\typora\src\image-20211016142242956.png" alt="image-20211016142242956"></p>
<h2 id="边缘检测："><a href="#边缘检测：" class="headerlink" title="边缘检测："></a>边缘检测：</h2><p>cv2.Canny()</p>
<p>Canny边缘检测方法被誉为边缘检测的最优方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(img, <span class="number">30</span>, <span class="number">70</span>)  <span class="comment"># canny边缘检测</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;canny&#x27;</span>, np.hstack((img, edges)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>之前采用低通滤波模糊图片，也就是去噪点，而想要得到图像边缘就需要用到高通滤波，锐化图像</p>
<h3 id="Canny边界检测"><a href="#Canny边界检测" class="headerlink" title="Canny边界检测"></a>Canny边界检测</h3><ol>
<li><p>使用5×5高斯排除噪音：</p>
<p>边缘操作本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理</p>
</li>
<li><p>计算图像梯度方向</p>
</li>
</ol>
<p>   使用sobel算子计算两个方向上的GX和GY，然后算出梯度方向：</p>
<p>   <img src="D:\typora\src\image-20211017100727722.png" alt="image-20211017100727722"></p>
<ol start="3">
<li>取局部极大值：</li>
</ol>
<p>   梯度已经有了轮廓，但为了进一步筛选，可以从（0°&#x2F;45°&#x2F;90°&#x2F;135°）这四个角度方向上取局部极大值</p>
<p>   比如A点在45°方向上大于B&#x2F;C点，那就保留A然后将B&#x2F;C设置为0.</p>
<p>   <img src="http://cos.codec.wang/cv2_understand_canny_direction.jpg" alt="img"></p>
<ol start="4">
<li>滞后阈值：Canny推荐的高低阈值比在2:1到3:1之间。</li>
</ol>
<p>   经过前面三步，就只剩下0和可能的边缘梯度值了，为了最终确定下来，需要设定高低阈值：</p>
<pre><code>   像素点的值大于最高阈值,那肯定是边缘
   
   像素值小于最低阈值那肯定不是边缘
   
   像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘
</code></pre>
<p>   AC是边缘   B不是。</p>
<p>   <img src="http://cos.codec.wang/cv2_understand_canny_max_min_val.jpg" alt="img"></p>
<h3 id="先阈值分割后检测"><a href="#先阈值分割后检测" class="headerlink" title="先阈值分割后检测"></a>先阈值分割后检测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)  <span class="comment">#自适应阈值分割 python中如果某个值不用，可以用下划线代替</span></span><br><span class="line">edges = cv2.Canny(thresh, <span class="number">30</span>, <span class="number">70</span>)  <span class="comment">#边缘检测，上阈值70 ，下阈值30</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;canny&#x27;</span>, np.hstack((img, thresh, edges)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_canny_edge_detection_threshold.jpg"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#滑动条调节阈值，理解高地阈值效果：</span><br><span class="line">import cv2</span><br><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">def track<span class="constructor">_back(<span class="params">x</span>)</span>:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">ori_img=cv2.imread(&#x27;<span class="module-access"><span class="module"><span class="identifier">NV</span>.</span></span>jpg&#x27;,<span class="number">0</span>)</span><br><span class="line">cv2.named<span class="constructor">Window(&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">cv2.create<span class="constructor">Trackbar(&#x27;<span class="params">upper</span>&#x27;,&#x27;<span class="params">window</span>&#x27;,100,255,<span class="params">track_back</span>)</span></span><br><span class="line">cv2.create<span class="constructor">Trackbar(&#x27;<span class="params">low</span>&#x27;,&#x27;<span class="params">window</span>&#x27;,200,255,<span class="params">track_back</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(True):</span><br><span class="line">    upper_= cv2.get<span class="constructor">TrackbarPos(&#x27;<span class="params">upper</span>&#x27;,&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">    low_=cv2.get<span class="constructor">TrackbarPos(&#x27;<span class="params">low</span>&#x27;,&#x27;<span class="params">window</span>&#x27;)</span></span><br><span class="line">    edges=cv2.<span class="constructor">Canny(<span class="params">ori_img</span>,<span class="params">low_</span>,<span class="params">upper_</span>)</span></span><br><span class="line">    cv2.imshow(&#x27;window&#x27;,edges)</span><br><span class="line">    <span class="keyword">if</span> cv2.wait<span class="constructor">Key(30)</span>==ord(<span class="character">&#x27;q&#x27;</span>):  #键入 q 关闭窗口   记得一定不要设置为<span class="number">0</span>  无限等待  不然循环无法进行下去</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h2 id="腐蚀与膨胀"><a href="#腐蚀与膨胀" class="headerlink" title="腐蚀与膨胀"></a>腐蚀与膨胀</h2><p>形态学操作  腐蚀  膨胀  开运算和闭运算</p>
<p>cv2.erode()  cv2.dilate()  cv2.morpho;ogyEx()</p>
<h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p><code>cv2.erode(src, kernel, iteration)</code></p>
<p>参数说明：</p>
<p>src表示图片 </p>
<p>kernel指腐蚀操作的内核，默认是一个简单的3X3矩阵，我们也可以利用<code>getStructuringElement（）</code>函数指明它的形状</p>
<p>iterations指的是腐蚀次数，省略是默认为1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;j.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8) <span class="comment">#指定核大小</span></span><br><span class="line">erosion = cv2.erode(img, kernel)  <span class="comment"># 腐蚀</span></span><br></pre></td></tr></table></figure>

<p>这个核也叫结构元素，因为形态学操作其实也是应用卷积来实现的结构元素可以是矩形&#x2F;椭圆&#x2F;十字形，可以用。<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 矩形结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 椭圆结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 十字形结构</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_morphological_struct_element.jpg" alt="img"></p>
<h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p><code>dilate()</code>可以对输入图像用特定结构元素进行膨胀操作，该结构元素确定膨胀操作过程中的邻域的形状，各点像素值将被替换为对应邻域上的最大值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dilation = cv2.dilate(img, kernel)  <span class="comment"># 膨胀</span></span><br></pre></td></tr></table></figure>

<h3 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h3><p><code>cv2.morphologyEx()</code></p>
<p>先腐蚀后膨胀开运算 </p>
<p>作用：分开物体，分解区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 定义结构元素  矩形结构</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;j_noise_out.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></span><br></pre></td></tr></table></figure>

<h3 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h3><p>先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除&#x2F;“闭合”物体里面的小黑洞，所以叫闭运算）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;j_noise_in.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></span><br></pre></td></tr></table></figure>

<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul>
<li>形态学梯度：膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;school.bmp&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_morphological_gradient.jpg" alt="img"></p>
<ul>
<li>顶帽：原图减去开运算后的图：<code>src - opening</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<ul>
<li>黑帽：闭运算后的图减去原图：<code>closing - src</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>

<h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p><img src="https://img-blog.csdnimg.cn/20200622220127452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5czQzMDM4MV8x,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>轮廓是连续的，边缘并不全都连续</strong>（下图）。其实<strong>边缘主要是作为图像的特征使用</strong>，比如可以用边缘特征可以区分脸和手，而<strong>轮廓主要用来分析物体的形态</strong>，比如物体的周长和面积等，可以说边缘包括轮廓。</p>
<p><img src="http://cos.codec.wang/cv2_understand_contours.jpg" alt="边缘和轮廓的区别"></p>
<p><strong>寻找轮廓一般用于二值化图像，所以通常会使用阈值分割或者Canny边缘检测得到二值图</strong></p>
<p>寻找轮廓是针对白色物体的，一定要保证物体是白色，背景是黑色，不然很多人在新专辑轮廓是会找到图片最外面的一个框</p>
<h3 id="第一步：寻找轮廓"><a href="#第一步：寻找轮廓" class="headerlink" title="第一步：寻找轮廓"></a>第一步：寻找轮廓</h3><p>使用<code>cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]])</code></p>
<p>返回两个值：contours;hierarchy</p>
<p>参数：</p>
<p>image 表示寻找轮廓的图像</p>
<p>mode表示轮廓的检索模式，有四种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.RETR_EXTERNAL   <span class="comment">#表示只检测外轮廓</span></span><br><span class="line">cv2.RETR_LIST   <span class="comment">#检测的轮廓不建立等级关系</span></span><br><span class="line">cv2.RETR_CCOMP <span class="comment">#建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。</span></span><br><span class="line">cv2.RETR_TREE   <span class="comment">#建立一个等级树结构的轮廓</span></span><br></pre></td></tr></table></figure>
<p>method是轮廓的近似方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.CHAIN_APPROX_NONE<span class="comment">#存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即max（abs（x1-x2），abs（y2-y1））==1</span></span><br><span class="line">cv2.CHAIN_APPROX_SIMPLE<span class="comment">#压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息</span></span><br><span class="line">cv2.CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain <span class="comment">#近似算法</span></span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line">img = cv2.imread(<span class="string">&#x27;D:\\test\\contour.jpg&#x27;</span>)</span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"> </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  <span class="comment">#寻找轮廓</span></span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>原图：<img src="https://img-blog.csdn.net/20131030153346984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VubnkyMDM4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:33%;" />检测图<img src="https://img-blog.csdn.net/20131030153441656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VubnkyMDM4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:33%;" /></p>
<p><strong>findcontours函数会“原地”修改输入的图像</strong>  也就是说原图被改变了</p>
<p><strong>contour返回值</strong><br>    cv2.findContours()函数首先返回一个list，list中每个元素都是图像中的一个轮廓，用numpy中的ndarray表示。这个概念非常重要。在下面drawContours中会看见。通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(contours))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(contours[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours))</span><br><span class="line"><span class="comment">#可以验证上述信息。会看到本例中有两条轮廓，一个是五角星的，一个是矩形的。每个轮廓是一个ndarray，每个ndarray是轮廓上的点的集合。</span></span><br><span class="line">由于我们知道返回的轮廓有两个，因此可通过</span><br><span class="line">cv2.drawContours(img,contours,<span class="number">0</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line">和</span><br><span class="line">cv2.drawContours(img,contours,<span class="number">1</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">分别绘制两个轮廓，关于该参数可参见下面一节的内容。同时通过</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(contours[<span class="number">1</span>]))</span><br><span class="line">输出两个轮廓中存储的点的个数，可以看到，第一个轮廓中只有<span class="number">4</span>个元素，这是因为轮廓中并不是存储轮廓上所有的点，而是只存储可以用直线描述轮廓的点的个数，比如一个“正立”的矩形，只需<span class="number">4</span>个顶点就能描述轮廓了。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>hierarchy返回值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">此外，该函数还可返回一个可选的hiararchy结果，这是一个ndarray，其中的元素个数和轮廓个数相同，每个轮廓contours[i]对应<span class="number">4</span>个hierarchy元素hierarchy[i][<span class="number">0</span>] ~hierarchy[i][<span class="number">3</span>]，分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，则该值为负数。</span><br><span class="line">通过</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(hierarchy))</span><br><span class="line"><span class="built_in">print</span> (hierarchy.ndim)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span> (hierarchy[<span class="number">0</span>].ndim)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span> (hierarchy.shape) <span class="comment"># (1, 2, 4)</span></span><br></pre></td></tr></table></figure>

<h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><img src="D:\typora\src\image-20211018233258899.png" alt="image-20211018233258899" style="zoom:150%;" />

<p><code>cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset ]]]]])</code></p>
<p>第一个参数是指明在哪幅图像上绘制轮廓；<br>第二个参数是轮廓本身，在Python中是一个list。<br>第三个参数指定绘制轮廓list中的哪条轮廓，如果是-1，则绘制其中的所有轮廓。</p>
<p>后面的参数很简单。其中thickness表明轮廓线的宽度，如果是-1（cv2.FILLED），则为填充模式。绘制参数将在以后独立详细介绍。</p>
<h2 id="轮廓层级"><a href="#轮廓层级" class="headerlink" title="轮廓层级"></a>轮廓层级</h2><p>很多情况下，图像中的形状之间是有关联的</p>
<p><img src="http://cos.codec.wang/cv2_understand_hierarchy.jpg" alt="img"></p>
<p>图中总共有8条轮廓，2和2a分别表示外层和里层的轮廓，3和3a也是一样。从图中看得出来：</p>
<ul>
<li>轮廓0&#x2F;1&#x2F;2是最外层的轮廓，我们可以说它们处于同一轮廓等级：0级</li>
<li>轮廓2a是轮廓2的子轮廓，反过来说2是2a的父轮廓，轮廓2a算一个等级：1级</li>
<li><strong>同样3是2a的子轮廓，轮廓3处于一个等级：2级</strong></li>
<li>类似的，3a是3的子轮廓</li>
</ul>
<p>这里面OpenCV关注的就是两个概念：<strong>同一轮廓等级</strong>和<strong>轮廓间的子属关系</strong>。</p>
<h3 id="OpenCV中轮廓等级的表示"><a href="#OpenCV中轮廓等级的表示" class="headerlink" title="OpenCV中轮廓等级的表示"></a>OpenCV中轮廓等级的表示</h3><p>如果我们打印出<code>cv2.findContours()</code>函数的返回值hierarchy，会发现它是一个包含4个值的数组：**[Next, Previous, First Child, Parent]**</p>
<ul>
<li><em>Next：与当前轮廓处于同一层级的下一条轮廓</em></li>
</ul>
<p>举例来说，前面图中跟0处于同一层级的下一条轮廓是1，所以Next&#x3D;1；同理，对轮廓1来说，Next&#x3D;2；<em>那么没有与它同一层级的轮廓的下一条轮廓了时，此时Next&#x3D;-1。</em></p>
<ul>
<li><em>Previous：与当前轮廓处于同一层级的上一条轮廓</em></li>
</ul>
<p>跟前面一样，对于轮廓1来说，Previous&#x3D;0；对于轮廓2，Previous&#x3D;1；对于轮廓1，没有上一条轮廓了，所以Previous&#x3D;-1。</p>
<ul>
<li><em>First Child：当前轮廓的第一条子轮廓</em></li>
</ul>
<p>比如对于轮廓2，第一条子轮廓就是轮廓2a，所以First Child&#x3D;2a；对轮廓3a，First Child&#x3D;4。</p>
<ul>
<li><em>Parent：当前轮廓的父轮廓</em></li>
</ul>
<p>比如2a的父轮廓是2，Parent&#x3D;2；轮廓2没有父轮廓，所以Parent&#x3D;-1。</p>
<p>下面我们通过代码验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.读入图片</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;hierarchy.jpg&#x27;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, thresh = cv2.threshold(img_gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.寻找轮廓</span></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.绘制轮廓</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(contours),hierarchy)  <span class="comment"># 8条</span></span><br><span class="line">cv2.drawContours(img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)  <span class="comment">#画出所有的轮廓  红色线条</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经验之谈：OpenCV中找到的轮廓序号跟前面讲的不同噢，如下图：</p>
</blockquote>
<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_TREE.jpg" alt="img"></p>
<p>现在既然我们了解了层级的概念，那么类似cv2.RETR_TREE的轮廓寻找方式又是啥意思呢？</p>
<h3 id="轮廓寻找方式"><a href="#轮廓寻找方式" class="headerlink" title="轮廓寻找方式"></a>轮廓寻找方式</h3><p>OpenCV中有四种轮廓寻找方式<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71">RetrievalModes</a>，下面分别来看下：</p>
<h3 id="1-RETR-LIST"><a href="#1-RETR-LIST" class="headerlink" title="1. RETR_LIST"></a>1. RETR_LIST</h3><p>这是最简单的一种寻找方式，它不建立轮廓间的子属关系，也就是所有轮廓都属于同一层级。这样，hierarchy中的后两个值[First Child, Parent]都为-1。比如同样的图，我们使用cv2.RETR_LIST来寻找轮廓：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, _, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(hierarchy)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">3</span>  <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">2</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">5</span>  <span class="number">3</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">4</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">7</span>  <span class="number">5</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">6</span> -<span class="number">1</span> -<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>

<p>因为没有从属关系，所以轮廓0的下一条是1，1的下一条是2……</p>
<blockquote>
<p>经验之谈：<strong>如果你不需要轮廓层级信息的话，cv2.RETR_LIST更推荐使用，因为性能更好。</strong></p>
</blockquote>
<h3 id="2-RETR-TREE"><a href="#2-RETR-TREE" class="headerlink" title="2. RETR_TREE"></a>2. RETR_TREE</h3><p>cv2.RETR_TREE就是之前我们一直在使用的方式，它会完整建立轮廓的层级从属关系，前面已经详细说明过了。</p>
<h3 id="3-RETR-EXTERNAL"><a href="#3-RETR-EXTERNAL" class="headerlink" title="3. RETR_EXTERNAL"></a>3. RETR_EXTERNAL</h3><p>这种方式只寻找最高层级的轮廓，也就是它只会找到前面我们所说的3条0级轮廓：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(contours), hierarchy, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]]]</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_EXTERNAL.jpg" alt="img"></p>
<h3 id="4-RETR-CCOMP"><a href="#4-RETR-CCOMP" class="headerlink" title="4. RETR_CCOMP"></a>4. RETR_CCOMP</h3><p>相比之下cv2.RETR_CCOMP比较难理解，但其实也很简单：它把所有的轮廓只分为2个层级，不是外层的就是里层的。结合代码和图片，我们来理解下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(hierarchy)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[[[ <span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">1</span>  <span class="number">3</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">2</span>  <span class="number">5</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span>  <span class="number">4</span>]</span><br><span class="line">  [ <span class="number">7</span>  <span class="number">4</span> -<span class="number">1</span> -<span class="number">1</span>]</span><br><span class="line">  [-<span class="number">1</span>  <span class="number">6</span> -<span class="number">1</span> -<span class="number">1</span>]]]Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hierarchy_RETR_CCOMP.jpg" alt="img"></p>
<blockquote>
<p>注意：使用这个参数找到的轮廓序号与之前不同。</p>
</blockquote>
<p>图中括号里面1代表外层轮廓，2代表里层轮廓。比如说对于轮廓2，Next就是4，Previous是1，它有里层的轮廓3，所以First Child&#x3D;3，但因为只有两个层级，它本身就是外层轮廓，所以Parent&#x3D;-1。大家可以针对其他的轮廓自己验证一下。</p>
<h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><img src="http://cos.codec.wang/cv2_min_rect_rect_bounding.jpg" alt="img" style="zoom:50%;" />

<p>在计算轮廓特征前，先寻找轮廓</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以数字3的轮廓为例</span></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="http://cos.codec.wang/cv2_31_handwriting_sample.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;handwriting.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshLEold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以数字3的轮廓为例</span></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>为了便于绘制，我们创建出两幅彩色图，并把轮廓画在第一幅图上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</span><br><span class="line">img_color2 = np.copy(img_color1)</span><br><span class="line">cv2.drawContours(img_color1, [cnt], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)  <span class="comment"># 4386.5</span></span><br></pre></td></tr></table></figure>

<p>注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。</p>
<blockquote>
<p>如果统计二值图中像素点个数，应尽量避免循环，**可以使用<code>cv2.countNonZero()</code>**，更加高效。</p>
</blockquote>
<h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">perimeter = cv2.arcLength(cnt, <span class="literal">True</span>)  <span class="comment"># 585.7</span></span><br></pre></td></tr></table></figure>

<p>参数2表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是True。</p>
<h3 id="图像矩"><a href="#图像矩" class="headerlink" title="图像矩"></a>图像矩</h3><p>矩可以理解为图像的各类几何特征，详情请参考：[<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Image_moment">Image Moments</a>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = cv2.moments(cnt)</span><br></pre></td></tr></table></figure>

<p>M中包含了很多轮廓的特征信息，比如M[‘m00’]表示轮廓面积，与前面<code>cv2.contourArea()</code>计算结果是一样的。质心也可以用它来算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cx, cy = M[<span class="string">&#x27;m10&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>], M[<span class="string">&#x27;m01&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>]  <span class="comment"># (205, 281)</span></span><br></pre></td></tr></table></figure>

<h3 id="外接矩形"><a href="#外接矩形" class="headerlink" title="外接矩形"></a>外接矩形</h3><p>形状的外接矩形有两种，如下图，绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转：</p>
<p><img src="http://cos.codec.wang/cv2_min_rect_rect_bounding.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)  <span class="comment"># 外接矩形</span></span><br><span class="line">cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)Copy to clipboardErrorCopied</span><br><span class="line">rect = cv2.minAreaRect(cnt)  <span class="comment"># 最小外接矩形</span></span><br><span class="line">box = np.int0(cv2.boxPoints(rect))  <span class="comment"># 矩形的四个角点取整</span></span><br><span class="line">cv2.drawContours(img_color1, [box], <span class="number">0</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>其中np.int0(x)是把x取整的操作，比如377.93就会变成377，也可以用x.astype(np.int)。</p>
<h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>外接圆跟外接矩形一样，找到一个能包围物体的最小圆：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(x, y), radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">(x, y, radius) = np.int0((x, y, radius))  <span class="comment"># 圆心和半径取整</span></span><br><span class="line">cv2.circle(img_color2, (x, y), radius, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_min_enclosing_circle.jpg" alt="img"></p>
<h3 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h3><p>我们可以用得到的轮廓拟合出一个椭圆：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ellipse = cv2.fitEllipse(cnt)</span><br><span class="line">cv2.ellipse(img_color2, ellipse, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_fitting_ellipse.jpg" alt="img"></p>
<h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回<strong>值越小，越相似</strong>。先读入下面这张图片：</p>
<p><img src="http://cos.codec.wang/cv2_match_shape_shapes.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;shapes.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)  <span class="comment"># 用于绘制的彩色图</span></span><br></pre></td></tr></table></figure>

<p>图中有3条轮廓，我们用A&#x2F;B&#x2F;C表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cnt_a, cnt_b, cnt_c = contours[<span class="number">0</span>], contours[<span class="number">1</span>], contours[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_b, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.0</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 2.17e-05</span></span><br><span class="line"><span class="built_in">print</span>(cv2.matchShapes(cnt_b, cnt_a, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.418</span></span><br></pre></td></tr></table></figure>

<p>可以看到BC相似程度比AB高很多，并且图形的旋转或缩放并没有影响。其中，参数3是匹配方法，详情可参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f">ShapeMatchModes</a>，参数4是OpenCV的预留参数，暂时没有实现，可以不用理会。</p>
<p>形状匹配是通过图像的Hu矩来实现的(<code>cv2.HuMoments()</code>)，大家如果感兴趣，可以参考：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Image_moment#Rotation_invariant_moments">Hu-Moments</a></p>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p><img src="http://cos.codec.wang/cv2_understand_histogram.jpg" alt="img"></p>
<ul>
<li>计算并绘制直方图</li>
<li>（自适应）直方图均衡化</li>
<li>OpenCV函数：<code>cv2.calcHist()</code>, <code>cv2.equalizeHist()</code></li>
</ul>
<h3 id="啥叫直方图"><a href="#啥叫直方图" class="headerlink" title="啥叫直方图"></a>啥叫直方图</h3><p>简单来说，直方图就是图像中每个像素值的个数统计，比如说一副灰度图中像素值为0的有多少个，1的有多少个……:</p>
<p><img src="http://cos.codec.wang/cv2_understand_histogram.jpg" alt="img"></p>
<p>在计算直方图之前，有几个术语先来了解一下：</p>
<ul>
<li>dims: 要计算的通道数，对于灰度图dims&#x3D;1，普通彩色图dims&#x3D;3</li>
<li>range: 要计算的像素值范围，一般为[0,256)</li>
<li>bins: 子区段数目，如果我们统计0<code>~</code>255每个像素值，bins&#x3D;256；如果划分区间，比如0<code>~</code>15, 16<code>~</code>31…240<code>~</code>255这样16个区间，bins&#x3D;16</li>
</ul>
<h3 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h3><p>OpenCV和Numpy中都提供了计算直方图的函数，我们对比下它们的性能。</p>
<h4 id="OpenCV中直方图计算"><a href="#OpenCV中直方图计算" class="headerlink" title="OpenCV中直方图计算"></a>OpenCV中直方图计算</h4><p>使用<code>cv2.calcHist(images, channels, mask, histSize, ranges)</code>计算，其中：</p>
<ul>
<li>参数1：要计算的原图，以方括号的传入，如：[img]</li>
<li>参数2：类似前面提到的dims，<strong>灰度图写[0]就行，彩色图B&#x2F;G&#x2F;R分别传入[0]&#x2F;[1]&#x2F;[2]</strong></li>
<li>参数3（mask）：要计算的区域，计算整幅图的话，写None</li>
<li>参数4：前面提到的bins</li>
<li>参数5：前面提到的range</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;hist.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.025288 s</span></span><br></pre></td></tr></table></figure>

<h3 id="计算部分图像直方图"><a href="#计算部分图像直方图" class="headerlink" title="计算部分图像直方图"></a>计算部分图像直方图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=cv2.imread(<span class="string">&#x27;hist.jpg&#x27;</span>,<span class="number">0</span>)  <span class="comment"># (1024,683)</span></span><br><span class="line">mask=np.zeros(img.shape,dtype=np.uint8)</span><br><span class="line">mask[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">200</span>]=<span class="number">255</span></span><br><span class="line">hist=cv2.calcHist([img],[<span class="number">0</span>],mask,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\typora\src\image-20211026210142552.png" alt="image-20211026210142552" style="zoom:50%;" /><img src="D:\typora\src\image-20211026210157181.png" alt="image-20211026210157181" style="zoom:50%;" /></p>
<h4 id="Numpy中直方图计算"><a href="#Numpy中直方图计算" class="headerlink" title="Numpy中直方图计算"></a>Numpy中直方图计算</h4><p>也可用Numpy的函数计算，其中<a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html">ravel()</a>函数将二维矩阵展平变成一维数组，之前有提到过：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hist, bins = np.histogram(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.020628 s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经验之谈：Numpy中还有一种更高效的方式：（还记得怎么评估性能吗：代码性能优化]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hist = np.bincount(img.ravel(), minlength=<span class="number">256</span>)  <span class="comment"># 性能：0.003163 s</span></span><br></pre></td></tr></table></figure>

<p>计算出直方图之后，怎么把它画出来呢？</p>
<h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><p>其实Matplotlib自带了一个计算并绘制直方图的功能，不需要用到上面的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>当然，也可以用前面计算出来的结果绘制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_calc_draw_histogram.jpg" alt="img"></p>
<p>从直方图上可以看到图片的大部分区域集中在150偏白的附近，这其实并不是很好的效果，下面我们来看看如何改善它。</p>
<blockquote>
<p>使用OpenCV的画线功能也可以画直方图，不过太麻烦了</p>
</blockquote>
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。其实从观感上就可以发现，前面那幅图对比度不高，偏灰白。对均衡化算法感兴趣的同学可参考：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96">维基百科：直方图均衡化</a></p>
<p><img src="http://cos.codec.wang/cv2_understand_histogram_equalization.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br></pre></td></tr></table></figure>

<p>OpenCV中用<code>cv2.equalizeHist()</code>实现均衡化。我们把两张图片并排显示，对比一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;equalization&#x27;</span>, np.hstack((img, equ)))  <span class="comment"># 并排显示</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_before_after_equalization.jpg" alt="img"></p>
<p><img src="http://cos.codec.wang/cv2_before_after_equalization_histogram.jpg" alt="均衡化前后的直方图对比"></p>
<p>可以看到均衡化后图片的亮度和对比度效果明显好于原图。</p>
<h3 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h3><p>不难看出来，直方图均衡化是应用于整幅图片的，会有什么问题呢？看下图：</p>
<p><img src="http://cos.codec.wang/cv2_understand_adaptive_histogram.jpg" alt="img"></p>
<p>很明显，因为全局调整亮度和对比度的原因，脸部太亮，大部分细节都丢失了。</p>
<p>自适应均衡化就是用来解决这一问题的：它在每一个小区域内（默认8×8）进行直方图均衡化。当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制，所以这个算法全称叫：<strong>对比度受限的自适应直方图均衡化</strong>CLAHE(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization">Contrast Limited Adaptive Histogram Equalization</a>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自适应均衡化，参数可选</span></span><br><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">cl1 = clahe.apply(img)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_adaptive_histogram.jpg" alt="img"></p>
<h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><p>[模板匹配]: <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D">https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D</a>	“模板匹配”</p>
<p>用来在大图中找小图，也就是说在一副图像中寻找另外一张模板图像的位置</p>
<img src="http://cos.codec.wang/cv2_understand_template_matching.jpg" alt="img" style="zoom:50%;" />

<p>用<code>cv2.matchTemplate()</code>实现模板匹配。首先我们来读入图片和模板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;lena.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;face.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]  <span class="comment"># rows-&gt;h, cols-&gt;</span></span><br></pre></td></tr></table></figure>

<p>匹配函数返回的是一副灰度图，最白的地方表示最大的匹配。使用<code>cv2.minMaxLoc()</code>函数可以得到最大匹配值的坐标，以这个点为左上角角点，模板的宽和高画矩形就是匹配的位置了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span></span><br><span class="line">res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF)</span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line"></span><br><span class="line">left_top = max_loc  <span class="comment"># 左上角</span></span><br><span class="line">right_bottom = (left_top[<span class="number">0</span>] + w, left_top[<span class="number">1</span>] + h)  <span class="comment"># 右下角</span></span><br><span class="line">cv2.rectangle(img, left_top, right_bottom, <span class="number">255</span>, <span class="number">2</span>)  <span class="comment"># 画出矩形位置</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_ccoeff_matching_template.jpg" alt="img"></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>这部分可看可不看，不太理解也没关系，还记得前面的方法吗？不懂得就划掉(✿◕‿◕✿)</p>
</blockquote>
<p>模板匹配的原理其实很简单，就是不断地在原图中移动模板图像去比较，有6种不同的比较方法，详情可参考：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d">TemplateMatchModes</a></p>
<ul>
<li>平方差匹配CV_TM_SQDIFF：用两者的平方差来匹配，最好的匹配值为0</li>
<li>归一化平方差匹配CV_TM_SQDIFF_NORMED</li>
<li>相关匹配CV_TM_CCORR：用两者的乘积匹配，数值越大表明匹配程度越好</li>
<li>归一化相关匹配CV_TM_CCORR_NORMED</li>
<li>相关系数匹配CV_TM_CCOEFF：用两者的相关系数匹配，1表示完美的匹配，-1表示最差的匹配</li>
<li>归一化相关系数匹配CV_TM_CCOEFF_NORMED</li>
</ul>
<p>归一化的意思就是将值统一到0~1，这些方法的对比代码可到<a target="_blank" rel="noopener" href="http://codec.wang/#/">源码处</a>查看。模板匹配也是应用卷积来实现的：假设原图大小为W×H，模板图大小为w×h，那么生成图大小是(W-w+1)×(H-h+1)，生成图中的每个像素值表示原图与模板的匹配程度。</p>
<h3 id="匹配多个物体"><a href="#匹配多个物体" class="headerlink" title="匹配多个物体"></a>匹配多个物体</h3><p>前面我们是找最大匹配的点，所以只能匹配一次。我们可以设定一个匹配阈值来匹配多次：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.读入原图和模板</span></span><br><span class="line">img_rgb = cv2.imread(<span class="string">&#x27;mario.jpg&#x27;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;mario_coin.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.标准相关模板匹配</span></span><br><span class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = <span class="number">0.8</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.这边是Python/Numpy的知识，后面解释</span></span><br><span class="line">loc = np.where(res &gt;= threshold)  <span class="comment"># 匹配程度大于%80的坐标y,x</span></span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):  <span class="comment"># *号表示可选参数</span></span><br><span class="line">    right_bottom = (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h)</span><br><span class="line">    cv2.rectangle(img_rgb, pt, right_bottom, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_template_matching_multi.jpg" alt="img"></p>
<p>第3步有几个Python&#x2F;Numpy的重要知识，来大致看下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html">np.where()</a>在这里返回res中值大于0.8的所有坐标，如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(np.where(x &gt; <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果(先y坐标，再x坐标)：(array([2, 2, 2]), array([0, 1, 2]))</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_np_where_function.jpg" alt="img"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/functions.html#zip">zip()</a>函数，功能强大到难以解释，举个简单例子就知道了：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(x, y)))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br></pre></td></tr></table></figure>

<p>这样大家就能理解前面代码的用法了吧：因为loc是先y坐标再x坐标，所以用loc[::-1]翻转一下，然后再用zip函数拼接在一起。</p>
<h2 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h2><p><img src="http://cos.codec.wang/cv2_understand_hough_transform.jpg" alt="img"></p>
<p>学习使用霍夫变换识别出图像中的直线和圆。图片等可到文末引用处下载。</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>理解霍夫变换的实现</li>
<li>分别使用霍夫线变换和圆变换检测图像中的直线和圆</li>
<li>OpenCV函数：<code>cv2.HoughLines()</code>, <code>cv2.HoughLinesP()</code>, <code>cv2.HoughCircles()</code></li>
</ul>
<h3 id="理解霍夫变换"><a href="#理解霍夫变换" class="headerlink" title="理解霍夫变换"></a>理解霍夫变换</h3><p>霍夫变换常用来在图像中提取直线和圆等几何形状，我来做个简易的解释：</p>
<p><img src="http://cos.codec.wang/cv2_understand_hough_transform.jpg" alt="img"></p>
<p>学过几何的都知道，直线可以分别用直角坐标系和极坐标系来表示：</p>
<p><img src="http://cos.codec.wang/cv2_line_expression_in_coordinate.jpg" alt="img"></p>
<p>那么经过某个点(x0,y0)的所有直线都可以用这个式子来表示：</p>
<p>r_\theta&#x3D;x_0\cdot\cos \theta+y_0\cdot\sin \thetarθ&#x3D;x0⋅cosθ+y0⋅sinθ</p>
<p>也就是说每一个(r,θ)都表示一条经过(x0,y0)直线，那么同一条直线上的点必然会有同样的(r,θ)。如果将某个点所有的(r,θ)绘制成下面的曲线，那么同一条直线上的点的(r,θ)曲线会相交于一点：</p>
<p><img src="http://cos.codec.wang/cv2_curve_of_r_theta.jpg" alt="img"></p>
<p>OpenCV中首先计算(r,θ) 累加数，累加数超过一定值后就认为在同一直线上。</p>
<h3 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h3><p>OpenCV中用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的(r,θ)数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.加载图片，转为二值图</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;shapes.jpg&#x27;</span>)</span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.霍夫直线变换</span></span><br><span class="line">lines = cv2.HoughLines(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure>

<p>函数中：</p>
<ul>
<li>参数1：要检测的二值图（一般是阈值分割或边缘检测后的图）</li>
<li>参数2：距离r的精度，值越大，考虑越多的线</li>
<li>参数3：角度θ的精度，值越小，考虑越多的线</li>
<li>参数4：累加数阈值，值越小，考虑越多的线</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.将检测的线画出来（注意是极坐标噢）</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    rho, theta = line[<span class="number">0</span>]</span><br><span class="line">    a = np.cos(theta)</span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a * rho</span><br><span class="line">    y0 = b * rho</span><br><span class="line">    x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (-b))</span><br><span class="line">    y1 = <span class="built_in">int</span>(y0 + <span class="number">1000</span> * (a))</span><br><span class="line">    x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (-b))</span><br><span class="line">    y2 = <span class="built_in">int</span>(y0 - <span class="number">1000</span> * (a))</span><br><span class="line"></span><br><span class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure>

<p><img src="http://cos.codec.wang/cv2_hough_line_function.jpg" alt="img"></p>
<h3 id="统计概率霍夫直线变换"><a href="#统计概率霍夫直线变换" class="headerlink" title="统计概率霍夫直线变换"></a>统计概率霍夫直线变换</h3><p>前面的方法又称为标准霍夫变换，它会计算图像中的每一个点，计算量比较大，另外它得到的是整一条线（r和θ），并不知道原图中直线的端点。所以提出了统计概率霍夫直线变换(Probabilistic Hough Transform)，是一种改进的霍夫变换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line"><span class="comment"># 3.统计概率霍夫线变换</span></span><br><span class="line">lines = cv2.HoughLinesP(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>,</span><br><span class="line">                        minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>前面几个参数跟之前的一样，有两个可选参数：</p>
<ul>
<li><code>minLineLength</code>：最短长度阈值，比这个长度短的线会被排除</li>
<li><code>maxLineGap</code>：同一直线两点之间的最大距离</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.将检测的线画出来</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1, y1, x2, y2 = line[<span class="number">0</span>]</span><br><span class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure>

<p><code>cv2.LINE_AA</code>在之前绘图功能中讲解过，表示抗锯齿线型。</p>
<p><img src="http://cos.codec.wang/cv2_hough_lines_p_function.jpg" alt="img"></p>
<h3 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h3><p>霍夫圆变换跟直线变换类似，只不过线是用(r,θ)表示，圆是用(x_center,y_center,r)来表示，从二维变成了三维，数据量变大了很多；所以一般使用霍夫梯度法减少计算量，对该算法感兴趣的同学可参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circle_Hough_Transform">Circle Hough Transform</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line"><span class="comment"># 2.霍夫圆变换</span></span><br><span class="line">circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">20</span>, param2=<span class="number">30</span>)</span><br><span class="line">circles = np.int0(np.around(circles))</span><br></pre></td></tr></table></figure>



<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h1>]]></content>
      <categories>
        <category>Python-learn</category>
        <category>Python 库</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
        <tag>视觉识别</tag>
      </tags>
  </entry>
  <entry>
    <title>关于书签与书签同步工具的分享</title>
    <url>/2023/04/23/%E5%85%B3%E4%BA%8E%E4%B9%A6%E7%AD%BE%E4%B8%8E%E4%B9%A6%E7%AD%BE%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>Bookmark and sync</p>
<p>纯share blog</p>
<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><h2 id="为什么需要书签"><a href="#为什么需要书签" class="headerlink" title="为什么需要书签"></a>为什么需要书签</h2><p>书签相信大家都不陌生，尤其是对于像我这样高强度冲浪的人来说，书签绝对是必不可少的，互联网花花世界这么大，碰到感兴趣的要是不收藏起来，之后想找无异于大海捞针。</p>
<h2 id="为什么需要BookmarkHub"><a href="#为什么需要BookmarkHub" class="headerlink" title="为什么需要BookmarkHub"></a>为什么需要BookmarkHub</h2><p>Hub在计算机里是集线器的意思，这里BookmarkHub可理解为书签库，这也是接下来我介绍的插件名。</p>
<p>我起初在网络上闲逛时经常用书签把自己感兴趣的东西加入书签栏，久而久之，书签的数量也就与日俱增，各种各样的书签迷人眼。有意思的视频网站、强大的工具网站、感兴趣的文章、常用的学校官网等等等。数量不断增加，种类也是，这时在书签中找记忆中似是而非的网站本身就成为了一个问题。</p>
<span id="more"></span>

<p>当然大多数浏览器或者软件都提供了在书签栏&#x2F;收藏夹中创建文件夹的功能。我们可以网页或者工具的作用或者内容给他分类。但是！这里有俩个情况：</p>
<ul>
<li>我浏览器不止一个Chrome常用于学习或者看CS相关的内容，Firefox则覆盖我生活中方法面面使用浏览器的情况，于此同时我手机用的浏览器也不止一个，夸克、Chrome。至于为什么不能<code>all in one</code>，我的回答是有时候单一的浏览器不能解决所有问题，不得不<code>all in all</code>。那么不同设备&#x2F;浏览器之间的书签便时不一致的，找东西的时候难不成还把所有设备过一遍？太low啦！！</li>
<li>书签栏分类等同于给书签打上了标签，以后找相关的就在这里面找，但是问题来了，并不是所有网站都是单一的，他可能与图片相关因此我将它放在了Photo文件夹，但其实际是一个处理图片的工具。那么我也可以将其放在工具集文件夹中…，怎么办呢？不好找啊。<br><img src="https://s2.loli.net/2023/04/23/OgUR1VsxPYhIQeq.png" alt="image-20230423123944435"></li>
</ul>
<h1 id="怎么办—介绍几个正在用或者用过的工具"><a href="#怎么办—介绍几个正在用或者用过的工具" class="headerlink" title="怎么办—介绍几个正在用或者用过的工具"></a>怎么办—介绍几个正在用或者用过的工具</h1><p>为了解决上述问题，我也找了挺多软件和插件。找到两个非常优秀的开源项目，真的非常nice！！！</p>
<h2 id="BookmarkHub"><a href="#BookmarkHub" class="headerlink" title="BookmarkHub"></a>BookmarkHub</h2><p><a target="_blank" rel="noopener" href="https://github.com/dudor/BookmarkHub">项目地址</a></p>
<p>项目有中文介绍教程，<a target="_blank" rel="noopener" href="https://github.com/dudor/BookmarkHub/blob/main/README_cn.md">教程网址</a></p>
<p>这是一个浏览器插件，目前支持Chrome、Firefox、edge等浏览器<img src="https://s2.loli.net/2023/04/23/GSIfvU8TtqxbWyw.png" alt="image-20230423125026448"></p>
<ul>
<li>简洁，操作及其方便</li>
<li>主打一个各浏览器书签同步其他么得，功能单一但有效</li>
<li>使用 GitHub 的 Gist 记录来存储浏览器的书签—有GitHub账户就行，教程会教你弄，保密性挺好很安全。</li>
</ul>
<p>使用方法（我直接照抄官方文档的，就加了点图）</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/login">登陆</a> GitHub，如果没有账号请点此<a target="_blank" rel="noopener" href="https://github.com/join">注册</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/settings/tokens/new">创建一个可以管理 gist 的 token</a>。</p>
<p>这里Note填BookmarkHub就行，下面token重置时间看你自己了，然后去最下面点创建</p>
<p><img src="https://s2.loli.net/2023/04/23/olWB8m1kUqhsMrZ.png" alt="image-20230423125247278"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://gist.github.com/">创建一个私有的 gist</a>。<strong>注意：如果是公开的 gist，你的书签是可以被他人搜索到的。</strong></p>
<p><img src="https://s2.loli.net/2023/04/23/i8hNzVIGlRCZnr6.png" alt="image-20230423125444413"></p>
</li>
<li><p>在你用的浏览器的应用商店下载 BookmarkHub，点击插件的设置按钮，在弹出的设置窗口填入 token 和 gist ID，然后你就可以上传下载书签了。</p>
<ul>
<li><p>这个token点设置里面的get token去弄就行。</p>
</li>
<li><p>gist ID 就是你在上一步创建的时候，网址框最后那一串<img src="C:\knowledge\blog\BLOG\source_posts\assets\image-20230423125925463.png" alt="image-20230423125925463"></p>
</li>
</ul>
</li>
</ol>
<h3 id="BookmarkHub如何解决第二个问题"><a href="#BookmarkHub如何解决第二个问题" class="headerlink" title="BookmarkHub如何解决第二个问题"></a>BookmarkHub如何解决第二个问题</h3><p>从上面功能描述来看，只可以解决第一个问题，第二个怎么办呢？</p>
<p>hhhh，软件没办法，但是可以从书签入手。火狐提供了书签描述、Chrome的话就只可以在书签名字做手脚，在名字后面加功能描述或者书签就行。在搜索框搜索就可以检索出来。</p>
<h2 id="xBrowserSync—同时解决两个问题"><a href="#xBrowserSync—同时解决两个问题" class="headerlink" title="xBrowserSync—同时解决两个问题"></a>xBrowserSync—同时解决两个问题</h2><p><a target="_blank" rel="noopener" href="https://www.xbrowsersync.org/">官方网站</a></p>
<p>emmm，说在前面，使用和介绍全是纯英文的。</p>
<ul>
<li><p>支持浏览器书签同步(插件)、手机同样可以通过app进行同步</p>
<img src="https://s2.loli.net/2023/04/23/N1me7OTgfBiYZ3d.png" alt="image-20230423130406192" style="zoom:50%;" />
</li>
<li><p>保护隐私安全—完全匿名、不用注册</p>
</li>
<li><p>不仅可以同步，还可以<strong>添加描述和标签来丰富你的本地浏览器书签</strong>，所有可以直接解决第二个问题</p>
</li>
</ul>
<p>相比于上一个，功能更强大了，但是安装和使用可能没那么简单，具体的装上用就是，上手即用。具体看其提供的Guide</p>
<ol>
<li><p>浏览器安装，然后设置密码</p>
<p><img src="https://s2.loli.net/2023/04/23/JNu5C3sTmL6njIS.png" alt="image-20230423132118064"></p>
</li>
<li><p>然后点sync，就ok啦，后面的就是日常使用了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>开源软件</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>开源软件</tag>
        <tag>书签</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用Socket获取IP地址-顺便初学Socket</title>
    <url>/2023/07/26/python%E4%BD%BF%E7%94%A8Socket%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80-%E9%A1%BA%E4%BE%BF%E5%88%9D%E5%AD%A6Socket-md/</url>
    <content><![CDATA[<p>偶然看的一个使用Socket获取本机IP的方式，感觉还挺有意思的，于是便有了这篇Blog，同时通过这个简单的项目，初步了解下在网络通信里面经常看的的Socket。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_host_ip</span>():</span><br><span class="line">    ip = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">with</span> closing(socket.socket(socket.AF_INET,socket.SOCK_STREAM)) <span class="keyword">as</span> _socket:</span><br><span class="line">        _socket.connect((<span class="string">&#x27;1.1.1.1&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">        ip = _socket.getsockname()[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(ip) <span class="comment"># 192.168.1.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_host_ip()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>从代码可以看出核心是socket模块，无论是<code>connect</code>还是<code>getsockname</code>都是其中的方法。因此我们最好可以先简单学习一下—Socket(套接字)</p>
</li>
<li><p>在学习过程中，有这样一个概念—当你使用<code>connect()</code>方法将<strong>套接字连接到远程主机时，套接字对象的本地<code>IP</code>地址是由操作系统自动分配的。操作系统通常会使用本机上的一个可用IP地址作为套接字对象的本地<code>IP</code>地址，这个<code>IP</code>地址通常是本机的一个局域网<code>IP</code>地址或公网<code>IP</code>地址，取决于本机与远程主机之间的网络环境。</strong></p>
</li>
<li><p>同时，再看<code>getsockname</code>方法的作用—用于获取套接字的本地地址和端口号。它返回一个元组，包含套接字绑定的本地地址和端口号。这个本地地址可以用于告诉其他套接字如何连接到它。</p>
</li>
<li><p>这样一来，上面代码的作用就知道了，先创建一个<code>Socket</code>对象<code>_socket</code>，随后将其与<code>(&#39;1.1.1.1&#39;, 80)</code>建立连接，客户端发送的是一个 TCP 连接请求。这里的80指的是端口号，一般是对于Web服务的端口—<strong>在使用网络编程时，便于正确地指定端口号，因此需要对其有一定的了解</strong>，比如DNS使用的53端口。</p>
</li>
<li><p>然后我可以通过<code>_socket.getsockname()</code>，获取操作系统自动给套接字分配的<code>ip</code>地址，通常是本机的一个局域网<code>IP</code>地址或公网<code>IP</code>地址。</p>
</li>
</ul>
<blockquote>
<p>可以注意到，在上面代码中使用的with语句与我们平时见到的不一样，它后面还使用了contextlib.closing()方法，这是为什么呢？</p>
<p> contextlib.closing() <strong>方法可以将一个对象封装成上下文管理器</strong>，使其在使用完毕后自动关闭。而<strong>with 语句是一种上下文管理器</strong>，可以自动管理资源的生命周期，一旦代码块执行完毕，无论是否发生异常，with语句会自动调用资源的__exit__()方法来关闭资源。</p>
<p>并不是所有的资源都是上下文管理器，也就是说，<strong>并不是所有的资源都可以直接使用with语句来关闭</strong>。这时就**可以使用contextlib.closing()方法来将资源包装成上下文管理器，以便能够在with语句中使用</p>
</blockquote>
<p>python官方关于socket的介绍可以看<a href="https://link.zhihu.com/?target=http://docs.python.org/library/socket.html">这里</a></p>
<p>后续，基于上面所使用到的内容，初步学习一下。</p>
<span id="more"></span>

<h1 id="with语句结合contextlib-closing"><a href="#with语句结合contextlib-closing" class="headerlink" title="with语句结合contextlib.closing"></a><code>with</code>语句结合<code>contextlib.closing</code></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `contextlib.closing(xxx)`的原理如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">closing</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Context to automatically close something at the end of a block.</span></span><br><span class="line"><span class="string">    Code like this:</span></span><br><span class="line"><span class="string">        with closing(&lt;module&gt;.open(&lt;arguments&gt;)) as f:</span></span><br><span class="line"><span class="string">            &lt;block&gt;</span></span><br><span class="line"><span class="string">    is equivalent to this:</span></span><br><span class="line"><span class="string">        f = &lt;module&gt;.open(&lt;arguments&gt;)</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            &lt;block&gt;</span></span><br><span class="line"><span class="string">        finally:</span></span><br><span class="line"><span class="string">            f.close()</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, thing</span>):</span><br><span class="line">        self.thing = thing</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.thing</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, *exc_info</span>):</span><br><span class="line">        self.thing.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>closing</code> 类包含了一个构造方法和两个特殊方法：<code>__enter__</code> 和 <code>__exit__</code>。<code>__init__</code> 方法用于初始化 <code>closing</code> 对象，接受一个参数 <code>thing</code>，表示需要关闭的对象。</li>
<li><code>__enter__</code> 方法返回 <code>thing</code>，即需要关闭的对象，表示进入 <code>with</code> 语句块时要执行的操作。</li>
<li><code>__exit__</code> 方法在 <code>with</code> 语句块执行完毕后被调用，表示退出 <code>with</code> 语句块时要执行的操作。在 <code>__exit__</code> 方法中，调用 <code>thing.close()</code> 方法可以关闭 <code>thing</code> 对象，释放占用的资源。</li>
<li>使用 <code>closing</code> 结合<code>with</code>可以将代码从繁琐的 <code>try/finall</code>y 代码块中解放出来.</li>
</ul>
<h1 id="到底什么是socket？"><a href="#到底什么是socket？" class="headerlink" title="到底什么是socket？"></a>到底什么是socket？</h1><p><strong>Socket是一个抽象层，它提供了一种通用的接口，让应用程序可以使用不同的协议进行网络通信。</strong></p>
<p>我们先看wiki对socket的描述，这可能需要对于计算机网络有一个初步认识 — <strong>socket是一种操作系统提供的进程间通信机制</strong></p>
<blockquote>
<p>网络套接字（英语：Network socket；又译网络套接字、网络接口、网络插槽）在计算机科学中是电脑网络中进程间资料流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。 </p>
<p>socket是一种操作系统提供的进程间通信机制。</p>
<p>  在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行资料交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。 </p>
<p>  在套接字接口中，以IP地址及端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连线后，再加上使用的协议（protocol），这个五元组（fiveelement tuple），作为套接字对（socket pairs），之后就可以彼此交换资料。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将资料送达特定的进程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。 </p>
</blockquote>
<p>​     </p>
<p>是不是看完有点迷糊？我们形象的理解下。</p>
<blockquote>
<p>想象一下你和你的朋友们在玩一个网络游戏，你们需要在游戏中进行实时的聊天和数据交换。这时，每个人的电脑就像是一个节点，而节点之间的数据交换需要通过网络进行。  </p>
<p> 为了实现这个数据交换，每个电脑上的游戏程序需要使用套接字接口来创建一个socket。这个socket会有一个唯一的IP地址和端口号，表示这个socket的地址。在这个游戏中，每个玩家都需要创建一个socket，使得他们能够相互交换数据。</p>
<p>当你发送一条消息给你的朋友时，你的游戏程序会将这条消息写入你创建的socket中，然后通过网络将这条消息发送给你的朋友的电脑。当你的朋友的电脑接收到这条消息时，他的游戏程序会从他创建的socket中读取这条消息，并且在游戏中显示出来。</p>
<p>  这里的socket就像是一个管道，连接了两个电脑上的游戏程序，使得它们能够在网络中相互交换数据。而socket地址就像是这个管道的两端，每个电脑上的游戏程序都需要知道自己的socket地址和对方的socket地址，才能够建立起通信连接。</p>
<p>而在上面的例子中，我与朋友在实际应用中就对应着客户端与服务端，而socket地址由ip地址与端口组成，它处理的是进程之间的通信。</p>
</blockquote>
<h1 id="简单使用socket"><a href="#简单使用socket" class="headerlink" title="简单使用socket"></a>简单使用socket</h1><h2 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h2><p>在使用socket之前我们需要使用socket提供的<code>socket()</code>方法创建一个Socket。例如，以下代码创建一个TCP套接字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   </span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Socket Created&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>socket.AF_INET</code>是一个常量，表示使用IPV4协议族的套接字。用于指定套接字使用IPv4地址和端口号。</li>
<li><code>SOCK_STREAM</code>表示使用TCP协议进行通讯。如果这里是<code>SOCK_DGRAM</code>则表示使用UDP协议进行通信，创建的也是UDP套接字</li>
</ul>
<p>错误处理，当<code>socket.socket()</code>函数执行失败时，会抛出一个<code>socket.error</code>异常，异常的内容就是一个元组，包含两个值，第一个值是一个错误码(error code)，第二个值是一个错误信息(error message)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error, msg:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Failed to create socket. Error code: &#x27;</span> + <span class="built_in">str</span>(msg[<span class="number">0</span>]) + <span class="string">&#x27; , Error message : &#x27;</span> + msg[<span class="number">1</span>]</span><br><span class="line">    sys.exit();</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Socket Created&#x27;</span></span><br></pre></td></tr></table></figure>





<h2 id="客户端Socket操作"><a href="#客户端Socket操作" class="headerlink" title="客户端Socket操作"></a>客户端Socket操作</h2><p>在客户端，需要创建一个套接字，并指定服务器的地址和端口来连接到服务器。</p>
<h3 id="获取远程主机IP地址"><a href="#获取远程主机IP地址" class="headerlink" title="获取远程主机IP地址"></a>获取远程主机IP地址</h3><p>在连接到服务器之前，客户端需要获取服务器的IP地址。</p>
<p>可以使用<code>socket.gethostbyname()</code>函数来获取远程主机的IP地址，如下所示：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line">  sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.google.net&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  remote_ip = socket.gethostbyname( host )</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> socket.gaierror:</span><br><span class="line">  <span class="comment">#could not resolve</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hostname could not be resolved. Exiting&#x27;</span>)</span><br><span class="line">  sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;Ip address of &#x27;</span> + host + <span class="string">&#x27; is &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Socket Created</span></span><br><span class="line"><span class="comment"># Ip address of www.baidu.com is 36.152.44.96</span></span><br></pre></td></tr></table></figure>

<p><code>gethostbyname()</code>方法是用于将主机名解析为IP地址。它接受一个主机名作为参数，并返回该主机名对应的IP地址。这个IP地址可以用于创建套接字，以便连接到远程服务器或绑定到本地地址。</p>
<h3 id="连接到服务器"><a href="#连接到服务器" class="headerlink" title="连接到服务器"></a>连接到服务器</h3><ul>
<li><p>首先，客户端需要连接到服务器，以建立网络连接。</p>
</li>
<li><p>在建立连接前，需要知道服务器的IP地址和端口号。</p>
</li>
<li><p>客户端可以使用<code>socket.connect()</code>函数来连接服务器。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">remote_ip = socket.gethostbyname( host )</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> socket.gaierror:</span><br><span class="line"><span class="comment">#could not resolve</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hostname could not be resolved. Exiting&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;Ip address of &#x27;</span> + host + <span class="string">&#x27; is &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Connect to remote server</span></span><br><span class="line">s.connect((remote_ip , port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Connected to &#x27;</span> + host + <span class="string">&#x27; on ip &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Socket Created</span></span><br><span class="line"><span class="comment"># Ip address of www.baidu.com is 36.152.44.96</span></span><br><span class="line"><span class="comment"># Socket Connected to www.baidu.com on ip 36.152.44.96</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意，<code>connect()</code>方法需要传入一个元组<code>(host, port)</code>，其中<code>host</code>是服务器的IP地址，<code>port</code>是服务器的端口号。</li>
<li><code>connect()</code>方法是<code>socket</code>模块中用于创建TCP连接的方法之一。它的作用是连接到一个远程服务器并与之建立TCP连接。</li>
</ul>
<h3 id="向服务器端发送数据"><a href="#向服务器端发送数据" class="headerlink" title="向服务器端发送数据"></a>向服务器端发送数据</h3><ul>
<li>连接成功后，客户端可以向服务器发送数据。</li>
<li>可以使用<code>socket.send()</code>函数来发送数据，如下所示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">remote_ip = socket.gethostbyname( host )</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> socket.gaierror:</span><br><span class="line"><span class="comment">#could not resolve</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hostname could not be resolved. Exiting&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;Ip address of &#x27;</span> + host + <span class="string">&#x27; is &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Connect to remote server</span></span><br><span class="line">s.connect((remote_ip , port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Connected to &#x27;</span> + host + <span class="string">&#x27; on ip &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send some data to remote server</span></span><br><span class="line">message = <span class="string">&quot;&#x27;GET / HTTP/1.1\r\nHost: baidu.com\r\n\r\n&#x27;&quot;</span></span><br><span class="line">message =  message.encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#Set the whole string</span></span><br><span class="line">s.send(message)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line"><span class="comment">#Send failed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Send failed&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Message send successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，客户端连接到了baidu的端口号80，并使用<code>send()</code>方法向服务器发送了一个消息，消息内容是<code>Hello, server!</code>。</li>
<li>需要注意的是，如果使用的是python3，如果不加message &#x3D;  message.encode()将str转换为byte，可能会出现报错<code>TypeError: a byteslike object is required, not ‘str’</code></li>
<li>这是因为Python3中，str 类型和 unicode 类型是同一种类型。Python2中，str 类型和 bytes 类型是同一种类型。</li>
</ul>
<h3 id="从服务器端接收数据"><a href="#从服务器端接收数据" class="headerlink" title="从服务器端接收数据"></a>从服务器端接收数据</h3><p>客户端可以使用<code>socket.recv()</code>函数从服务器端接收数据，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket   <span class="comment">#for sockets</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment">#for exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#create an AF_INET, STREAM socket (TCP)</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">remote_ip = socket.gethostbyname( host )</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> socket.gaierror:</span><br><span class="line"><span class="comment">#could not resolve</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hostname could not be resolved. Exiting&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;Ip address of &#x27;</span> + host + <span class="string">&#x27; is &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Connect to remote server</span></span><br><span class="line">s.connect((remote_ip , port))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Socket Connected to &#x27;</span> + host + <span class="string">&#x27; on ip &#x27;</span> + remote_ip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Send some data to remote server</span></span><br><span class="line">message = <span class="string">&quot;&#x27;GET / HTTP/1.1\r\nHost: baidu.com\r\n\r\n&#x27;&quot;</span></span><br><span class="line">message =  message.encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#Set the whole string</span></span><br><span class="line">s.send(message)</span><br><span class="line"><span class="keyword">except</span> socket.error:</span><br><span class="line"><span class="comment">#Send failed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Send failed&#x27;</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Message send successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Now receive data</span></span><br><span class="line">reply = s.recv(<span class="number">4096</span>)</span><br><span class="line">re_list = reply.split(<span class="string">&#x27;\r\n&#x27;</span>.encode())</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> re_list:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Socket Created</span></span><br><span class="line"><span class="string">Ip address of www.baidu.com is 36.152.44.95</span></span><br><span class="line"><span class="string">Socket Connected to www.baidu.com on ip 36.152.44.95</span></span><br><span class="line"><span class="string">Message send successfully</span></span><br><span class="line"><span class="string">b&#x27;HTTP/1.1 302 Found&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Bdpagetype: 3&#x27;</span></span><br><span class="line"><span class="string">b&#x27;ContentLength: 154&#x27;</span></span><br><span class="line"><span class="string">b&quot;ContentSecurityPolicy: frameancestors &#x27;self&#x27; https://chat.baidu.com http://mirrorchat.baidu.com https://fjchat.baidu.com https://hbachat.baidu.com https://hbechat.baidu.com https://njjschat.baidu.com https://njchat.baidu.com https://hnachat.baidu.com https://hnbchat.baidu.com http://debug.baiduint.com;&quot;</span></span><br><span class="line"><span class="string">b&#x27;ContentType: text/html&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Date: Sun, 23 Jul 2023 15:09:34 GMT&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Location: https://www.baidu.com/search/error.html&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Server: BWS/1.1&#x27;</span></span><br><span class="line"><span class="string">b&#x27;SetCookie: BDSVRTM=0; path=/&#x27;</span></span><br><span class="line"><span class="string">b&#x27;Traceid: 1690124974056851201016077367759043291635&#x27;</span></span><br><span class="line"><span class="string">b&#x27;XUaCompatible: IE=Edge,chrome=1&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;html&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;body bgcolor=&quot;white&quot;&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;/body&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&lt;/html&gt;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">进程已结束,退出代码0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端发送了一条HTTP请求，请求内容是<code>GET / HTTP/1.1\r\nHost: baidu.com\r\n\r\n</code>。关于该请求的含义需要去了解HTTP协议，这里不过多赘述<br>collapsed:: true</li>
<li>请求行：<code>GET / HTTP/1.1</code>，其中<code>GET</code>表示请求方法，<code>/</code>表示请求的URI路径，<code>HTTP/1.1</code>表示使用的HTTP协议版本。</li>
<li>请求头：<code>Host: baidu.com</code>，其中<code>Host</code>是HTTP&#x2F;1.1协议中的一个必选请求头字段，用于指定请求的目标服务器的域名或IP地址。</li>
<li>空行：<code>\r\n</code>表示一个空行，用于分隔请求头和请求体。由于这个请求没有请求体，因此空行后面没有数据。</li>
<li>由于HTTP协议中使用<code>\r\n</code>作为行结束符，因此请求报文中每行结尾都需要添加<code>\r\n</code>。在请求头和请求体之间需要添加一个空行，即两个<code>\r\n</code>，表示请求头已经结束，后面没有请求体数据。</li>
<li>这条请求会向<code>baidu.com</code>的默认HTTP端口80发起请求，<strong>要求获取主页内容</strong>。然后，客户端使用<code>client_socket.recv()</code>方法从服务器接收了一条消息，数据大小为4096字节。最后，客户端在控制台输出了从服务器接收到的数据。</li>
<li>上述reply后续的处理是为了便于人类阅读加上的。</li>
</ul>
<h3 id="关闭socket"><a href="#关闭socket" class="headerlink" title="关闭socket"></a>关闭socket</h3><p>完成数据交换后，服务器需要关闭socket，以释放网络资源。可以使用<code>socket.close()</code>函数来关闭socket</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<h2 id="服务器端Socket操作"><a href="#服务器端Socket操作" class="headerlink" title="服务器端Socket操作"></a>服务器端Socket操作</h2><ul>
<li>在服务器端，需要创建一个套接字并将其绑定到一个特定的网络地址，以便客户端可以连接到它。</li>
</ul>
<h3 id="服务器端绑定Socket"><a href="#服务器端绑定Socket" class="headerlink" title="服务器端绑定Socket"></a>服务器端绑定Socket</h3><ul>
<li>在创建完套接字后，我们可以使用<code>bind()</code>方法将套接字绑定到一个特定的IP地址和端口。</li>
<li>例如，以下代码将TCP套接字绑定到本地主机的8000端口</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将套接字绑定到本地主机的8000端口</span></span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>使用的方法便是<code>bind()</code>，其用于<strong>将一个套接字绑定到一个具体的IP地址和端口号上，从而使得其他套接字可以通过该地址和端口号找到这个套接字并与之通信。</strong></li>
</ul>
<h3 id="Socket侦听连接"><a href="#Socket侦听连接" class="headerlink" title="Socket侦听连接"></a>Socket侦听连接</h3><ul>
<li>接下来，我们可以使用<code>listen()</code>方法开始监听连接请求。</li>
<li>例如，以下代码开始监听TCP连接请求：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将套接字绑定到本地主机的8000端口</span></span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始监听连接请求</span></span><br><span class="line">sock.listen(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h3><ul>
<li>在监听请求期间，我们可以使用<code>accept()</code>方法接受客户端的连接请求。</li>
<li>例如，以下代码接受一个TCP连接请求</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将套接字绑定到本地主机的8000端口</span></span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始监听连接请求</span></span><br><span class="line">sock.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受客户端的连接请求</span></span><br><span class="line">client_sock, client_addr = sock.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出客户端的地址信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;客户端地址：&#x27;</span>, client_addr)</span><br></pre></td></tr></table></figure>



<h1 id="服务器端与客户端的异同"><a href="#服务器端与客户端的异同" class="headerlink" title="服务器端与客户端的异同"></a>服务器端与客户端的异同</h1><ul>
<li>创建和绑定：在服务器端，需要创建一个套接字并将其绑定到一个特定的网络地址，以便客户端可以连接到它。而在客户端，只需要创建一个套接字，并指定服务器的地址和端口来连接到服务器。</li>
<li>监听和接受连接：服务器端需要调用<code>listen()</code>函数来监听传入的连接请求。一旦有客户端请求连接，服务器端会调用<code>accept()</code>函数来接受连接，并创建一个新的套接字来处理与该客户端的通信。而客户端只需要调用<code>connect()</code>函数来连接到服务器。</li>
<li>数据交换：在服务器端，可以同时处理多个客户端的连接请求，并与每个客户端进行数据交换。服务器端可以使用多线程或多进程来实现并发处理。而客户端通常只与服务器进行一对一的通信。</li>
<li>关闭连接：在服务器端，当与客户端的通信结束后，需要调用<code>close()</code>函数来关闭与该客户端的连接。而客户端在完成通信后，也需要调用<code>close()</code>函数来关闭与服务器的连接。</li>
</ul>
<h1 id="常用方法语法"><a href="#常用方法语法" class="headerlink" title="常用方法语法"></a>常用方法语法</h1><ul>
<li>socket: <code>socket(family, type, proto)</code><ul>
<li>创建一个新的套接字对象其中</li>
<li><code>family</code> 指定地址族（如 <code>AF_INET</code> 表示 IPv4）</li>
<li><code>type</code> 指定套接字类型（如 <code>SOCK_STREAM</code> 表示 TCP 套接字）</li>
<li><code>proto</code> 指定协议类型（如 <code>IPPROTO_TCP</code> 表示 TCP 协议）。</li>
</ul>
</li>
<li>connect: <code>connect(address)</code><ul>
<li>连接到指定的地址</li>
<li><code>address</code> 是一个表示远程主机地址和端口号的元组。</li>
</ul>
</li>
<li>bind: <code>bind(address)</code><ul>
<li>绑定指定的地址到套接字</li>
<li><code>address</code> 是一个表示本地主机地址和端口号的元组。</li>
</ul>
</li>
<li>gethostbyname: <code>gethostbyname(hostname)</code><ul>
<li>解析指定主机名的 IP 地址，返回一个表示 IP 地址的字符串。</li>
</ul>
</li>
<li>gethostname: <code>gethostname()</code><ul>
<li>返回本地主机名。</li>
</ul>
</li>
<li>send: <code>send(data)</code><ul>
<li>发送数据到连接的套接字，其中 <code>data</code> 是要发送的数据。</li>
</ul>
</li>
<li>recv: <code>recv(bufsize)</code><ul>
<li>从连接的套接字接收数据，其中 <code>bufsize</code> 是要接收的最大字节数。</li>
</ul>
</li>
<li>listen: <code>listen(backlog)</code><ul>
<li>开始监听连接，其中 <code>backlog</code> 指定连接请求队列的最大长度。</li>
</ul>
</li>
</ul>
<h1 id="理解时遇到的一些问题"><a href="#理解时遇到的一些问题" class="headerlink" title="理解时遇到的一些问题"></a>理解时遇到的一些问题</h1><ul>
<li>创建的套接字对象的ip地址是不是就是本机的？<ul>
<li>在使用<code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code><strong>创建套接字对象时，它并没有绑定到任何本地地址或端口上</strong>。因此，在调用<code>bind()</code>方法之前，套接字对象并没有本地IP地址。</li>
<li>当调用<code>bind()</code>方法将套接字对象绑定到一个本地IP地址和端口号上时，它的本地IP地址就是你指定的本地IP地址。如果你在调用<code>bind()</code>方法时将IP地址参数设置为<code>&#39;&#39;</code>，则表示将套接字绑定到所有可用的IP地址上，这时套接字的本地IP地址将是本机的一个有效IP地址。</li>
<li>另外，当使用<code>connect()</code>方法将<strong>套接字连接到远程主机时，套接字对象的本地IP地址是由操作系统自动分配的。操作系统通常会使用本机上的一个可用IP地址作为套接字对象的本地IP地址，这个IP地址通常是本机的一个局域网IP地址或公网IP地址，取决于本机与远程主机之间的网络环境。</strong></li>
<li>因此，套接字对象的本地IP地址是否就是本机的IP地址，取决于你如何使用套接字对象，并且在使用套接字对象之前是否将其绑定到本地地址和端口号上。</li>
</ul>
</li>
<li><code>gethostbyname</code>与<code>getsockname</code>之间存在什么关系呢？<ul>
<li><code>gethostbyname()</code>方法是<strong>用于将主机名解析为IP地址</strong>。它接受一个主机名作为参数，并返回该主机名对应的IP地址。这个IP地址可以用于创建套接字，以便连接到远程服务器或绑定到本地地址。</li>
<li><code>getsockname()</code>方法是<strong>用于获取套接字的本地地址和端口号</strong>。它返回一个元组，包含套接字绑定的本地地址和端口号。这个本地地址可以用于告诉其他套接字如何连接到它。</li>
</ul>
</li>
</ul>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/260139078">用大白话解释什么是Socket</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39982451">Python 的 Socket 编程教程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lbj1260200629/article/details/114823170">解决 Python3 中 TypeError: a byteslike object is required, not ‘str‘</a></li>
<li>chatgpt</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>项目式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>关于开源软件与我的分享目的</title>
    <url>/2023/04/21/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E4%B8%8E%E6%88%91%E7%9A%84%E5%88%86%E4%BA%AB%E7%9B%AE%E7%9A%84/</url>
    <content><![CDATA[<p>开源软件还有一个名字，叫自由软件，与之相对于有一类软件叫闭源软件，比如我们常用的QQ，微信等。接下来接简单介绍下两者的区别</p>
<ul>
<li><p>开源软件—open source software顾名思义就是开放软件源代码的软件，这意味着任何人都可以修改软件的源代码。相当于一个工具，大家可以在初代的基础上对其进行修改，并重新发布软件。这也是为什么其被称作自由软件。至于重新发布甚至商业化这里涉及到不同开源协议的要求不同，便不赘述，可自行了解。</p>
</li>
<li><p>闭源软件则与其正好相反，其源代码是私有的，只能被制造商或授权用户查看和修改。因此，普通用户无法访问、修改或重新分发该软件的源代码。闭源软件常见于需要保护隐私或者需要用于盈利的软件。</p>
</li>
</ul>
<span id="more"></span>

<p>综上开源软件的好处便很明显了，不知道你们用闭源软件的时候有没有这种担忧，就是你资源全放一个篮子里了，哪天平台跑路了我不是啥也没了，这也是我为什么要买大硬盘存资源的原因，网盘固然好，但解决不了我的忧虑，更不用说国内目前国内两大网盘—阿里和百度都是和谐高手。这里的和谐涉及范围很广，比如我阿里大部分wlop的壁纸都寄了，周杰伦的歌也是。</p>
<p>~嘶，跑题了</p>
<p>从上面来说，开源软件的第一个特点就是稳，创始人不更了没事，最坏也就是没人维护了，甚至社区还有人在继续维护，那更不用担心。</p>
<p>另外一个关键点便是开源软件，极少有后门，当然，这里要排除那些拿别人的开源软件，塞了点东西，然后买给你的那种，很少，但确实存在。正常情况，一个源代码公开的软件，塞后门…emm</p>
<p>其他的杂七杂八好处，太多了，反正现在我纯纯开源拥护者，虽然目前能力止步于使用者，但是希望成为一名开源者。真是屑啊</p>
<h1 id="正文？"><a href="#正文？" class="headerlink" title="正文？"></a>正文？</h1><p>接下来会慢慢介绍一些自己目前正在使用，或者以前使用过的优秀开源工具，注意是开源工具哦，上手用的那种。</p>
<p>简单介绍几个贼爽的，bilix、Codesker、pot、snipaste…</p>
]]></content>
      <categories>
        <category>开源软件</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>开源软件</tag>
      </tags>
  </entry>
  <entry>
    <title>满足至极的微信输入法.md</title>
    <url>/2024/02/29/%E6%BB%A1%E8%B6%B3%E8%87%B3%E6%9E%81%E7%9A%84%E5%BE%AE%E4%BF%A1%E8%BE%93%E5%85%A5%E6%B3%95-md/</url>
    <content><![CDATA[<h1 id="满足至极的微信输入法"><a href="#满足至极的微信输入法" class="headerlink" title="满足至极的微信输入法"></a>满足至极的微信输入法</h1><p>此前从少数派上一篇文章看到对于微信输入法的推荐，于是乎从手机尝试一一周，然后熟悉再探索，大概用了两周左右。目前全面更换为微信输入法。简单聊一下怎么个好用法。</p>
<p>此前，在手机端基本是使用讯飞或者系统自己带的，桌面端则是使用微软自带以及Rime小狼毫(一开始想折腾下，但是也没折腾明白，使用文档感觉是在学Python文档)。手机端基本使用需求是满足的，联想功能方面还行。但是现在对比下来就存在许多缺点，单纯就输入功能来说</p>
<ul>
<li>小狼毫没有配置对应文件的话，对于诗词以及一些谚语之类的，基本是没有自动联想相关方面词条的功能。对比下来微软感觉反而是遇到微信输入法之前的最优解。</li>
<li>手机方面，除了明显舒服的优化输入以及自动补全外，微信输入法值得一提的就是删除时向上滑动可以清屏，向下滑可以恢复清理的内容。方便删大量文字，同时删过头了还可以反悔。</li>
</ul>
<span id="more"></span>

<h2 id="外观—极为克制、即为简约的外观。"><a href="#外观—极为克制、即为简约的外观。" class="headerlink" title="外观—极为克制、即为简约的外观。"></a>外观—极为克制、即为简约的外观。</h2><p>微信输入法没有皮肤，就挺好，简约好用，输入法就是用来打字的。</p>
<p><img src="https://s2.loli.net/2024/02/29/7n9LxGAuiTIsMmt.png" alt="image-20240229193513226"></p>
<h2 id="功能-—-Nice"><a href="#功能-—-Nice" class="headerlink" title="功能 — Nice"></a>功能 — Nice</h2><h3 id="第一神技-—-剪切板同步"><a href="#第一神技-—-剪切板同步" class="headerlink" title="第一神技 — 剪切板同步"></a>第一神技 — 剪切板同步</h3><p>不同设备在下载好输入法以后，点击「关联设备」，随后在要同步的设备上点击「查看匹配码」，将对应设备匹配码输进去，就可以关联不同设备的剪切板了。简单好用！</p>
<p><img src="https://s2.loli.net/2024/02/29/IpVhUAmYEGDJfjy.png" alt="image-20240229193537594"></p>
<p>使用也简单，一台设备复制粘贴，其他设备的剪切板就会有，图片也行，如下：<br><img src="https://s2.loli.net/2024/02/29/3zeXDcWB5gkmJxw.png"></p>
<h3 id="第二神技-—-常用语"><a href="#第二神技-—-常用语" class="headerlink" title="第二神技 — 常用语"></a>第二神技 — 常用语</h3><p>微信输入法是存在一些不足的，比如说，如果你是刚下载，这个符号「」你应该是没法直接打出来的。但是可以通过常用语，将它添加到你的输入中。</p>
<p>如下所示，我每次输入kuo，在选项中都会有「」可以选择。</p>
<p><img src="https://s2.loli.net/2024/02/29/rThqPIbeSmGH3NZ.png" alt="image-20240229193601835"></p>
<p>这为我们自定义以及搭建自己的输入法提供了一条路径，使得普适的输入法可以更加个性化。</p>
<p>检索优化，在桌面端按下Down或者Up，并不是一行一行出现相关词，而是如下图所示，提供更方便的检索方式，对于使用体验显然是一个优化。</p>
<p><img src="https://s2.loli.net/2024/02/29/uOFYEfdSVLrohmG.png" alt="image-20240229193609290"></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>见不到任何多余的东西，非常克制非常克制，整体用上来就是一个很清爽的输入法，没有其他</p>
<p>综上自来水，微信输入法显然是微信出品的一款追求口碑的产品。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>生活杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>图床搭建与PicGO---typora</title>
    <url>/2023/03/07/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E4%B8%8EPicGO-typora/</url>
    <content><![CDATA[<h1 id="图床搭建与PicGO—typora"><a href="#图床搭建与PicGO—typora" class="headerlink" title="图床搭建与PicGO—typora"></a>图床搭建与PicGO—typora</h1><h2 id="图床选择与注册"><a href="#图床选择与注册" class="headerlink" title="图床选择与注册"></a>图床选择与注册</h2><p>图床选择很多，但是建议选择比较长期还有稳定的图床，当然如果可以免费自然是更好。</p>
<p>我这次选择的是<a target="_blank" rel="noopener" href="https://www.imgurl.org/vip/manage/upload">ImgURL</a></p>
<p>之前用过<a target="_blank" rel="noopener" href="https://sm.ms/">SM.MS</a></p>
<p>两者都好用，后者注册和使用更加方便，初始上传的最大图片限制是5G，但是个人用肯定够了</p>
<span id="more"></span>


<h2 id="PicGO"><a href="#PicGO" class="headerlink" title="PicGO"></a>PicGO</h2><h3 id="ImgURL"><a href="#ImgURL" class="headerlink" title="ImgURL"></a>ImgURL</h3><p>在GitHub的<a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.1">下载界面</a>选择一个比较稳定的版本进行安装，别安装尝鲜版。安装速度可能有点慢，因为是GitHub。自己想办法&#x3D;.&#x3D;</p>
<p>下好以后就绑到你所使用的图床就行，当然前提是你的图床支持PicGO。我使用的ImgURL有很详细的<a target="_blank" rel="noopener" href="https://doc.xiaoz.org/books/imgurl-pro/page/picgo">教程</a>。当然使用可以直接绑定的图床肯定更方便，比如阿里云、腾讯云、SM.MS等</p>
<p>关于插件的下载和SM.MS一样就行，然后根据官方教程绑定PicGO和ImgURL；这里直接看教程就行，很详细了。</p>
<h3 id="SM-MS"><a href="#SM-MS" class="headerlink" title="SM.MS"></a>SM.MS</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133270020">参考文档</a></p>
<p>在安装好PicGO和注册好SM.MS后，使用typora测试了下图片上传，毫无疑问上传失败。因为没有对PicGO进行配置。于是只好去网上找教程。   </p>
<p>首先是PicGO提供的SM.MS有问题，需要下一个插件，叫做<a target="_blank" rel="noopener" href="https://github.com/xlzy520/picgo-plugin-smms-user">smms-user</a>；当然最好是在PicGo.app自己软件里面的插件设置去下载最好—搜索smms-user然后点击安装就行，等待安装完成。<br><img src="https://s2.loli.net/2023/03/07/6nQAoprPjKdBWYX.png" alt="image-20230307142211939"></p>
<p>这里我遇到了第一个坑，就是一直安装不上，然后网上搜索了，关于picgo.app的解决方案真不多，然后我把日志里面的几个报错全去ChatGPT问了下，如下：然后我选择了最粗暴的，重装。遗憾的是，我重装了两次还是有问题，于是便选择使用npm，结果在管理员权限出现了问题，qwq。<br><strong>直接说最后解决方案：重装，然后以管理员权限启动</strong> </p>
<p><img src="https://s2.loli.net/2023/03/07/wVguaZMkWo6RH5N.png" alt="image-20230307163057301"></p>
<p>这次插件成功安装了，接下来要做的就是配置一下插件，在左侧图床设置里面会如下图所示，左键插件右下角设置按钮，然后把从SM.MS获取到的token填进插件的plugin以及uploader中。再把默认图片上传改为SM.MS-登录用户</p>
<p><img src="https://s2.loli.net/2023/03/07/58tXJrFHjnseAC4.png" alt="image-20230307163751194"></p>
<p><img src="https://s2.loli.net/2023/03/07/EMTDwm1gcGUZ3ed.png" alt="image-20230307181803403"></p>
<p>然后再用图片进行测试，发现上传成功，解下来再把typora里的图片上传方式改下。</p>
<h2 id="typora设置"><a href="#typora设置" class="headerlink" title="typora设置"></a>typora设置</h2><p>上传服务设定改一下，路径选择你PicGO的位置。然后点击<strong>验证图片上传选项</strong></p>
<p><img src="https://s2.loli.net/2023/03/07/EagXR9tlN8FnD3M.png" alt="image-20230307182146879"></p>
<p>第二个问题出现了，上传图片失败，我直接进PICGO的日志中把这次上传去找了下问题，结果是typora的图片传不上去了。直接用就行，文档里面图片不受影响。</p>
<p><img src="https://s2.loli.net/2023/03/07/4BEJKOvm7IiWPaS.png" alt="image-20230307182427400"></p>
<p><img src="https://s2.loli.net/2023/03/07/iTlbnIsyOCN9qmS.png" alt="image-20230307182550000"></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>图床</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译工具整理以及沉浸式翻译</title>
    <url>/2023/03/09/%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E4%BB%A5%E5%8F%8A%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>最近毕业设计，在弄文献翻译嘛，所以找了下合适的翻译工具，大学四年自己用过的翻译工具挺多的，整理一下吧，顺便强推下这个插件—沉浸式翻译，我只能说，无敌！</p>
<h1 id="沉浸式翻译"><a href="#沉浸式翻译" class="headerlink" title="沉浸式翻译"></a>沉浸式翻译</h1><p>本来是先介绍翻译工具再介绍这个的，但是翻译工具没啥好推的，能用DeePL就用，所以先介绍下这个。</p>
<ol>
<li>安装的话，油猴搜沉浸式翻译就行，当然Github也有项目，地址在这：<br> <a target="_blank" rel="noopener" href="https://github.com/immersive-translate/immersive-translate/">https://github.com/immersive-translate/immersive-translate/</a></li>
<li>也可以直接安装拓展，目前主流浏览器都上架了。<a target="_blank" rel="noopener" href="https://immersive-translate.owenyoung.com/installation">官方推荐安装文档</a></li>
</ol>
<span id="more"></span>

<p><img src="https://s2.loli.net/2023/03/09/1h9ZDFqnQdEtejM.png" alt="image-20230309111252328"></p>
<p>主要特性官方说的比较清楚了，这介绍下我认为它的主要优点吧，首先是翻译区域，以往类似的网页翻译都是整个界面全部翻译，而这个有双语对照，等于在不破化原文布局的情况下，给你加一篇区域，嵌入翻译结果，直接上效果图。页面中蓝色虚线下划线就是翻译结果，这个显示样式是可以设定的。</p>
<p><img src="https://s2.loli.net/2023/03/09/yjzaV695ZOcivRI.png" alt="image-20230309111725492"></p>
<p>还有一个巨大优点就是对于PDF，Epub电子书的双语翻译；两者的使用官方都给出了具体教程</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://immersive-translate.owenyoung.com/usage">PDF文件翻译</a>  PDF翻译效果很一般，至于准确性，纯看你用的是谁的翻译了，我用的DeePL.</p>
<p><img src="https://s2.loli.net/2023/03/09/F931RxenUyqrVp8.png" alt="image-20230309113852360"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://immersive-translate.owenyoung.com/usage">Epub文件翻译</a>：这里Epub网页工具我推荐这个<a target="_blank" rel="noopener" href="https://epub-reader.online/">Epub-reader</a> 如下图所示，Epub格式文档用Epub-reader打开然后加上沉浸式翻译，这不是无敌？</p>
<p><img src="https://s2.loli.net/2023/03/09/g6GOVPe8wRTa4NA.png" alt="image-20230309114042796"></p>
</li>
</ol>
<h2 id="关于拓展选用的翻译工具"><a href="#关于拓展选用的翻译工具" class="headerlink" title="关于拓展选用的翻译工具"></a>关于拓展选用的翻译工具</h2><p>目前官方提供如下这些，能直接用的有腾讯交互翻译、必应翻译还有谷歌翻译，但是正常情况下谷歌翻译是用不了的。</p>
<p><img src="https://s2.loli.net/2023/03/09/fYR7oaUpndMxmuy.png" alt="image-20230309114213971"></p>
<p>这里简单介绍下如何使用DeePL，其他的直接进官方提供文档，按照教程去弄就行。</p>
<p>选择DeePL以后，他会让你填DeePL的API然后填进去，测试以下，能用就行了。问题来了，API怎么弄呢？ 有一个东西，叫淘宝、还有一个东西，叫闲鱼；不愿花小钱就用其他的也行，都还可以，百度翻译也不差。</p>
<p><img src="https://s2.loli.net/2023/03/09/RZX26sYIdUj4w5p.png" alt="image-20230309114432026"><br><img src="https://s2.loli.net/2023/03/09/ziO7DRroI1Q2dTK.png" alt="image-20230309114516467"></p>
<h1 id="翻译工具整理（支持文档输入）"><a href="#翻译工具整理（支持文档输入）" class="headerlink" title="翻译工具整理（支持文档输入）"></a>翻译工具整理（支持文档输入）</h1><h2 id="DeePL"><a href="#DeePL" class="headerlink" title="DeePL"></a><a target="_blank" rel="noopener" href="https://www.deepl.com/translator">DeePL</a></h2><p>DeePL翻译结果的准确性还有本地化相比于其他翻译工具，毋庸置疑的更加强大，翻译TOP1的地位也得到了诸多认可。机翻很大的一个缺陷就是本地化，而DeePL在这方面做的确实十分优秀，首推的翻译工具自然是它，而且在文献一些名词方面它的翻译也比较准确。更重要的一点是，DeepL翻译应用程序是完全免费的，但是DeepL的翻译质量却远胜于竞争对手。</p>
<p><img src="https://s2.loli.net/2023/03/09/1o2FeXQMpRkAyzi.png" alt="image-20230309105331599"></p>
<p>单说我自己的体验，有图有真相，如下所示，图一是DeePL的翻译，图二是谷歌的，高下立判。<br>都是基于沉浸式翻译插件的，谷歌在这英译英呢，这里展示的DeePL需要使用API，DeePL的api下文会提到；单纯从结果来说就算是谷歌自带的全网页翻译，文献翻译方面也和粑粑一样。</p>
<p>DeePL的</p>
<img src="https://s2.loli.net/2023/03/09/N9j3krXEuFwBQCb.png" alt="image-20230309104412970"  />

<p>谷歌的</p>
<img src="https://s2.loli.net/2023/03/09/6zCBRepvnMKdLiU.png" alt="image-20230309104449254"  />



<h2 id="谷歌翻译"><a href="#谷歌翻译" class="headerlink" title="谷歌翻译"></a><a target="_blank" rel="noopener" href="https://translate.google.com/?hl=zh-CN">谷歌翻译</a></h2><p>Google 翻译支持对PDF文件进行翻译，您只需要上传PDF文件即可。但是，Google 翻译并不完美，可能会出现一些翻译错误。此外，如果PDF文件中有很多图片或格式，Google 翻译可能无法处理。虽然说谷歌翻译和DeePL存在差距，但是说句第二不过分吧，不过目前好像，emmm，用不了。</p>
<p><img src="https://s2.loli.net/2023/03/09/o7QUzJGBH9w5plv.png" alt="image-20230309105256673"></p>
<h2 id="百度翻译"><a href="#百度翻译" class="headerlink" title="百度翻译"></a><a target="_blank" rel="noopener" href="https://fanyi.baidu.com/">百度翻译</a></h2><p>这应该是平时用的最多的，质量中规中矩。</p>
<p><img src="https://s2.loli.net/2023/03/09/TmspgXPxCYyuQ6W.png" alt="image-20230309114839033"></p>
<h2 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a><a target="_blank" rel="noopener" href="https://fanyi.youdao.com/index.html">有道翻译</a></h2><p>一款在线翻译软件，同样支持多种格式文档输入，但是在翻译准确度上与前两者存在一定差距。</p>
<p><img src="https://s2.loli.net/2023/03/09/SlZ1ofLnD5FEKBJ.png" alt="image-20230309105700758"></p>
<h2 id="Doctranslate"><a href="#Doctranslate" class="headerlink" title="Doctranslate"></a><a target="_blank" rel="noopener" href="https://www.onlinedoctranslator.com/zh-CN/">Doctranslate</a></h2><p>Doctranslate支持在线整篇文档直接翻译，并且能够<strong>完整保留文档中的公式、排版和布局</strong>，对于论文中需要保留大量公式的同学来说十分不错。同时，整个翻译都是免费的，但是翻译质量相对于谷歌和DeePL当然存在差距。</p>
<p><img src="https://s2.loli.net/2023/03/09/ijh2vs3gXocQDOH.png" alt="image-20230309110133647"></p>
<h2 id="CNKI翻译助手"><a href="#CNKI翻译助手" class="headerlink" title="CNKI翻译助手"></a><a target="_blank" rel="noopener" href="https://dict.cnki.net/index">CNKI翻译助手</a></h2><p>这不能用来作为主流翻译软件，只能用来作为辅助工具，主要翻译文献里面的名词啥的，网页主页如下，可以自己看看</p>
<p><img src="https://s2.loli.net/2023/03/09/OJbAQxMHv7WgwF6.png" alt="image-20230309111003378"></p>
<h2 id="其他翻译工具"><a href="#其他翻译工具" class="headerlink" title="其他翻译工具"></a>其他翻译工具</h2><p>其实推荐用的只有DeePL还有谷歌，然后谷歌用不了，等于只推荐DeePL，其他的都放这了，仁者见仁，智者见智。</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="http://www.iciba.com/">金山词霸</a>：同样支持文档翻译，但是他自己说文档翻译结果只做参考。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://fanyi.caiyunapp.com/#/">彩云小译</a>：也是在线翻译，同样支持文档翻译<br><img src="https://s2.loli.net/2023/03/09/eX7kjgvQ16zhDKC.png" alt="image-20230309110537954"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://jianwai.youdao.com/">网易见外工作台</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>浏览器插件</tag>
      </tags>
  </entry>
  <entry>
    <title>看万里归途时我在想什么？</title>
    <url>/2023/06/12/%E7%9C%8B%E4%B8%87%E9%87%8C%E5%BD%92%E9%80%94%E6%97%B6%E6%88%91%E5%9C%A8%E6%83%B3%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>刚看完万里归途，趁着感触还在，写点东西。</p>
<p>emmm，之前看过类似的战狼。但二者还是有很大不同的，相比于战狼的吴京个人花式秀，我其实更觉得张译这种“赌”，更加贴合实际也更让人满怀敬意，更像一个有血有肉有信念的人。</p>
<span id="more"></span>

<p>在战乱中，在枪械下，个人的力量显得如此不堪一击，也许一颗飞溅的子弹便会让人生戛然而止。但两次放弃撤侨，一次描写渺渺，一笔带过将位置让给了台湾同胞。第二次则前后脉络清晰，嘴硬的宗大伟看着最好的伙伴章宁死在眼前，有一次“没座位”回来找白婳。此前与边境官哈桑就华人出境的拉扯将张译身为一个外交官的能力与水平体现的淋漓尽致。</p>
<p>此后寻白婳，并带领125号人前往迪拉特的情节才是电影的主线，也是宗大伟身为外交官死里求生的一次次豪赌。</p>
<p>死里逃生找到白婳，结果需要带走的人远不是预想的七八个，而是从未预想的百来人。在交战区带出百来人，而且失去与大使馆联系，宗大伟选择了赌，与其坐以待毙等着轰炸机淹没不如死里求生赌，徒步前往迪拉特赌救援。</p>
<p>中途自以为是且初出茅庐的成朗与自作聪明的刘明辉，再次将宗大伟拉上了赌桌。在ak枪口下，宗大伟与叛军首领再次豪赌，赌他不敢杀他这个外交官。赌来了一次俄罗斯转盘，最终以司机瓦迪尔的死亡结尾。从最终结局的戏剧性来看，宗大伟输给了勇气，但我以为这是再正常不过的人之常情，若救了，反倒显得有些圣母。</p>
<p>最后一次豪赌，仍然是俄罗斯转盘，只不过这次赌注换成了章宁的女儿法提玛。所有三次颤抖的手扣动扳机，换来叛军首领的无地自容与不可置信。随后成朗与其对赌，赌其不敢在摄像头下开枪，更无可能杀了所有人。</p>
<p>是的，就现实而言，在枪械下，普通人能做的，便是靠脑子和勇气去赌那一线生机，抓住了方可得活。若对方是个轴军官，一枪下去，一切皆休。所幸，蠢货也当不上叛军首领，也当不上边境官。</p>
<p>问题来了，对方的赌注是宗大伟等人的生命，宗大伟的赌注呢？是国家给予的底气！就像第三次豪赌时，他掏出护照告诉叛军首领，血债血偿！</p>
<p>最后重逢的画面真的很美，以年味，以市井气息，将人从战乱拉回了这个国泰民安的国家，这个撤离时高呼的“家”。</p>
<p><img src="https://s2.loli.net/2023/06/12/gZAdXoV2fbm9uaC.png" alt="image-20230612141651615"></p>
<p><img src="https://s2.loli.net/2023/06/12/VwplJhc4mkM3RI2.png" alt="image-20230612141659194"></p>
]]></content>
      <tags>
        <tag>生活杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉低不会写诗---周记06</title>
    <url>/2023/08/22/%E8%8B%8F%E6%A0%BC%E6%8B%89%E4%BD%8E%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B006/</url>
    <content><![CDATA[<p>这篇周记拖了一会，本来想要不要再拖一会，但是有些想法已经有些模糊，我担心再拖就写不出那会的心情了，因此便爬了起来打开logseq。写完再睡一小时，准备夜班吧。</p>
<p>前天，走在路上，我突然冒出一个想法，我有什么值得骄傲的？或许在身边人看来，我什么都会一点，玩啥都可以叫上一起，谈啥都可以插进嘴，干啥都能帮点忙，问啥似乎都可以聊两句。但我知道，这不过是啥都走马观花看多了，网上冲浪漫游时间长而已。有些想法，并不是我的，我只不过是它的拥簇，与认可者。那，我自己有什么值得自豪的呢？</p>
<p>当时，应该是晚上，坐在电召车回宿舍的路上，我思考这个问题。得到了一个不是答案的答案。抛开小学懵懵懂懂，顽劣不堪的快乐时光，与记忆模糊的初一不谈。从初二转入长蓝开始，一直至今，我似乎没什么变化。假如让我和老同学打一场篮球，去KTV唱歌或者约两三个人聚餐，我可以肯定他们可以很快从记忆里找到我。那个，喜欢抢麦的我，篮球场上篮没进动作浮夸懊悔的我，对别人事比自家事还上心的我，以及那个给感情出谋划策侃侃而谈但自己一塌糊涂的我。</p>
<p>当时没想那么多，只是感慨，我似乎确实没怎么变化。而现在写这段话时，我已然度过了校园生活，对打工生涯格格不入，我回想这些也只是希望，我可以一直是我。也许社会、职场不可避免的会让我变得圆滑，但我真诚的希望，我可以一直怀着一颗赤诚的心，对朋友、家人，其实哪来那么多勾心斗角，无非是想要的越来越多。那我现在一不娶妻，二不买房，至于立业还是有想法的，真的很想实现free of work，谁不羡慕做自己热爱的事业还把钱给赚了的呢。</p>
<span id="more"></span>

<h1 id="正式工作-—-累"><a href="#正式工作-—-累" class="headerlink" title="正式工作 — 累"></a>正式工作 — 累</h1><p>培训结束，正式开始了倒班生活，第一天就开始拉强度了，几乎是干满了。下班后人都是晕乎乎的，头也十分晕，当天回去倒头就睡。</p>
<p>睡眠真的是个好东西，尤其是那种可以沾床就睡，闹钟一响就起的人真是让我羡慕极了。像我之前正常生活时，基本上了床，闭上眼睛就开始胡思乱想，天马行空，东想西想。折腾半小时，实在没法入睡，就又爬起来掏出手机，如果背背单词或者看点枯燥硬核的书籍可能困意一会就来了。如果看的是小说，短视频，那么恭喜我，喜提“三点了，赶紧睡赶紧睡套餐”</p>
<p>现在这么倒头就睡其实也难受，第二天有时候起来迷迷糊糊的，感觉三魂不全。我觉得最好的生活方式还是那种十点睡，五点左右起来的，这样早睡早起真是感觉一天的时间都多了，虽然严格计算差不多。但是每天早上如果早起，自己的第一反应真的不是掏出手机开始刷，或是打开电脑开始游戏。当初早起，我一般是进厨房转转和奶奶说早上想吃啥，然后出门呼吸一下老家的新鲜空气，要是实在舒畅就去河边走一会，回来一般会看会书或者写会题。当然，这样的生活如今距离我感觉十分遥远了，存在记忆中的美好。</p>
<p>都说适应就好了，真不知道自己能不能适应，如果不行还是早早润了较好，就不要折磨自己了。</p>
<h1 id="杂记有感"><a href="#杂记有感" class="headerlink" title="杂记有感"></a>杂记有感</h1><h2 id="关于发言未整理好逻辑"><a href="#关于发言未整理好逻辑" class="headerlink" title="关于发言未整理好逻辑"></a>关于发言未整理好逻辑</h2><p>这是上周碰到糟心事，听人讲话，他就想到哪说到哪，如果是重点反复强调倒是无所谓，但是在每一个事中间总是穿插一些一听就很临时的衔接，让人一听就知道你不是有准备的，不过是过来随便瞎扯两句的。当然关键是卡着下班前的时间点来拖时间啊，这就让人很难受了。为此我还闲的无聊整理了一个语录</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">还有一个问题</span><br><span class="line">还有一个呢</span><br><span class="line">再有一个问题</span><br><span class="line">还有呢</span><br><span class="line">再提一个</span><br><span class="line">再一个呢就是</span><br><span class="line">再一个要强调一点</span><br><span class="line">还有一个就是</span><br></pre></td></tr></table></figure>

<p>qwq，这也给自己提个醒，讲话留意。</p>
<h2 id="深思熟虑证明我是错的"><a href="#深思熟虑证明我是错的" class="headerlink" title="深思熟虑证明我是错的"></a>深思熟虑证明我是错的</h2><p>到目前为止，我接触到的核知识，都是围绕核安全去做的，而核事故究其根本其实是人因，当时我就想，既然是因为人因出错，那么让计算机代替人工完成程序不就好了。</p>
<p>毕竟，机器是不会骗人的。</p>
<p>但是正式工作第一天，我就打消了这个想法，至少现阶段根本不现实。首先是技术方面，要采用机器完全带动人工，有电脑程序逻辑进行驱动现在的技术是肯定做不到完全取代的，也许可以再某些地方节约时间。其次，就算可以实现，要想落地难度非常离谱！这是核，不是什么学生信息管理系统，稍有不慎，危及的并不算某个人，更不是某个公司，整个国家与世界都会受到极其长远的影响。假如程序逻辑出现某些bug或者缺陷，而没有及时发现，我相信目前世界没有任何一个国家可以再承担一次切尔诺贝利事故的后果，踩进这个坑可能就爬不出来了。而且假如采用计算机系统接入，网络安全就是另一个更大的问题了，世界没有安全的网络，没有安全的墙！</p>
<p>所以我觉得，核工业与IT领域最好的结合应该是在某些需要人工较为艰难实现的某一个操作上，通过嵌入式设备进行辅助操作。而这据我了解似乎也是目前一直在推进的。</p>
<h2 id="关于我学习的一个误区"><a href="#关于我学习的一个误区" class="headerlink" title="关于我学习的一个误区"></a>关于我学习的一个误区</h2><p>以往的学习基本都是先看看要用什么，然后先学习好了，再去实践，但是效率真的很低。感觉自己就是一个知识的搬运工，知识从网络上经过我的大脑与手，通过键盘，映射到了我的本地笔记软件上，并在我的大脑中留下了它走过的痕迹。</p>
<p>我不知道费曼学习法？当然知道，但并未做到，我并没有实践来驱动学习，而是将做笔记误以为是实践，误以为自己使用的是费曼学习法。但并不是。</p>
<p>费曼学习法肯定是要花费时间的，而我也不可能刚学到就可以进行输出，我认为正确的过程应该是项目驱动学习，学习继续完成项目，知识达到一定的重复次数，在大脑中留下比较深的路径以后，我再把它拓印在Blog或者总结中。</p>
<p>先这样吧，准备上班去咯，加油！！！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉底不会写诗-周记02</title>
    <url>/2023/07/27/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B002-md/</url>
    <content><![CDATA[<p>标题没问题，确实是周记02，因为周记01里说了好些胡话，不想发，但肯定是不愿删的，索性就直接从周记02开始了。</p>
<p>躺着拿工资的一周，真不戳！</p>
<span id="more"></span>

<h1 id="状态一般"><a href="#状态一般" class="headerlink" title="状态一般"></a>状态一般</h1><p>学习状态仍然很一般。</p>
<p>不过较之前略好吧，下周再接再厉了咯。对于一个从小到大英语依托答辩的人来说，狠下心认真学习英语真是艰难，也参了一些方法论，但是对于时间的要求确实比较苛刻了，我在考虑要不要早起一会，每天上班之前抽空学一会，否则一进公司整个人就不太能沉下心来学习。</p>
<p>继续尽力把它当作一门工具语言慢慢融入生活把，心无旁骛的学习真的不是一件简单的事情，对吧？</p>
<h1 id="周末与物价"><a href="#周末与物价" class="headerlink" title="周末与物价"></a>周末与物价</h1><p>周四在B站刷到了封神第一步的宣发片，当时就觉得这画面不错，而且封神这一题材作为东方玄幻的祖师爷我还是很感兴趣的。</p>
<p>坦然的说，妲己确实有魅惑到我！</p>
<p>于是乎，周六便有了这一次进城观影+吃吃喝喝，相较于上次踩坑，这次体验好上太多。吸取了上次教训，这次在吃饭前提前联系了熟悉附近菜馆的前辈，咨询有没有什么地道的湘菜—我实在不想吃甜到腻歪的菜了，我想吃辣！！！！</p>
<p>事实证明，这确实是一个明智之举！</p>
<p><img src="https://s2.loli.net/2023/12/20/cHZeIA9oUd6nb1g.jpg" alt="c2ef34bba5ce3e256d7f81f54393d68"></p>
<p>非常费解，福鼎这样一个在宁德下面的6线小城市，物价丝毫不逊色长沙，美团上想找个剪头发的地方，随随便便一家洗剪吹都得60左右。最后挑挑拣拣终于找到一家35的，还算不错，我的发际线又有了遮挡。</p>
<p>电影院是我最后去的，封神第一部给我的印象还算不错，但与最初的超高预期肯定还算有一定差距。</p>
<p>总的来说线索明朗，从头到尾娓娓道来，逐步引出封神里的关键人物—姬发、妲己、殷寿(纣王)。但不得不吐槽的是姜子牙与二郎神杨戬的形象，不说截然不同，但确实与我印象中的相差甚远，也或许是我期望太高，毕竟其他封神相关影片中，这二位都是何等飒飒风姿姜子牙不过修道40余载，二郎神也算是初哥，略显青涩倒也正常，但这着实颠覆了我印象中他桀骜不驯的样子，你可是杨戬啊！！！！</p>
<p>随后剧情的跌宕起伏，伴随着殷寿“传销头子”形象的逐渐丰满与妲己的步步登天、姬发在兄友的先后祭天中醒悟，剧情也逐渐演变向高潮，最后以殷寿“身死”戛然而止。</p>
<p>当然，大幕才刚拉开帷幕，对后续充满期待。</p>
<h1 id="新尝试"><a href="#新尝试" class="headerlink" title="新尝试"></a>新尝试</h1><p>公司的游泳馆规格早有耳闻，初入公司便不断有前辈安利，作为内地的旱鸭子我已经很久没有下过水了，上次游泳应该还是在初中。</p>
<p>当时学游泳是在公共游泳馆，常常人满为患！！！</p>
<p>在这忠实建议，不要去鱼龙混杂的地方学或者练习游泳，那会是一场很糟糕的体验。</p>
<ul>
<li>鱼龙混杂 — 各种液体在水里</li>
<li>基本游两次就要生病，看抵抗力了</li>
<li>大人带小孩是真的糟心</li>
</ul>
<p>网购的游泳装备也都到了，于是乎便拉上人，在水里扑棱。估计还是有点肌肉记忆，在水里泡了半小时，蛙泳倒也能一口气游个十多米，当然，换气换不来，只能憋着谁手脚尽量协调着做蛙泳，有些慢，但确实动了。我自己初步估计的学习路线是怎样的呢？</p>
<ul>
<li>“飘”起来</li>
<li>手脚协调</li>
<li>初步蛙泳</li>
</ul>
<p>这次游泳倒是一口水没喝，但是鼻子吸的水可一点也不少。</p>
<p>这还没有开始换气，如果练习换气估计我会喝不少水，请教练我自然是不愿意的，舍不得那个钱，况且我也觉得没必要，人大了反而比较拘谨，自己摸索倒是畅快许多。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉底不会写诗-周记03</title>
    <url>/2023/07/31/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B003-md/</url>
    <content><![CDATA[<p>这周开始正经上课了，比较充实，浅浅的记录一下。</p>
<span id="more"></span>

<h1 id="新东西"><a href="#新东西" class="headerlink" title="新东西"></a>新东西</h1><h2 id="安全盲区"><a href="#安全盲区" class="headerlink" title="安全盲区"></a>安全盲区</h2><p>没法肆意摸鱼了</p>
<p>接触了一些新东西 — 安全相关。</p>
<p>课堂上有些曾经的安全事故示例，我试图设身处地思索，发现我也许也有可能成为视频里那个“愚者”。</p>
<p>比如，汽油在空气中放置不当，非常容易级转瞬即“逝”。衡量气体的爆炸极限、液体的闪点。至于固体，自然是燃点。这些都与安全息息相关，若不知道这些，实际生活中接触到时确实可能怎么逝的都不知道。</p>
<ul>
<li>可被燃烧的物质与空气中的氧混合可发生燃烧，但只有当燃料的浓度落在可由实验决定的上、下限之间才可能燃烧，此上下限称为**可燃极限( flammability limits)**。</li>
<li>点燃在空气中的气体，气体可能会引爆，或者会很快停止，这种情况是由气体在空气中的浓度来决定的。当气体浓度太低，没有足够燃料来维持爆炸；当气体浓度太高，没有足够氧气燃烧。气体只有在两个浓度之间才可能引爆，这两个浓度称为<strong>爆炸下限</strong>（LEL,lower explosive limit）、<strong>爆炸上限</strong>（UEL,upper explosive limit），惯以百分比表示。它们是气体的<strong>爆炸极限</strong>（又称<strong>爆炸界限</strong>）。</li>
<li><strong>闪点</strong>是指挥发性物质所挥发出的气体与火源接触下会闪出火花（短暂）点燃的最低温度</li>
</ul>
<p>除此之外还有许多安全示例，不得不提我对公司安全防范方面真的很满意。也许初时觉得繁琐，但深思确实都是站在员工生命安全一侧的举措。</p>
<p>虽然有些时候跨过规矩会省事，但随之而来的是风险增加。</p>
<h2 id="ESP32"><a href="#ESP32" class="headerlink" title="ESP32"></a>ESP32</h2><p>但是这周偶然在B站看到了使用ESP32实现的墨水屏，还挺有意思的。</p>
<p>于是乎便稍微关注了下，随后发现这东西制作小玩意还真挺方便的，蓝牙与WiFi的存在使得其可以通过API与互联网进行交互完成许多有意思的功能—天气、股票曲线、动图、TODO提示、墨水屏手表等等。</p>
<p>关键是这芯片是真的很便宜，价格非常美丽，买来玩玩完全不心疼，而且似乎可以通过Python对功能进行编译，此前使用Python编译的我仅知道树莓派。</p>
<p>进一步了解后，发现我关注的知名UP主稚晖君对于ESP32也有过应用，自研了一个透明小电。当时他这个项目似乎是手头有什么就用什么(好想也像这样融会贯通啊！！！！)，完全照搬会踩很多坑，因此可以直接参考这个改良过后的版本—<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1d3411T77a/?spm_id_from=333.337.search-card.all.click">视频链接</a>，当然加群是必须的，开源资源整理的非常全面。<br><img src="https://s2.loli.net/2023/07/31/W3DbVfu7E8zUgkA.png" alt="image-20230731230146725"></p>
<p>目前我的想法是用ESP32做一个墨水屏天气+时间显示器(暂时想要这些功能)的小摆件，然后稍微懂点ESP32再去做小电视，已经是一个有工资的社会人了，买东西倒无需像大学一样束手束脚，好耶！！</p>
<h1 id="物价带来的一点点思考"><a href="#物价带来的一点点思考" class="headerlink" title="物价带来的一点点思考"></a>物价带来的一点点思考</h1><p>之间进城里剪个头发，问一圈全是四五十，找了一阵才看的一个三十多的。当时就为福鼎这六线城市但是近乎一线城市(这里说的是长沙)的物价感到诧异，随便吃点冒菜也嘎嘎贵就更让人不能理解了。</p>
<p>现在终于知道(也许是真相？)福鼎这边物价不便宜的原因了。</p>
<p>从某种意义上来说这里属于江浙一带的后花园，虽然在福建，但这里的人距离温州却是最近的，而且大部分本地人都赶上了时代，在江浙一带有所收入，因此豪车也不罕见。</p>
<p>但个人收入不等同于地区发展，先富似乎没有带动后富。</p>
<p>但宁德—福鼎在整个福建确实属于很穷的，几个人的富裕与当地财政又有多大影响呢？</p>
<p>似乎老家也是这样，虽然刚经过国家帮扶摘掉贫困县帽子，当地不缺穷人—或者说基本是都是温饱。</p>
<p>但绝不缺富豪，豪车豪宅也见过不少(也许都是在外地发了财的)。</p>
<p><strong>所以先富带动后富这样的方针又是否正确呢？在思索最近的大新闻，似乎都是富起来以后愈加富，富者恒富，贫者恒贫。存在疑惑！</strong></p>
<p>讲到这就不得不提一嘴去玩过的岳阳了，那确实是一座非常宜居的城市—至少见识浅薄的我是这么认为的，作为湖南第二梯队的城市，岳阳的物价并不算贵—当然如果整日爽吃烧烤那可真是便宜不了一点！</p>
<p>近几年捕鱼禁了，洞庭湖旁工业也禁了，在岳阳的人闲暇时逛一逛湖畔风景(不止洞庭湖哦，还有南湖)那凉爽的湖风当真让人畅意。当然，房价也是需要考虑的，这边房价不太便宜，当然也并不贵，属于努力可以够到的水平吧。</p>
<p>风景+美食+交通便利+生活节奏较慢种种原因让我对这个城市印象格外的不错。</p>
<p>希望以后可以多出去看看，好好体验下大好河山的自然美景与人文风俗，想想真是让人期待。</p>
<h1 id="忙碌的周末"><a href="#忙碌的周末" class="headerlink" title="忙碌的周末"></a>忙碌的周末</h1><p>整个周末基本都在宿舍，周六忙于拼积木—整整一天。周日则持续摆烂状态，玩一会学一会，玩一会学一会，不过精神倒是放松了不少，挺舒服的。而且做出来的积木也差强人意—毕竟第一次做。<br><img src="https://s2.loli.net/2023/07/31/TsuoQLxtIBjNfKi.png" alt="image-20230731230542899"></p>
<p><img src="https://s2.loli.net/2023/07/31/dNuEx7K3stlwYnV.png" alt="image-20230731230551252"></p>
<p>我就想啊，能不能把周末也加入可以调休，狠狠的工作狠狠的玩。当然，我也知道这只能是自己YY一下。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉底不会写诗-周记04</title>
    <url>/2023/08/07/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B004-md/</url>
    <content><![CDATA[<h1 id="怀念"><a href="#怀念" class="headerlink" title="怀念"></a>怀念</h1><p>最近总是想学校、想长沙、想家。</p>
<p>突如其来，也许走着走着，刷着手机，吃着饭，突如其来涌上心头。有点想吃校门口的烤面筋、烧烤、鸡公煲，哪怕是吃到腻歪的黄焖茄子，都很怀念。那种张着嘴巴，呼哈呼哈，拍着小肚子散着步回宿舍，漫谈着天南地北，憧憬着那个叫做以后的东西。时不时叫上人，去大碗先生爽吃干锅鱿鱼，或是出个小远门体验下五一各种小吃，也很怀念湖南的蛙来哒。正在写这段话的我刚淋完雨还饿着肚皮，不由吞咽了一口口水。想吃吴酥生的绿豆糕了~</p>
<p>从未距离故乡如此之远，生活方式极大差异，让我格外不适应。有时在餐桌上看着一桌的菜却无从下手，在小吃街逛了一圈却空手而归。</p>
<p>同时，也确实想家了，也不知老人家在家身体如何。</p>
<p>怀念湖南了，我也不知道何时能适应，或者是忘却？</p>
<span id="more"></span>

<h1 id="新玩意"><a href="#新玩意" class="headerlink" title="# 新玩意"></a># 新玩意</h1><h2 id="typora插件"><a href="#typora插件" class="headerlink" title="typora插件"></a>typora插件</h2><p><a target="_blank" rel="noopener" href="https://github.com/obgnail/typora_plugin">typora插件集合，功能增强工具</a></p>
<p>在网上闲逛时，偶然看到这个关于typora插件的项目，仔细看了看插件的功能，直呼舒服了。</p>
<p>typora我一直是用来做总结性或者写一些比较短的东西的，很少用来写会频繁更新的。</p>
<p>虽然其非常简洁，而且用起来很舒服，但是章节折叠的问题一直让我很难受，如果篇幅一旦长了想找之前的某个内容会显得有些困难。</p>
<p>当然新版的typora提供了侧边栏的目录功能，这一缺陷其实还好，但是如果可以折叠章节，码字体验也许会好一点，而恰巧这个插件里面有这一功能。</p>
<p>其他插件功能也各种各样，有许多是我未曾考虑，当然某种意义上也是并不在需求范围之内的，不过插件功能启用与否可以基于自己需求的，不需要那么不启动这一个就行了。</p>
<p><img src="https://s2.loli.net/2023/08/07/7KzxtDE8uocfa65.png" alt="image-20230807201908380"></p>
<h2 id="激活正版IDM"><a href="#激活正版IDM" class="headerlink" title="激活正版IDM"></a>激活正版IDM</h2><p><a target="_blank" rel="noopener" href="https://github.com/lstprjct/IDM-Activation-Script">项目地址</a></p>
<p>之前用的IDM都是网上蹭来的，也一直没有更新，这个项目刚好可以解决这个问题，而且属于一劳永逸式，是支持继续更新的—只要不被官方逮捕。</p>
<h2 id="将下述代码复制到Windows的powershell中并运行，然后会弹出一个命令描述符窗口，输入1进行选择即可"><a href="#将下述代码复制到Windows的powershell中并运行，然后会弹出一个命令描述符窗口，输入1进行选择即可" class="headerlink" title="将下述代码复制到Windows的powershell中并运行，然后会弹出一个命令描述符窗口，输入1进行选择即可"></a>将下述代码复制到Windows的powershell中并运行，然后会弹出一个命令描述符窗口，输入1进行选择即可</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enable TLSv1.2 <span class="keyword">for</span> compatibility with older clients</span></span><br><span class="line">[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor [System.Net.SecurityProtocolType]::Tls12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DownloadURL = <span class="string">&#x27;https://raw.githubusercontent.com/lstprjct/IDM-Activation-Script/main/IAS_0.8.cmd&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FilePath = <span class="string">&quot;<span class="variable">$env</span>:TEMP\IAS.cmd&quot;</span></span></span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Invoke-WebRequest -Uri $DownloadURL -UseBasicParsing -OutFile $FilePath</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    Write-Error $_</span><br><span class="line">        Return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Test-Path $FilePath) &#123;</span><br><span class="line">    Start-Process $FilePath -Wait</span><br><span class="line">    $item = Get-Item -LiteralPath $FilePath</span><br><span class="line">    $item.Delete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后弹窗中会让你取一个用户名，随便写即可，回车就行了，最后命令行会出现successful activate，代表激活成功</p>
<p>打开IDM，点击上方工具栏中注册，就可以看的已经激活了</p>
<p><img src="https://s2.loli.net/2023/08/07/2KYgvBEZFrcIthq.png" alt="image-20230807201928450"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉底不会写诗---周记05</title>
    <url>/2023/08/14/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B005/</url>
    <content><![CDATA[<p>这周还是愉快轻松的一周，考试考完就舒服了，成绩什么的，我是卷不来的，当下的心情愉悦最重要压！</p>
<h1 id="新玩意"><a href="#新玩意" class="headerlink" title="新玩意"></a>新玩意</h1><p><a target="_blank" rel="noopener" href="https://tagly.notion.site/">全网漫游指南</a> 我认为是一个非常不错的导航站，内容挺多有用的，当然最终还是要根据自己的需求看看用哪一个，其中的终身学习板块里面能看到很多优秀的问答社区，真的很不错。</p>
<span id="more"></span>

<p><img src="https://s2.loli.net/2023/08/14/h7E3FJ8r4K5xRXy.png" alt="image-20230814235325155"></p>
<h1 id="快递被糟蹋了后的思索"><a href="#快递被糟蹋了后的思索" class="headerlink" title="快递被糟蹋了后的思索"></a>快递被糟蹋了后的思索</h1><p>群里收的kindle pw4到了，去拿快递。看的外包装的一刻心里一凉，稀碎，于是当场就开箱了，看看屏幕还活着没。只能说，命真大。<br><img src="https://s2.loli.net/2023/08/14/4bzKBfGnASl6yUT.png" alt="快递"></p>
<p><img src="https://s2.loli.net/2023/08/14/iUq2wLlGuVWEatd.png" alt="image-20230814235458187"></p>
<p>虽然外壳战损，但确实是活着。而且没什么问题。</p>
<p>刚好今天刚寄出去一个生日礼物—diy的便携屏，积木外壳。由于没有原包装，所以寄的时候顺丰直接和我说要寄的话自己负责，心里真是七上八下，非常担忧！</p>
<p>回来的路上便联想了一下，快递做到安全运输，不暴力真的那么难嘛，哪怕国内以安全保障闻名的顺丰。</p>
<p>作为一个经常网购的人，我也算接触过了各式各类的快递，见最离谱的是外壳已经成渣了，或者说，也就剩那点纸了。</p>
<p>从揽件到运输到派件，快递不断辗转，纯人工配送想要保证运输安稳，丝毫不被碾压确实不太可能。但是快递员们将购物者也许期待已久的快递，当作垃圾从卡车上一件一件的往下摔或是丢，自然让人对于其安全性不报任何信任，或许由于价格低廉的原因？</p>
<p>价格 &#x3D;&#x3D; 质量 &#x3D;&#x3D; 快递员对快递处理方式？ 真是让人费解！！！</p>
<p>我稍微整理下快递在运输途中受损的原因</p>
<ul>
<li>揽件时放置不当，导致运输过程中快递遭到挤压</li>
<li>在物流中心分转时，物件被摔或是挤压</li>
<li>派送或者放到驿站时，物件如小山一般堆积在地上进行分拣或者堆在车上派送</li>
</ul>
<p>没有解决方法嘛，自然是有的。而且这些缺陷其实顺丰与京东都有所规避，这也是为什么在运输贵重物品时一般选择二者的重要原因。</p>
<p>现在快递入库和出库使用的都是码，倘若采用智能揽件+出库的方式。将快递通过计算机分拣与整理，便可以通过无情绪的机器，重复这繁琐枯燥的过程，而且安全整齐。</p>
<p>快递箱的型号就那么些，市面上的纸盒大部分也有其标准尺寸，在揽件时堆积完全可以有序的进行堆积，而不是一窝蜂塞进卡车。</p>
<p>关于装车这一点其实京东确实非常好，由于大二经常接触京东小哥，倒也见过许多次他们装车，至少快递大小是给你放在车上不同地方堆好的，避免了快递遭受不公平体量碾压的风险。</p>
<p>而派送方面其实目前也有许多大城市的物流开始接入智能设备了，无论是自提柜还是无人送货车都是其一种体现，当然菜鸟驿站的出现毫无疑问也是保障了快递安全的，虽然无法避免卸货时快递遭受的虐待。</p>
<p>仔细思考如今的快递，似乎在派送方面做的还是不错的，至少我认为在保证盈利的情况下驿站这东西真的很好。</p>
<p>综上，倘若使用全过程接入智能设备，程序化处理快递，将装车+转运+分包至快递点的任务都接入系统，大部分因为堆叠与运输造成的快递损坏其实都可以避免，剩下的揽件与派送导致的质量问题其实并不多。二者的快递总量都不大，挤压和碰撞带来的损坏已经很小，唯一需要注意的就是快递被快递员当作工作烦躁泄愤的工具被无情抛来抛去，这对于工作效率其实并无任何提升，只是也许丢的时候很爽罢了o.0。</p>
<p>但是，不可行。快递这行，人工可比接入智能设备便宜多了，要知道快递是需要全国达的，在不知道几线的城市接入这些玩意，怎么可能盈利？邮政的全国通是快递员跑出来的，山路，索道，鸟不拉屎的地方也给你送到。</p>
<p>总而言之就是人工比机械便宜，快递员还是比外卖员香的，至少坐的是三轮，有棚子。</p>
<p>但是在一线城市接入智能设备显然是一个趋势，也是正在发生的。<strong>但是，我选择自提，那无人车配送一次两块，好贵！！！！</strong></p>
<h1 id="小碎片"><a href="#小碎片" class="headerlink" title="小碎片"></a>小碎片</h1><h2 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h2><p>烧烤估计是我在这边吃的最多的小吃了，时不时就想去搞两个，打包回来坐在电脑前嘎嘎吃。虽然菜品不是很多，但是吃起来还是比较爽的，我这算不算实现了烧烤自由呢？</p>
<p><img src="https://s2.loli.net/2023/08/14/Ji6YbGqZOlc7pTk.png" alt="image-20230814235526466"></p>
<h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><p>书签日益增多，虽然我已经做了十分详细的分类与标签了，但内容一多仍然让人觉得麻烦。几百个书签还是有些多了。</p>
<p><img src="https://s2.loli.net/2023/08/14/DlYawBI231rfKpe.png" alt="image-20230814235548962"></p>
<p>我打算抽点时间整理一下，主要是进行细分以及打标签。</p>
<p>这些书签里面很多都是文章，这些东西可以选择<strong>加入cubox或者chrome的阅读清单</strong>，这样一来既可以进行同步又可以极大的减少书签数目，方便管理与使用。</p>
<p>一劳永逸的方法还是以后从加入书签开始就进行分类与打tag，增加对书签的描述，虽然需要一点思考，但我觉得这是值得的，想找的时候总归有迹可循。</p>
<p>其实不只是书签，电脑上很多东西也是，我已经长记性了，基本都进行了分门别类，在下载的时候就不要一直next，仔细看看存储位置。</p>
<p>不行就只能everything(软件名)咯！</p>
<h2 id="篮球赛与聚餐"><a href="#篮球赛与聚餐" class="headerlink" title="篮球赛与聚餐"></a>篮球赛与聚餐</h2><p>这周和前辈们一起打了一场球赛，第一节打下了领先20多分，连忙在第二局开始控分。</p>
<p>都是一个部门的兄弟，自然还是的<strong>讲究友谊</strong>的。得益于队友们实在强大，我得以在第四节上去混了一段时间，居然还侥幸假动作晃开，进了一个。</p>
<p>赛后的聚餐是一家湘菜馆，来这边还是第一次吃这玩意，属实畅快。</p>
<p><img src="https://s2.loli.net/2023/08/14/QbV5l4DRjuacAsZ.jpg" alt="IMG_20230812_185542"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>苏格拉底不会写诗---周记07</title>
    <url>/2023/09/02/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E4%B8%8D%E4%BC%9A%E5%86%99%E8%AF%97-%E5%91%A8%E8%AE%B007/</url>
    <content><![CDATA[<p>这周自己状态很差，所以拖了三天了，翻来覆去还是觉得应该写一下。</p>
<h1 id="迫切的想离开现在环境"><a href="#迫切的想离开现在环境" class="headerlink" title="迫切的想离开现在环境"></a>迫切的想离开现在环境</h1><p>不知道有没有提过，我目前的工作是需要倒班的，当时选的时候其实并没有害怕，自认为在大学也不是没通宵过，熬的夜也不少，所以这点强度应该是没什么问题的。但是事实告诉我，大错特错。熬夜规律与日夜颠倒、作息紊乱真的不是一个东西，那种想睡睡不着，干活眼皮打架，空闲时间浑浑噩噩的感觉真是太差了。更不用提身体方面，内分泌紊乱，时不时出现胸口骤疼的情况了。</p>
<span id="more"></span>

<p>最初幻想的是42休21，而且工资尚可，当然毫无意义需要付出倒班的代价。但是事实与我想的确实有些大相径庭，各方面的。让我最心动的毫无疑问是42休21，我认为这可以使得我有充裕的时间可以享受自己的生活，做一些自己想做的，想看的，想见的。但是现实往往残酷不堪，但现实就是现实，在休息时间里，我需要学习，需要培训，需要准备考核，需要参加团建，当然毋庸置疑的我也需要很长的时间来缓解两个夜班通宵带来的精力损耗。用前辈们的话来说，习惯就好，但是人总会思考未来的，何况一个个前辈就在我眼前，看着他们仿佛就可以看到自己的未来。如果一直坚持不懈的学习，也许倒班20年有机会从值长位置离开，结束倒班生涯，但是身体真的吃得消嘛？我不知道，但是似乎都有大大小小的毛病。而前辈们的投入呢，值得吗？我也在思考这个问题，这是我第一份工作，如果干下去自然是最后一份，但是对于其他公司与行业，或多或少通过同学或者好友的信息也能了解。没有不累的，如果想要有收入，都很累，无论是电网还是其他国企央企，至少我知道的工科相关的，都很累。但是，累也是有区别的，说好听点，我目前上升路径稳定，说难听点，人生一眼望得到头。</p>
<p>若熬一熬过去了也倒好，但是前辈们一干就是二十年，基本人的一生都在这上面了。坦白而言我无法享受这种枯燥与折磨，这于我而言无法接受。所以我离职或者调岗的想法无比强烈，而想法萌芽到成长往往很迅速，精神内耗了两天我还是选择了向师傅开口。他其实也一直想调岗，申请了很多年了，但是因为没有医院证明证明身体出问题了，始终没法摆脱。而且有家庭有负担，辞职显然不现实，这行业也没法转职，这就是一座围城，拿的越多，想走越难。和他谈过以后，我觉得等休假结束与值长谈谈调岗的可能，若不行便只有考研离职这一条路了。</p>
<h1 id="太姥山小游"><a href="#太姥山小游" class="headerlink" title="太姥山小游"></a>太姥山小游</h1><p><img src="https://s2.loli.net/2023/09/02/1wIeGYsrjHZOzJx.png" alt="202309020238860.png"></p>
<p>太姥山还是非常不错的，云雾缭绕的感觉真的很棒，岩石在云雾中若隐若现，登高远眺难免心旷神怡。</p>
<p><img src="https://s2.loli.net/2023/09/02/otGiZulMTIJ2khm.jpg" alt="mmexport1693121725593_1693454266872_0"></p>
<p>若要说让我印象比较深刻的还得是走一线天的时候，非常狭窄，从外面看过去绝是无法通行的，里面更是狭窄，处处弯腰前行，侧身缓缓挪动方才穿过。各种山基本都会有个都有一线天，但我觉得这才是当真可以称得上这个名字的。<br><img src="https://s2.loli.net/2023/09/02/DnI3eG5axg4Y6Ad.png" alt="image-20230902023612368"></p>
<p>照着地图找，在五百罗汉寺久久找不到去往龙鲤湖的道路，已经找不到路时只得返回小铺歇息，老板娘热情的给整了一杯17年的白茶，不得不说哪怕不怎喝茶的也仍然觉得那味道不错。喝过以后口中回味仍在，但又不会显得非常涩，而是一种很舒畅的感觉，我不太懂茶，只是单纯觉得确实不错。</p>
<p>下山时走栈道，眼前尽是云卷云舒，闭眼尽是清风拂面。虽然是正午，但并不炽热，反而有些凉爽，身边总有一阵一阵的风拂过。这里的风与曾爬过得武功山相差甚远，武功山上尽是绿茵一片，风凶猛的很。而这里放眼看去尽是各种石头，风绵长而清爽。<br><img src="https://s2.loli.net/2023/09/02/nrXghumwcaN5Glp.jpg" alt="IMG_20230827_142653_1693493436962_0"></p>
<p>登高这件事是很有意思的，我觉得非常适合心事重重压力大的人，爬山的时候便没有那么多的想法，防空脑袋的感觉真的很好。</p>
<h1 id="时空恋旅人"><a href="#时空恋旅人" class="headerlink" title="时空恋旅人"></a>时空恋旅人</h1><p>这部电影是躺在床上看的， 所以对于细节也许不是太清晰，因此我只想记录下自己看的时候与看完的一些感受。</p>
<p>如果我能穿越时空，我会干什么？我觉得我也许与Tim最初的想法一样，首先搞钱。但钱在解决了舒适生活之上，带来的未必就是快乐，关于这个问题，前段时间看的一篇文章做出了非常详尽的描述—<a target="_blank" rel="noopener" href="https://moretothat.com/money/">Money Is the Megaphone of Identity</a>，这里有一副图，我看完至今仍然在思考，我想要的是哪个阶段。目前来说是freedom in work。</p>
<p><img src="https://s2.loli.net/2023/09/02/z5LqkIAQXWT2ufm.png" alt="image-20230902023743581"></p>
<p><img src="https://s2.loli.net/2023/09/02/UeBzhRJXylG3Ebt.png" alt="image-20230902023749662"></p>
<p><img src="https://s2.loli.net/2023/09/02/XPaSeCnoEyTMhvm.png" alt="image-20230902023757531"></p>
<p><img src="https://s2.loli.net/2023/09/02/uO9s52Z6RJikjWg.png" alt="image-20230902023815825"></p>
<p>电影中Tim父亲反复强调的，以及剧情演绎所告知的，其实始终是活在当下以及珍惜现在。假如给我重来一次的机会，我一定会选择早恋。也许那的的确确是青春期的萌动，但是也好过如今乱七八糟的思绪，那是单纯直白的喜欢。如今哪怕遇到也许动心，也许起意的女孩，但瞻前顾后总是算了算了，久而久之似乎就习惯了一个人，直到害怕另一者的加入。</p>
<p>毫无疑问，穿越时空是不现实的，更别说剧中这种几乎毫无蝴蝶效应的情况，Tim的一切都仅仅改变自己的生活。最初的遇到玛丽以后直接穿回去与她在一起，第一次窘迫那就再来一次，熟稔的像个老男人，一次次改变着生活中的小窘境。妹妹酒驾事故穿越回去救她，甚至穿回那一个新年夜，远离了渣男。但这一次似乎蝴蝶的翅膀终究煽动，儿子变了，且回不来。直到后面父亲去世后，穿越回去的闲聊。穿越时空给Tim带来了快乐，这是毫无疑问的，但是随之而来的，也是不一样的烦心事。</p>
<p>活在当下，这其实是一件很难的事情，我总是会不由自主的畅想将来，怀念过去或者后悔。剧中后面的时光在琐碎与闲暇中过去，生活仍然是生活，改变的只是Tim的心态与接受生活的方式。</p>
<p>为什么？qwq，因为他有玛丽，衣食无忧，心态良好。说回自己，不得不承认，这样田园牧歌一般的生活，对于我来说真是太具吸引力了，可以做自己喜欢且想做的，闲时大可携侣同游，衣食无忧。</p>
<p>Tim应该是处于freedom in attention，我目前来说应该是Homelessness 到 Basic Necessities，虽然有家可回但是毕竟不是自己一个人的小屋，工资实现吃穿自由倒是没什么问题。但思索未来，似乎自己永远也达不到free in work的程度，这并不容易，尤其是在大环境向下走的时候。</p>
<p>未来的路还很长，但是我并不想在现在就给他走死，加油吧男孩。</p>
<h1 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a target="_blank" rel="noopener" href="https://thepalindrome.org/p/matrices-and-graphs">线性代数—矩阵是图，图是矩阵</a>： 这篇文章主要介绍图与矩阵之间的关系，矩阵可以用图表示，图也可以用矩阵表示。</p>
<p><a target="_blank" rel="noopener" href="https://www.moonkite.cn/category/network/20%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E6%A5%9A-IP-%E5%8D%8F%E8%AE%AE/">20张图说清楚 IP 协议</a> ：这篇文章感觉还是很适合入门IP协议知识的，关于IP工作的一些关键点都有涉及，用心做图解真的好评。</p>
<p>就这样吧，争取下周多多记录，多写写</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机的启动---操作系统的引导</title>
    <url>/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/</url>
    <content><![CDATA[<p>学408当时听课时，这里讲的基本就是说BIOS引导什么的，属实不是很清楚，索性找了几个详解的文章学习了下，梳理了大体流程，这里简单概括下。</p>
<p>首先简要过一遍流程：按下开机按钮上电—主板上写死的固件(硬件电路)运行—CPU将所有寄存器的值都设为默认值—CPU指向BIOS(在主板ROM中的固定位置)–BIOS程序进行硬件检测和初始化操作—搜索启动盘—（读取 MBR）将启动盘中的 0 盘 0 道 1 扇区的 512 个字节原封不动的写入(拷贝)内存中<code>0x7c00</code>开始的位置—确定活动分区—确定引导扇区，将其加载到内存中—操作系统加载。</p>
<span id="more"></span>

<h1 id="按下开关-不重要"><a href="#按下开关-不重要" class="headerlink" title="按下开关(不重要)"></a>按下开关(不重要)</h1><ol>
<li><p>CPU会执行一个复位（Reset）过程：CPU内置有一个复位电路，该电路会向CPU的所有寄存器发送一个特殊的复位信号，以重置所有寄存器。</p>
</li>
<li><p>CPU将所有寄存器的值都设为默认值</p>
<ul>
<li><p>PC 寄存器被强制初始化为 0xFFFF0 ，这也是BIOS程序的入口地址。</p>
<ul>
<li>段基址寄存器 cs 初始化为 0xF000</li>
<li>偏移地址寄存器 IP 初始化为 0xFFF0</li>
<li>根据实模式下的最终地址计算规则，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。</li>
</ul>
</li>
<li><p>复位信号会将通用寄存器AX、BX、CX、DX等以及其他寄存器如标志寄存器FLAGS、指令指针寄存器IP等重置为默认值。默认值通常是0或者一些固定的值，具体取决于CPU架构和制造商。</p>
</li>
</ul>
</li>
<li><p>其他…</p>
</li>
</ol>
<h1 id="启动BIOS"><a href="#启动BIOS" class="headerlink" title="启动BIOS"></a>启动BIOS</h1><ol>
<li>BIOS上电自检POST（Power-On Self Test）</li>
<li>初始化硬件设备</li>
<li>按照顺序搜索启动设备</li>
<li>BIOS在启动时会按照一定的顺序搜索可用的启动设备，通常包括硬盘、CD&#x2F;DVD光驱、USB闪存驱动器等。这个顺序可以通过BIOS设置进行配置，并被称为“启动顺序”或“启动顺序”。</li>
</ol>
<h1 id="BIOS加载启动区"><a href="#BIOS加载启动区" class="headerlink" title="BIOS加载启动区"></a>BIOS加载启动区</h1><ol>
<li>BIOS 会按照设备顺序，读取主引导记录MBR，即读取0 盘 0 道 1 扇区的内容，如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区。<ul>
<li>MBR（Master Boot Record，主引导记录，大小为 512 字节）<ul>
<li>第1-446 字节：包含了引导程序的代码，即调用操作系统的机器码，可以被 CPU 直接执行。</li>
<li>第 447-510 字节：分区表（Partition Table）信息，将硬盘分为了若干个分区。<ul>
<li>分区表（Partition Table）记录了硬盘上的所有分区信息，包括每个分区的起始位置、大小和分区类型等。</li>
</ul>
</li>
<li>第 511-512 字节：“MBR结束标志”（MBR End of Sector Marker），记录签名（0x55 和 0xAA），若记录签名正确，表示设备可以用于启动—也就是说这个区是启动区。</li>
</ul>
</li>
</ul>
</li>
<li>如果计算机确定了当前盘的MBR是启动区，那么BIOS会将硬盘中启动区的 512 字节的数据，原封不动复制到内存中的 0x7c00处<ul>
<li><img src="https://s2.loli.net/2023/04/09/OHZa8d5YL4SPR32.png" alt="BIOS将启动区复制进内存中">{:height 717, :width 663}</li>
</ul>
</li>
</ol>
<h1 id="查找活动分区（引导分区）"><a href="#查找活动分区（引导分区）" class="headerlink" title="查找活动分区（引导分区）"></a>查找活动分区（引导分区）</h1><ol>
<li>PC寄存器的值变为0x7c00，从这里开始运行—启动区开始跑起来！</li>
<li>当BIOS将MBR加载到内存中后，它会读取分区表中的<strong>活动分区</strong>标识位。若分区表中的活动分区标识位被设置为1，则表示该分区是可引导的。<ul>
<li>分区表记录了磁盘上所有分区的位置、类型和大小等信息，在分区表中，有一个标识位被称为<strong>“活动分区”（Active Partition）</strong>，一般为某个主分区，也就是至多四个主分区之一。此标识位指示了系统应该从哪个分区引导操作系统</li>
<li><strong>每个硬盘最多只能有一个活动分区。</strong>如果硬盘上存在多个操作系统，那么每个操作系统都需要独立的活动分区来引导启动。</li>
</ul>
</li>
<li>BIOS会跳转到该分区上的的<strong>引导扇区（Boot Sector）</strong>上，并将其加载到内存中执行。<ul>
<li>引导扇区是一个特定的扇区，通常包含了操作系统引导程序的代码和数据，例如Windows操作系统的<code>bootmgr</code>或<code>grub</code>引导程序。</li>
</ul>
</li>
</ol>
<h1 id="操作系统加载（不重要）"><a href="#操作系统加载（不重要）" class="headerlink" title="操作系统加载（不重要）"></a>操作系统加载（不重要）</h1><ol>
<li>一旦引导扇区（Boot Sector）被加载到内存中执行，它会继续加载操作系统的其他部分。通常，这涉及到在文件系统中查找操作系统的核心文件，并将其加载到内存中。在 Windows 操作系统中，这个核心文件可能是 ntoskrnl.exe，而在 Linux 操作系统中，它可能是 vmlinuz。</li>
<li>操作系统的核心文件被加载到内存后，它就开始初始化操作系统，包括创建进程、分配内存等。</li>
<li>接下来，操作系统会开始运行第一个进程，这通常是 init 进程或 systemd 进程，它负责启动其他进程和服务。最终，操作系统完成了启动过程，并准备好接受用户的交互请求。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>ChatCPT回答</li>
<li>九曲阑干计算机操作系统课程</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247499226&idx=1&sn=1ff3d54a3608423b7781142ae3ac62ca&chksm=c2c58777f5b20e61664a51d31ab779bbe68c317c3459218c7cd4b9530887dbb33470628c3248&cur_album_id=2123743679373688834&scene=178&subscene=10000&sessionid=0&clicktime=1680866166&enterid=1680866166&ascene=3&fasttmpl_type=0&fasttmpl_fullversion=6624157-zh_CN-zip&fasttmpl_flag=0&realreporttime=1680866396392&devicetype=android-31&version=280021bd&nettype=ctnet&abtest_cookie=AAACAA==&lang=zh_CN&countrycode=CN&exportkey=n_ChQIAhIQCyZc6Yv5z6dy2QVteNwcHxLcAQIE97dBBAEAAAAAAPtNGgF0q1cAAAAOpnltbLcz9gKNyK89dVj0Du2uiGcJqb8sHF7c2U2ij/b1CFiEhbUp8mVvdOz/xIs2zDIQ3brTKgtycIfKAkKlayYbYQMBIm6WXwMsU2L7z+gh0Kfqyfyf+rEaNY9K/7gtjEP5eq5M93ABeVZJmYqG08bUj9g+0287IQOcBKnZnzQ4iUP1RaJZXZheVCyPIqgmZeigDneK3E5XhMUWbZbA/5Zc4KLf0VInmzJH9Lda0S7JqVbaIqnK3m9EjszFaU6l04m3u1Y=&pass_ticket=XcWSJctQOhG8pwa0eQOrUbdf8Ys1LQVUfhi198uiWp2rQ4FPIsYikPGtEdpQog1oXhFbKZFsjygJG7S+63Fzxw==&wx_header=3">你管这破玩意叫操作系统源码 | 第一回 最开始的两行代码</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247483867&idx=1&sn=76ece31324d32922a7cb9db129decd3f&chksm=c2c67b76f5b1f260bb459e12c029f8e6a7a813055811ab8ed794a3f36d0d7d50e66df27f4f0a&scene=21#wechat_redirect">全网最硬核讲解计算机的启动过程</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的deque.md</title>
    <url>/2024/04/06/python%E4%B8%AD%E7%9A%84deque/</url>
    <content><![CDATA[<h2 id="什么是deque"><a href="#什么是deque" class="headerlink" title="什么是deque"></a>什么是deque</h2><p><code>deque</code>即队列，数据结构中的一种基本类型。</p>
<p>队列是操作受限的线性表，只允许在一端进行插入 (入队)，另一端进行删除 (出队)</p>
<ul>
<li>操作特性：先进先出 FIFO</li>
<li>队头（Front）：允许删除的一端</li>
<li>队尾（Rear）：允许插入的一端</li>
<li>空队列：不含任何元素的空表</li>
</ul>
<p>队列的类型有多种，上述定义是广义的，比如还有双端队列、循环队列，deque基本都可以实现这些队列的特性。继续看下去吧~</p>
<p>Python中<code>deque</code>和列表有很多相似地方，基本使用非常类似。</p>
<span id="more"></span>

<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空队列</span></span><br><span class="line">new_deque = deque()</span><br><span class="line"><span class="built_in">print</span>(new_deque)  <span class="comment"># deque([])</span></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;队列的形式是deque([***])&#x27;&#x27;&#x27;</span></span><br><span class="line">new_deque.clear()  <span class="comment"># 清空队列</span></span><br></pre></td></tr></table></figure>

<p>在创建队列时，我们可以将其他可迭代对象，迭代元素作为队列的元素，怎么理解呢？</p>
<p>队列的形式是<code>deque([])</code>，假如初始化时，里面是一个可迭代对象，那么队列会讲可迭代元素作为他的初始元素，这一点类似 解包然后打包，可以通过如下例子看一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_deque = deque(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_deque)  <span class="comment"># deque([&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;])</span></span><br><span class="line">new_deque.clear()  <span class="comment"># 清空队列</span></span><br><span class="line"></span><br><span class="line">new_deque = deque([<span class="string">&quot;hello&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(new_deque)  <span class="comment"># deque([&#x27;hello&#x27;])</span></span><br><span class="line">new_deque.clear()  <span class="comment"># 清空队列</span></span><br></pre></td></tr></table></figure>

<h3 id="增删改查等操作"><a href="#增删改查等操作" class="headerlink" title="增删改查等操作"></a>增删改查等操作</h3><p>增删改查操作和列表基本一模一样，列表可以用的许多基本方法<code>deque</code>也可以使用(注意：队列没法切片)，这里举例说明.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 队列中增加元素 --- 入队操作</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从下面的操作结果，我们可以看出，队列和列表一样，增加元素都是默认增加在右边的，而且append的操作完全一致</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">new_deque = deque()</span><br><span class="line">new_deque.append(<span class="string">&quot;first element&quot;</span>)</span><br><span class="line">new_deque.append(<span class="string">&quot;second element&quot;</span>)</span><br><span class="line">new_deque.append([<span class="string">&quot;first list&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(new_deque)</span><br><span class="line"><span class="comment"># deque([&#x27;first element&#x27;, &#x27;second element&#x27;, [&#x27;first list&#x27;]])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;队列有一种类型叫做双端队列，顾名思义，两端都可以执行入队出队操作，因此实际上我们也可以从左边执行入队操作&#x27;&#x27;&#x27;</span></span><br><span class="line">new_deque.clear()  <span class="comment"># 清空队列</span></span><br><span class="line">new_deque.appendleft(<span class="string">&quot;first element&quot;</span>)</span><br><span class="line">new_deque.appendleft(<span class="string">&quot;second element&quot;</span>)</span><br><span class="line">new_deque.appendleft([<span class="string">&quot;first list&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(new_deque)</span><br><span class="line"><span class="comment"># deque([[&#x27;first list&#x27;], &#x27;second element&#x27;, &#x27;first element&#x27;])</span></span><br><span class="line">new_deque.clear()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;deque 和 list 一样，同样的也支持使用 extend 将「可迭代对象」的所有元素都依次添加进队列，和append类似，extend也可以从左边入队，即 extendleft&#x27;&#x27;&#x27;</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l2 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">l3 = [<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>]</span><br><span class="line">new_deque = deque(l1)</span><br><span class="line"><span class="built_in">print</span>(new_deque)</span><br><span class="line"><span class="comment"># deque([1, 2, 3, 4])</span></span><br><span class="line">new_deque.extend(l2)</span><br><span class="line"><span class="built_in">print</span>(new_deque)</span><br><span class="line"><span class="comment"># deque([1, 2, 3, 4, 5, 6, 7, 8])</span></span><br><span class="line">new_deque.extendleft(l3)</span><br><span class="line"><span class="built_in">print</span>(new_deque)</span><br><span class="line"><span class="comment"># deque([-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列的删除操作 --- 出队</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;队列的出队操作使用的方法也是 pop()，当然和入队操作一样，出队可以双端执行，默认也是从右端出队，可以通过如下示例理解&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 初始化队列</span></span><br><span class="line">de = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment"># 默认也是右端出队</span></span><br><span class="line"><span class="built_in">print</span>(de.pop())  <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左端出队</span></span><br><span class="line"><span class="built_in">print</span>(de.popleft())  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">此外，队列支持许多列表中的方法，如下所示</span></span><br><span class="line"><span class="string">* count(x)  计算元素x出现的次数</span></span><br><span class="line"><span class="string">* index(x) - 查找出现给定值x的第一个位置</span></span><br><span class="line"><span class="string">* remove(x) - 删除第一个x出现的值</span></span><br><span class="line"><span class="string">* reverse() - 就地反转 deque </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同时，还有一个列表不支持的方法 --- rotate() 旋转，该方法如果理解循环队列就知道其作用了，就是让队列整个转一个元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">rotate_deque = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">rotate_deque.rotate()</span><br><span class="line"><span class="built_in">print</span>(rotate_deque)</span><br><span class="line"><span class="comment"># deque([4, 1, 2, 3])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;rotate()默认参数 1 ，即顺时针旋转一个元素，我们可以修改参数来控制旋转的方向和旋转长度&#x27;&#x27;&#x27;</span></span><br><span class="line">rotate_deque.rotate(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(rotate_deque)</span><br><span class="line"><span class="comment"># deque([2, 3, 4, 1])</span></span><br><span class="line">rotate_deque.rotate(-<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(rotate_deque)</span><br><span class="line"><span class="comment"># deque([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>

<h2 id="deque与list的区别"><a href="#deque与list的区别" class="headerlink" title="deque与list的区别"></a>deque与list的区别</h2><p>方法上的区别主要就是上面说的<code>left</code>以及旋转，这些都是针对队列特性做出的适应，队列的先进先出特性、双端队列、循环队列都可以实现。</p>
<p>从上面来看，队列的操作基本和列表一致，但是如果仅是如此的话，列表实现上述功能也是可以的，列表可以使用「切片」操作啊，那么<strong>队列的优势在哪</strong>？</p>
<ul>
<li>在<code>deque</code>  中，可以从左侧有效地追加和弹出元素（而在列表中，随着列表的增长，追加和弹出元素的速度会变慢）</li>
<li>在 <code>deque</code>中，可以通过参数 <code>maxlen</code> 控制<code>deque</code>  的最大尺寸 — 这一特性可以帮我们实现一些特殊操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  deque 参数 maxlen 将限制 deque 的最大长度 --- 这是队列非常重要的一个特性</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;当队列中的元素已经达到 maxlen 时，此时再向其中添加元素，则会把先进去的元素挤出去 --- 先进先出特性&#x27;&#x27;&#x27;</span></span><br><span class="line">deque_size = <span class="number">3</span></span><br><span class="line">deque_max = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=deque_size)</span><br><span class="line"><span class="built_in">print</span>(deque_max)</span><br><span class="line"><span class="comment"># deque([1, 2, 3], maxlen=3)</span></span><br><span class="line">deque_max.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(deque_max)</span><br><span class="line"><span class="comment"># deque([2, 3, 4], maxlen=3)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;如上所示，元素 4 将元素 1 挤出了队列&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这一特性，在实践中非常有用 — 滑动窗口 、缓冲区、历史记录  — 利用队列的「先进先出」特性</p>
<p>在处理数据流或时间序列时，你可能需要考虑一个<strong>固定大小的滑动窗口</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口</span></span><br><span class="line">‘‘‘</span><br><span class="line">计算最近 n 个数据点的平均值</span><br><span class="line">’’’</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">window_size = <span class="number">5</span></span><br><span class="line">window = deque(maxlen=window_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data_point <span class="keyword">in</span> data_stream:</span><br><span class="line">    window.append(data_point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Current rolling average: <span class="subst">&#123;<span class="built_in">sum</span>(window) / <span class="built_in">len</span>(window)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>由于使用的是生成器表达式和一次只能容纳一个元素的 <code>deque</code> ，这意味着您尽可能地节省了空间，这种方法应用到<strong>大文件中处理数据</strong>时，在空间上的效率就会非常方便</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找句子中的最后一个元音</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">&quot;The quick brown fox jumps over the last dog!&quot;</span></span><br><span class="line"><span class="comment"># The last vowel is an &#x27;o&#x27; --------------------------^</span></span><br><span class="line"></span><br><span class="line">vowels = <span class="built_in">set</span>(<span class="string">&quot;aeiouAEIOU&quot;</span>)</span><br><span class="line"></span><br><span class="line">last_vowel = deque((char <span class="keyword">for</span> char <span class="keyword">in</span> sentence <span class="keyword">if</span> char <span class="keyword">in</span> vowels), maxlen=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(last_vowel.pop())  <span class="comment"># o</span></span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No vowels found.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在实现网络协议或处理I&#x2F;O操作时，<code>maxlen</code> 可以作为一个<strong>缓冲区大小的限制</strong>，历史记录也是同理，存放一定数目的记录，越先记录的越先被删除</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">buffer = deque(maxlen=<span class="number">1024</span>)  <span class="comment"># 假设我们的最大缓冲区大小为1024字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> receiving_data:</span><br><span class="line">    buffer.append(new_data)</span><br><span class="line">    <span class="comment"># 处理buffer中的数据...</span></span><br></pre></td></tr></table></figure>

<p>更多的例子可以看<a target="_blank" rel="noopener" href="https://mathspp.com/blog/python-deque-tutorial"><code>deque</code> 教程</a>这篇文章的最后一节。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol>
<li><a target="_blank" rel="noopener" href="https://mathspp.com/blog/python-deque-tutorial">deque 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/collections.html#collections.deque">官方文档</a></li>
</ol>
]]></content>
      <categories>
        <category>Python-learn</category>
        <category>Python 库</category>
      </categories>
  </entry>
</search>
